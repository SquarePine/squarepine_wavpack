#include "CustomWavPack.h"

static const WavpackDecorrSpec fast_specs [] = {
        { 1, 2, {18,17} },
        { 1, 1, {17,17} },
        { 0, 2, {18,17} },
        { 0, 1, {17,17} },
        { 1, 3, { 1,18} },
        { 1, 1, {17, 1} },
        { 0, 1, { 1,17} },
        { 0, 1, {-2,17} },
        { 0, 2, {-1,17} },
        { 1, 1, {17, 2} },
        { 0, 3, {18,18} },
        { 0, 1, {17, 1} },
        { 1, 6, { 1, 2} },
        { 1, 1, {17, 3} },
        { 0, 1, {-2, 3} },
        { 0, 1, { 2,17} },
        { 0, 1, {18,-2} },
        { 0, 1, {-1,17} },
        { 0, 1, {18,17} },
        { 0, 1, {17, 2} },
        { 1, 2, {18,-2} },
        { 1, 1, { 1,17} },
        { 0, 3, {18, 2} },
        { 0, 1, {17,-2} },
        { 0, 1, {18,-2} },
        { 1, 2, {17,-3} },
        { 0, 1, {18, 3} },
        { 0, 1, {18,18} },
        { 1, 1, { 1, 3} },
        { 1, 1, {18, 3} },
        { 1, 1, { 1, 3} },
        { 0, 2, {18,17} },
        { 1, 1, { 1,17} },
        { 1, 1, {17, 3} },
        { 0, 3, {18,17} },
        { 0, 1, {18,18} },
        { 1, 1, { 1, 3} },
        { 1, 1, { 1,18} },
        { 0, 1, {18,-2} },
        { 0, 2, {18,17} },
        { 0, 1, {-1,18} },
        { 1, 1, {17, 3} },
        { 0, 1, {17, 2} },
        { 0, 1, {17, 3} },
        { 1, 1, {18, 2} },
        { 1, 1, {17,-2} },
        { 0, 1, { 1,-2} },
        { 0, 2, {18,17} },
        { 0, 1, {17,-2} },
        { 1, 1, {17,-2} },
        { 0, 1, {18, 3} },
        { 0, 1, { 2,17} },
        { 1, 2, {18,-3} },
        { 1, 2, { 1,18} },
        { 1, 2, {18, 2} },
        { 0, 1, {17,-1} },
        { 0, 1, {17,-2} },
        { 1, 1, {17,-2} },
        { 1, 1, { 1, 3} },
        { 0, 1, { 1,17} },
        { 1, 2, {18,-2} },
        { 1, 2, {17,-3} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 1, {17, 2} },
        { 1, 2, {18,18} },
        { 0, 1, {17, 2} },
        { 0, 1, {18,17} },
        { 1, 1, { 1,17} },
        { 1, 1, {17, 2} },
        { 0, 2, {18,18} },
        { 0, 2, {18,17} },
        { 1, 2, {17,-3} },
        { 1, 6, { 1, 2} },
        { 0, 3, {17,17} },
        { 0, 1, { 1,18} },
        { 0, 1, { 1,-2} },
        { 1, 1, {17, 2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 1, {18, 3} },
        { 1, 2, {17,-3} },
        { 0, 1, {17, 2} },
        { 0, 1, {17, 3} },
        { 0, 1, {18,-2} },
        { 1, 1, {18,18} },
        { 1, 6, { 1, 2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 1, {-1,17} },
        { 1, 1, {18, 3} },
        { 0, 1, {17,18} },
        { 1, 1, {17, 3} },
        { 0, 1, {18, 3} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 2, {18, 2} },
        { 0, 1, {-2, 3} },
        { 0, 4, {18,-1} },
        { 0, 2, {18,18} },
        { 0, 1, {-2, 3} },
        { 1, 1, {17,-2} },
        { 0, 1, {17, 3} },
        { 0, 2, {18,17} },
        { 0, 2, {-1,18} },
        { 1, 1, { 2,17} },
        { 0, 2, {17,-2} },
        { 0, 1, {17, 2} },
        { 1, 2, {18,-3} },
        { 0, 1, {17,-2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 1, {17,-2} },
        { 1, 2, {17,-3} },
        { 1, 1, { 1, 3} },
        { 1, 1, { 2,17} },
        { 1, 2, {18, 2} },
        { 1, 1, { 2,17} },
        { 1, 1, {18, 2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 1, {17,-2} },
        { 0, 2, {18,17} },
        { 0, 2, {17,-1} },
        { 0, 2, {18,-2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 1, { 1, 3} },
        { 0, 2, {-2,17} },
        { 0, 2, {18,-2} },
        { 0, 2, {17,-2} },
        { 1, 1, { 2,17} },
        { 1, 1, { 1, 3} },
        { 0, 1, { 2,17} },
        { 0, 2, {18,17} },
        { 0, 3, {-1,17} },
        { 1, 1, { 2,17} },
        { 0, 2, {18,18} },
        { 0, 1, {17, 2} },
        { 1, 4, {18,-3} },
        { 1, 1, {18, 1} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 2, {18,-1} },
        { 0, 1, {-1,18} },
        { 1, 6, { 1, 2} },
        { 1, 1, {17, 2} },
        { 1, 4, {18, 3} },
        { 0, 1, { 1,17} },
        { 0, 1, {18, 2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 2, {17, 2} },
        { 0, 2, {18,-2} },
        { 0, 1, { 1,18} },
        { 1, 2, {18,-3} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 2, {18,18} },
        { 1, 3, {17,17} },
        { 0, 1, {-2,17} },
        { 0, 1, {17,18} },
        { 0, 1, {-1, 3} },
        { 1, 1, { 2,17} },
        { 0, 2, {18,-1} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 1, {17,-2} },
        { 1, 2, {17, 2} },
        { 1, 1, {18, 3} },
        { 0, 1, {18, 2} },
        { 1, 2, {17,-3} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 1, {-2,17} },
        { 0, 1, {17,-1} },
        { 0, 1, {18,-1} },
        { 0, 2, {18,17} },
        { 1, 2, {17,-3} },
        { 1, 1, { 1,18} },
        { 1, 3, {18, 2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 3, {18,18} },
        { 0, 1, { 1,-2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 2, {17,-3} },
        { 1, 1, {18,18} },
        { 0, 2, {18, 2} },
        { 0, 1, {17,18} },
        { 1, 2, {18, 2} },
        { 1, 1, {17,-2} },
        { 0, 2, {17,-1} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 1, { 1,-2} },
        { 0, 1, {18, 1} },
        { 1, 2, {18,-2} },
        { 0, 1, {17, 2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 1, {17, 3} },
        { 0, 1, {17,-1} },
        { 0, 1, {18, 2} },
        { 1, 1, {17, 3} },
        { 1, 1, {17,-2} },
        { 0, 1, {18,18} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 1, {17,18} },
        { 0, 1, {-2, 3} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 2, {18,-3} },
        { 0, 2, {18,17} },
        { 0, 3, {18, 2} },
        { 0, 1, { 1,18} },
        { 0, 2, {18,17} },
        { 0, 1, {17,-1} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 1, {-2, 3} },
        { 0, 3, {17,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 1, {17, 2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 1, 1, {17, 2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18, 2} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
        { 0, 2, {18,17} },
};

static const WavpackDecorrSpec default_specs [] = {
        { 1, 2, {18,18, 2,17, 3} },
        { 0, 2, {18,17,-1, 3, 2} },
        { 1, 1, {17,18,18,-2, 2} },
        { 0, 2, {18,17, 3,-2,17} },
        { 1, 2, {18,17, 2,17, 3} },
        { 0, 1, {18,18,-1, 2,17} },
        { 0, 1, {17,17,-2, 2, 3} },
        { 0, 1, {18,-2,18, 2,17} },
        { 1, 2, {18,18,-1, 2, 3} },
        { 0, 2, {18,17, 3, 2, 5} },
        { 1, 1, {18,17,18, 2, 5} },
        { 0, 1, {17,17,-2, 2, 3} },
        { 0, 1, {18,-2,18, 2, 5} },
        { 0, 1, {17,-2,17, 2,-3} },
        { 1, 1, {17,-2,17, 1, 2} },
        { 0, 1, {17,17,-2, 2, 3} },
        { 1, 1, {18, 3, 1, 5, 4} },
        { 1, 4, {18,18, 2, 3,-2} },
        { 0, 1, { 1,-1,-1, 2,17} },
        { 0, 2, {18,17, 3, 2, 5} },
        { 0, 1, {18,18,18, 2,17} },
        { 0, 1, {18,17,-1, 2,18} },
        { 1, 1, {17, 3, 2, 1, 7} },
        { 0, 2, {18,-2,18, 2, 3} },
        { 1, 3, {18,-3,18, 2, 3} },
        { 0, 3, {18,17, 2, 3,17} },
        { 1, 1, {17,17, 2, 1, 4} },
        { 0, 1, {17,18,-2, 2,17} },
        { 1, 1, {18,18, 3, 5, 2} },
        { 0, 1, {17,17, 2,18, 4} },
        { 0, 1, {18,17, 1, 4, 6} },
        { 1, 1, { 3,17,18, 2,17} },
        { 1, 1, {17, 3, 2, 1, 7} },
        { 0, 1, {18,17,-1, 2, 3} },
        { 1, 1, {17,17, 2, 1, 4} },
        { 1, 2, {18,17,-1,17, 3} },
        { 1, 2, {18,17, 2, 3,-1} },
        { 0, 2, {18,18,-2, 2,17} },
        { 0, 1, {17,17, 2,18, 4} },
        { 0, 5, {-2,18,18,18, 2} },
        { 1, 1, {18,18,-1, 6, 3} },
        { 0, 1, {17,17,-2, 2, 3} },
        { 1, 1, {18,17,18, 2,17} },
        { 0, 1, {18,17, 4, 3, 1} },
        { 0, 1, {-2,18, 2, 2,18} },
        { 1, 2, {18,18,-2, 2,-1} },
        { 1, 1, {17,17, 2, 1, 4} },
        { 0, 1, {17,18,-2, 2,17} },
        { 1, 1, {17, 3, 2, 1, 7} },
        { 1, 3, {18,-3,18, 2, 3} },
        { 1, 2, {18,18,-2, 2,-1} },
        { 1, 1, {18,18, 3, 5, 2} },
        { 0, 2, {18,18,-1, 2,17} },
        { 0, 1, {18,-1,17,18, 2} },
        { 0, 1, {17,-1, 2, 3, 6} },
        { 0, 1, {18,-2,18, 2, 5} },
        { 1, 2, {18,18,-2, 2,-1} },
        { 0, 3, {18,18, 2, 3,17} },
        { 0, 1, {17,17, 2,18, 4} },
        { 1, 1, {17,-2,17, 1, 2} },
        { 0, 1, {-1, 3, 5, 4, 7} },
        { 0, 3, {18,18, 3, 2, 5} },
        { 0, 1, {17,17, 2,18, 4} },
        { 0, 1, {18,17,-2,18, 3} },
        { 0, 2, {18,18,-2, 2,17} },
        { 0, 3, {18,17,-2, 2, 3} },
        { 1, 1, {18,18,-2, 2,17} },
        { 0, 1, {18,17, 4, 3, 1} },
        { 1, 2, { 3,18,17, 2,17} },
        { 1, 2, {18,18, 2,-2,18} },
        { 1, 2, {18,18,-1,18, 2} },
        { 0, 2, {18,18,-2, 2,17} },
        { 1, 3, {18,18, 2, 3,-2} },
        { 0, 3, {18,18, 3, 2, 5} },
        { 0, 1, {18,-2,18, 2, 5} },
        { 1, 1, {17, 3, 2, 1, 7} },
        { 1, 3, {18,18,-2, 2,18} },
        { 1, 1, {17,18,18,-2, 2} },
        { 0, 1, {18,-2,18, 2, 5} },
        { 0, 2, {18,-2,18, 2, 3} },
        { 0, 1, {-1, 3, 4, 5, 7} },
        { 1, 1, {17,17, 2,-1, 7} },
        { 0, 1, {18,-1,-1, 2,-2} },
        { 0, 2, {18,17, 2, 3,17} },
        { 0, 1, {18,17, 2,18, 2} },
        { 0, 2, {18,17,-1, 2,17} },
        { 0, 1, { 1,18, 3, 2, 5} },
        { 0, 2, {18,-2, 4,18, 2} },
        { 1, 1, {18, 3, 1, 5, 4} },
        { 0, 1, {18,17,18, 2, 5} },
        { 1, 1, {18, 3, 1, 5, 4} },
        { 0, 4, {18,18,-2, 2,18} },
        { 1, 1, {18,18, 3, 2, 5} },
        { 1, 1, {17,17, 2, 1, 4} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 1, {18,18, 2, 1, 3} },
        { 1, 1, {17,17, 2, 1, 4} },
        { 1, 2, {17,17, 2,18, 3} },
        { 0, 1, {18,17, 1, 4, 6} },
        { 1, 2, {18,18,-2, 2,-1} },
        { 0, 1, {18,-2,18, 2, 5} },
        { 1, 1, {17, 2,18, 2,17} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 1, {18,18, 3, 6,-1} },
        { 0, 1, {18,17, 2,18, 3} },
        { 0, 1, {18,17,-2, 2,17} },
        { 1, 1, { 3,17,18, 2,17} },
        { 1, 3, {18,-3,18, 2, 3} },
        { 1, 3, {18,18,-3,18, 2} },
        { 1, 1, {18, 3, 1, 5, 4} },
        { 0, 1, {17,-2,17, 2,-3} },
        { 1, 1, {18,18, 3, 5, 2} },
        { 1, 2, {18,18,-2, 2,-1} },
        { 0, 1, {18,-1,-1, 2,-2} },
        { 1, 1, {18, 3, 1, 5, 4} },
        { 0, 3, {18,17,-1, 2,17} },
        { 1, 3, {18,17, 2,18,-2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 2, {18,18,-2, 2,-1} },
        { 1, 1, {18, 3, 1, 5, 4} },
        { 0, 4, { 3,18,18, 2,17} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 1, {18,17,-1,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 1, {18,18,18, 3, 2} },
        { 0, 1, {17,-1, 2, 3, 6} },
        { 0, 1, {17,-1, 2, 3, 6} },
        { 0, 2, {18,17,-2, 3, 2} },
        { 1, 3, {18,17, 2,-2,18} },
        { 0, 2, {18,18, 2,17, 3} },
        { 0, 1, {18,18, 2,18,-2} },
        { 0, 2, {18,-2, 4,18, 2} },
        { 0, 1, {-2,18, 2, 2,18} },
        { 0, 2, {18,17, 3, 6, 2} },
        { 0, 1, {18,17,18, 2, 5} },
        { 0, 3, {18,18,-2, 3, 2} },
        { 1, 1, {18,18, 2,18, 5} },
        { 0, 1, {17,-1, 2, 3, 6} },
        { 1, 4, {18,18, 2, 3,-2} },
        { 0, 2, {18,17,18, 2,-2} },
        { 0, 1, { 1,18, 3, 2, 5} },
        { 1, 4, {18,-2,18, 2, 3} },
        { 1, 2, {18, 2,18, 3,-2} },
        { 0, 2, {18,18,18, 2, 4} },
        { 0, 2, { 3,17,18, 2,17} },
        { 1, 1, {18,-1,18, 2,17} },
        { 1, 2, {17,17, 2,18, 3} },
        { 0, 2, {18,17,-2, 3, 2} },
        { 0, 1, { 1,-1,-1, 2,17} },
        { 0, 3, { 3,18,18, 2,17} },
        { 0, 1, {18,-1,17,18, 2} },
        { 0, 1, {18,17, 2,18, 3} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 1, {18,17, 2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 2, {17,17, 2,18, 3} },
        { 0, 1, {18,17,-2, 2, 3} },
        { 0, 1, {18,-2,18, 2, 5} },
        { 1, 4, {18,-2,18, 2, 3} },
        { 1, 3, {18,17, 2, 3, 6} },
        { 0, 2, {18,18, 2,17, 3} },
        { 0, 2, {18,17, 2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 1, {18,18, 3, 5, 2} },
        { 0, 2, {18,18,-2, 2, 3} },
        { 1, 2, {18,17, 2,17, 3} },
        { 0, 1, {18,17, 2, 3,18} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 4, {18,18, 2, 3,-2} },
        { 0, 1, {17,-2,17, 2,-3} },
        { 0, 1, {17,17, 2,18, 4} },
        { 1, 1, {18,18,18, 2, 4} },
        { 1, 2, {18, 2,18, 3,-2} },
        { 1, 1, {18,18,-2, 2,17} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18, 2,17, 3} },
        { 0, 2, {18,18,18, 2, 4} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,17,-2, 3, 2} },
        { 0, 1, { 1,-1,-1, 2,17} },
        { 1, 4, {18,18, 2, 3,-2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 1, {18,-2,18, 3, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 1, {18,18,-2, 2,17} },
        { 0, 3, {18,17, 2, 3,17} },
        { 1, 2, {18,18, 2,-2,18} },
        { 0, 1, {-1, 3, 5, 4, 7} },
        { 1, 1, {18, 3, 1, 5, 4} },
        { 1, 1, {18,18,-2,18, 3} },
        { 0, 2, {18,17,18, 2,-2} },
        { 0, 2, {18,18, 2,17, 3} },
        { 1, 2, {18, 2,18, 3,-2} },
        { 1, 4, {18,18, 2, 3,-2} },
        { 1, 3, {18,17, 2, 3, 6} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 2, {18,17,-2,-1,17} },
        { 0, 1, {17,-1, 2, 3, 6} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2, 2, 3} },
        { 1, 1, {18,18,18, 2, 5} },
        { 0, 1, {17,17,-2, 2, 3} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,17, 3, 6, 2} },
        { 0, 2, {18,17,18, 2, 3} },
        { 0, 3, {18,17,-3,18, 2} },
        { 0, 1, {18,18,18, 2, 3} },
        { 0, 1, {18,-2,-3, 2, 6} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 1, {18,17,18, 2, 5} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 1, {18,17,18, 2, 5} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 1, {18,18,18, 2, 3} },
        { 1, 1, {17,-2,17, 1, 2} },
        { 1, 1, {17,17, 2,-1, 7} },
        { 0, 1, {18,17, 4, 3, 1} },
        { 1, 3, {18,-3,18, 2, 3} },
        { 0, 1, { 1,18, 3, 2, 5} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 1, {18,18, 3, 6, 2} },
        { 0, 1, {17,17, 2,18, 4} },
        { 0, 1, {17,17, 2,18, 4} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 1, 2, {18,-2,18, 3, 2} },
        { 1, 1, {17,-2,17, 1, 2} },
        { 1, 1, {18,18, 3, 2, 5} },
        { 0, 1, {18,18,-1, 2, 3} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 1, {18,17,18, 2, 5} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 1, { 3,18,18, 2,17} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
        { 0, 2, {18,18,-2,18, 2} },
};

static const WavpackDecorrSpec high_specs [] = {
        { 1, 2, {18,18,18,-2, 2, 3, 5,-1,17, 4} },
        { 0, 1, {18,17,-2, 2,18, 3, 7, 2, 5, 4} },
        { 1, 2, { 1,18, 3, 6,-2,18, 2, 3, 4, 5} },
        { 0, 2, {18,18,-2, 2,18, 3, 6, 2,17, 4} },
        { 1, 2, {18,18, 2,18, 3, 2,-1, 4,18, 5} },
        { 1, 1, { 7, 6, 5, 3, 4, 2, 5, 4, 3, 7} },
        { 1, 1, {17, 3,18, 7, 2, 6, 1, 4, 3, 5} },
        { 1, 1, {-2,18,18,18, 3,-2, 6, 5, 2, 1} },
        { 1, 2, {18,18,-1,18, 2, 3, 6,-2,17, 5} },
        { 0, 1, {17,17,18, 3, 6, 4, 5, 2,18,-2} },
        { 1, 2, { 1,18,-2, 3, 5, 2, 4,-1, 6, 1} },
        { 0, 2, {18,18, 3, 6,18, 2, 4, 8, 5, 3} },
        { 0, 1, {-2, 1,18, 2,-2, 7,18, 2,-1, 5} },
        { 1, 1, { 4, 3, 8, 1, 5, 2, 5, 6, 2, 8} },
        { 1, 1, {17,18, 2, 6, 3, 4,-1, 1, 8, 6} },
        { 0, 1, {18,18, 3, 6, 3,-2, 2, 5,-1, 1} },
        { 0, 1, {18,18,17,-1, 2,-2,18, 3, 4, 5} },
        { 1, 2, {18,17, 2,-2,18, 3, 5, 7, 2, 4} },
        { 1, 2, {18,18, 3, 6,-2,18, 2, 5, 8, 3} },
        { 0, 1, {18,17, 2,18,18, 2, 6, 5,17, 7} },
        { 1, 2, {18,17, 2,18, 3, 2, 6,18,-1, 4} },
        { 1, 1, { 5, 3, 6, 5, 3, 4, 1, 2, 4, 7} },
        { 1, 1, { 5, 3, 6, 5, 3, 4, 1, 2, 4, 7} },
        { 0, 1, {-2,18,18,18,-2, 3, 2, 4, 6, 5} },
        { 1, 2, {18,17,-3, 3,-1,18, 2, 3, 6, 5} },
        { 0, 1, {17,18, 7, 3,-2, 7, 1, 2, 4, 5} },
        { 1, 1, { 2,18,18,-2, 2, 4,-1,18, 3, 6} },
        { 0, 3, { 1,18, 4, 3, 5, 2, 4,18, 2, 3} },
        { 0, 1, {-2,18, 2,18, 3, 7,18, 2, 6,-2} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {18,18, 5, 4, 6, 4, 5, 1, 4, 3} },
        { 1, 1, {18, 3, 6, 5, 7, 8, 2, 3, 1,-1} },
        { 1, 1, {18,18,18, 2,-2, 3, 5,18, 2, 8} },
        { 0, 2, {18,17,-2, 2, 3,18,-3, 5, 2, 7} },
        { 1, 1, { 1, 1,-1, 8,17, 3,-2, 2, 6,17} },
        { 0, 2, {18,18,17, 2,-2, 3, 2, 4,18, 5} },
        { 1, 1, {17,18, 2,-1, 5, 7,18, 3, 4, 6} },
        { 1, 1, { 5, 4, 5,17, 3, 6, 3, 4, 7, 2} },
        { 0, 1, {17, 3, 1, 7, 4, 2, 5,-2,18, 6} },
        { 0, 1, {17,18, 2,18, 4, 3, 5, 7,-3, 6} },
        { 1, 2, {17,17,-3,-2, 2, 8,18,-1, 3, 5} },
        { 0, 1, {17,17,18, 2, 3, 6,-2, 8, 1, 7} },
        { 1, 1, { 1, 2, 6,-2,18, 2, 5,-3, 7,-2} },
        { 0, 1, {18,18, 3,18, 6, 8,-2, 2, 3, 5} },
        { 0, 1, {18,17, 2,18,-2, 3, 7, 6, 2, 4} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {18,18, 2,-1, 3, 6, 1, 3, 4, 8} },
        { 0, 1, {18,18, 3, 6, 5, 3,-2, 2,18,-1} },
        { 0, 1, {18,17,-3,18, 2, 4,-2, 3, 6,17} },
        { 1, 3, { 1, 2,17, 3,18, 7,-1, 5, 2, 4} },
        { 1, 1, {18, 3,18, 6, 8,18,-2, 5, 7, 2} },
        { 0, 1, {17, 2,18, 6, 3, 2, 5, 4, 8, 1} },
        { 0, 1, {18,17,-1, 2, 3,18,18, 2, 3,17} },
        { 1, 1, {18, 7, 6, 5, 5, 3, 1, 4, 2, 4} },
        { 1, 1, { 6,17, 3, 8, 1, 5, 7,-1, 2, 1} },
        { 1, 1, {18,-2,18, 3,-2, 2, 7, 4, 6,18} },
        { 1, 3, {18,-3,18, 2, 3,18,-1, 7, 2, 5} },
        { 0, 2, {18,-2, 7, 1, 3, 2, 4, 6,-3, 7} },
        { 1, 1, {18,-2, 2,-3,18,-2,17,-1, 4, 2} },
        { 0, 3, {17,17, 2, 5, 3, 7,18, 6, 4, 2} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {18,17, 4, 6, 6, 4, 5, 3, 4, 1} },
        { 0, 1, {18, 5, 3, 6, 2, 3, 8, 1, 3, 7} },
        { 1, 2, {18,17,-2, 2,18, 3, 5, 7,-1, 2} },
        { 0, 1, { 1,18,18, 3, 6,-1, 4, 8, 5, 2} },
        { 1, 1, { 1, 5, 3, 4, 1, 1, 3, 5, 7, 3} },
        { 0, 1, { 3,18,18, 2,18,18,-1, 2, 3,18} },
        { 1, 2, {18,18,-1,18, 2, 3, 4, 6,18, 5} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {18, 3, 1, 4, 5, 2, 7, 1, 3, 6} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 2, {18,18,-1,18, 2, 3, 5,-2, 6, 8} },
        { 1, 1, {17,18, 4, 8, 3, 2, 5, 2, 7, 6} },
        { 1, 4, { 1, 2, 5,18,-2, 2, 3, 7,-1, 4} },
        { 0, 2, {18,17,-1, 3, 6,18, 2, 3, 7, 5} },
        { 0, 1, {-2,18, 2,-3, 6,18, 4, 3,-2, 5} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {17,17, 6, 2, 4, 8, 3, 5,-1,17} },
        { 1, 1, {18, 3,18, 6, 8,18,-2, 5, 7, 2} },
        { 1, 2, {17,17,-3, 2,18,-2, 8, 3, 6,-1} },
        { 1, 1, {18,-2,17,18, 2, 3,-2, 6, 5, 4} },
        { 1, 2, {18,17,-1, 3,18, 2, 5, 3, 6,-3} },
        { 0, 1, {18,17, 2,18, 7,18, 2, 4, 3,17} },
        { 1, 3, {18,18, 5, 6, 4, 3, 4,18, 6, 5} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, { 7, 6, 5, 3, 4, 2, 5, 4, 3, 7} },
        { 0, 1, {-2,18,18,18, 3, 6, 4, 2, 5, 2} },
        { 0, 3, {18,17,-3,18, 3, 2, 5,-1,17, 3} },
        { 1, 1, {17,18, 7, 3, 1, 7, 4, 2, 6, 5} },
        { 1, 1, {18, 2,-2,-1,18, 5, 3,-2, 1, 2} },
        { 0, 3, {18,18,-1, 3, 2, 7, 5,18, 4, 3} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {17,18, 2,-2, 4, 8,18, 3, 6, 5} },
        { 0, 2, {18,17, 3, 5,-2, 7, 2,18, 3,-1} },
        { 1, 1, {18, 2,-2,-1,18, 5, 3,-2, 1, 2} },
        { 0, 2, { 3,17,18,18, 2, 5, 7, 6,18, 3} },
        { 1, 1, {17,18,18, 4, 3, 2,18, 7, 8,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {17, 1, 2, 3, 5, 6, 1, 4, 8,17} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 2, {18,17,-1,18,-3, 2, 8, 3, 6,17} },
        { 1, 1, {17,17, 1, 2, 4, 5,-1, 2, 1, 6} },
        { 1, 1, { 1, 2, 6,-2,18, 2,-3, 3,-2, 5} },
        { 0, 1, {18, 3,18, 6,18, 5, 2, 4,-1, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {18,18,-1, 2,18, 3, 6, 4,-2, 7} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 2, {-1,18,18,18, 2,-2, 4, 7, 2, 3} },
        { 0, 3, { 3,17,-2, 5, 2, 7,18, 6, 4, 5} },
        { 0, 1, {17, 6,18, 3, 8, 4, 5, 3, 8,18} },
        { 0, 2, {18, 2, 6, 2,18, 3, 2, 4, 5, 8} },
        { 0, 1, { 3,18,18, 2,18,-1, 2,18, 2,17} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, { 3, 6,17,-2, 5, 1, 2, 7, 4, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 3, { 3,18,17, 5, 6, 2, 7,-2, 8,18} },
        { 1, 1, {18,-1, 3, 1, 7, 2,-1, 4, 6,17} },
        { 1, 1, {18, 2,-2,-1,18, 5, 3,-2, 1, 2} },
        { 0, 2, {18, 1, 2,18, 3, 6, 5, 2, 4, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {17,-2, 2,18,18, 8, 5, 3, 2, 6} },
        { 0, 1, {18,17, 2,18, 3, 2, 7,-2,18, 4} },
        { 1, 2, { 1,18, 2, 3,-1, 5, 6, 4, 7,17} },
        { 0, 2, {18,17, 3, 6,-2, 2, 3, 8, 5,17} },
        { 0, 2, {18,18, 3, 2,18,-1, 2, 4, 3,17} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 2, {17,-1,18, 2, 3,-2, 5,18, 2, 7} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 2, {18,-3,18, 2, 3,-2,18, 5, 6,-3} },
        { 0, 2, {18,17, 3, 5,-2, 7, 2,18, 3,-1} },
        { 1, 1, { 1,18,-1, 2, 3, 1,-2, 8, 2, 5} },
        { 0, 1, {18,18, 3, 6,18, 2, 3, 4, 8, 5} },
        { 0, 1, {-2, 1,18, 2,-2, 5, 7,18, 2,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {17,18,-1, 2, 8, 3, 4, 5, 1, 7} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 2, {18,18,-1, 2,18, 3,-2, 5, 4, 2} },
        { 1, 1, {18,17, 2,18, 3, 8, 5, 2, 7,17} },
        { 0, 1, {18,18, 3,18, 6, 8,-2, 2, 3, 5} },
        { 0, 1, {18,18, 2,18, 2, 6,18, 2,17, 7} },
        { 1, 3, {18,17,18, 2, 8,18, 5,-1, 3, 6} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {18, 7, 6, 5, 5, 3, 1, 4, 2, 4} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 2, {18,17,-1, 3, 6,18, 2, 5, 8, 3} },
        { 0, 1, {17,18,18, 4, 7, 2, 3,-2,18, 5} },
        { 1, 2, {18, 1, 2, 6, 2, 5,18, 2, 4, 8} },
        { 0, 4, {18, 4, 1, 2, 3, 5, 4, 1, 2, 6} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 2, {18,17, 2,-1,18, 3,-3, 5, 2, 4} },
        { 0, 1, {17,17, 3, 6, 3, 5,-2, 2,18,-1} },
        { 0, 2, {18,18, 3,-2,18, 2,-3, 5, 3, 6} },
        { 1, 1, {17,17, 2, 4, 1, 3, 5, 2, 6,-3} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {17, 1, 3, 2, 7, 1, 6, 3, 4, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {17,-1,18, 2, 1, 5, 3, 8,-1,-2} },
        { 1, 1, {17,18,-1, 8, 2, 5, 3, 4, 1, 6} },
        { 1, 2, { 1,18, 3,-1, 5, 1, 2, 4, 7, 6} },
        { 0, 1, {18,18, 3, 6, 5, 3,-2, 2,18,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, { 1,18,-1, 3, 8, 5, 6, 1, 2, 3} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 2, {18,18, 2, 3, 6,18,-1, 4, 2, 3} },
        { 1, 1, { 1, 3, 5,18, 2, 6, 7, 2, 3, 1} },
        { 1, 1, { 1, 3, 8,18, 5, 2, 7, 1, 3,-2} },
        { 0, 2, {17, 2,18, 3, 6, 2, 4, 5, 8, 3} },
        { 0, 1, {18,17, 2,18, 3, 2, 7,-2,18, 4} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 2, {18,-3,18,-1, 3,-2, 5, 7, 1, 2} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 3, {18,18, 2, 6,18, 5,18, 2, 3,17} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 3, { 1,-1, 1, 3,-2, 2, 5, 7,-3,18} },
        { 1, 2, {18, 7, 3,-3, 2, 8, 2, 5, 4,17} },
        { 1, 1, { 1, 4, 5, 1, 3, 4, 6, 7, 8, 3} },
        { 0, 1, {18,17, 2,18,-1, 2, 3,18, 2, 4} },
        { 0, 2, {18,18,-2,18, 2, 3, 4, 7, 5,17} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {17,18, 2, 1, 3, 2, 5, 1, 2, 3} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 2, {18,18,-1, 2, 3, 5, 8, 6, 1,-2} },
        { 0, 1, {17,18, 8, 3, 4, 6, 5, 2, 8, 7} },
        { 1, 2, { 1, 3,-2,18, 2, 5, 1, 7,-1,-2} },
        { 0, 3, {18,17,-1, 3,18, 2, 3, 6, 4,17} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 2, {18,18, 4,18, 6, 7, 8, 3,18, 2} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 2, {17,-3,17, 2,-2, 8, 3,18, 4,-3} },
        { 1, 1, {18,17, 3, 5, 6, 2, 8, 1, 3, 7} },
        { 0, 1, {18,18, 3, 6, 5, 3,-2, 2,18,-1} },
        { 0, 3, {18,18, 2, 6,18, 5,18, 2, 3,17} },
        { 1, 1, {18,18, 5, 4, 6, 4, 5, 1, 4, 3} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 2, { 3,17,18,-3, 2, 5,18, 6,-1, 7} },
        { 1, 1, {17,18, 3, 2, 5,-1, 6, 8, 4, 7} },
        { 1, 1, {18, 1,-2, 3, 2, 1, 7, 6, 3, 4} },
        { 0, 3, { 1, 2,17, 3,18, 2, 7, 5, 4,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, {17,-2, 2,18,18, 8, 5, 3, 2, 6} },
        { 0, 2, {18, 5,18, 2, 3, 7,-2, 1, 6, 8} },
        { 0, 1, { 2,-1,18,-1, 2, 4,-3, 5,18, 3} },
        { 0, 1, { 3,17,18, 5, 2,18, 7, 3, 6, 5} },
        { 1, 4, { 1, 2, 5,18,-2, 2, 3, 7,-1, 4} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, { 1,18, 2, 1, 3, 4, 1, 5, 2, 7} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {17,17,18, 2, 4, 5,18,-2, 6, 3} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 2, {18,18,-1, 3, 5, 6, 8,18, 2, 3} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {18,18, 4, 6, 8,18, 7, 3, 2, 5} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 2, {-1,18,18,18, 2, 4,-2, 2, 3, 6} },
        { 0, 2, {18,-2, 7, 1, 3, 2, 4, 6,-3, 7} },
        { 1, 1, {17,18, 8, 3, 4, 6,-2, 5, 3, 8} },
        { 0, 2, {18, 1, 2, 6, 2, 8, 3,18, 5, 4} },
        { 1, 1, { 3,18,18, 2,18, 2,18, 3, 2,18} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 1, 1, { 3,17,18, 5, 2, 6, 7, 1, 4, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2, 8} },
};

static const WavpackDecorrSpec very_high_specs [] = {
        { 1, 2, {18,18, 2, 3,-2,18, 2, 4, 7, 5, 3, 6, 8,-1,18, 2} },
        { 0, 1, {18,18,-1,18, 2, 3, 4, 6, 5, 7,18,-3, 8, 2,-1, 3} },
        { 1, 2, { 1,18,-2, 4,18, 2, 3, 6,-1, 7, 5,-2,18, 8, 2, 4} },
        { 0, 1, {17,17, 2, 3, 4,18,-1, 5, 6, 7,18, 2, 8,17, 3,-2} },
        { 1, 1, {18,18, 2,18, 3, 2,18, 4,-1, 3,18, 2, 6, 8,17, 5} },
        { 0, 2, {18,17, 2, 3,-2, 5,18,-3, 2, 4, 7, 3, 6, 8, 5,17} },
        { 1, 1, {18,-2, 2,-3,18, 5,-2,18, 2, 3, 6, 2,17, 4, 7,-1} },
        { 1, 1, {17, 8,18, 3,-2, 2, 5, 4,18, 6, 3, 8, 7, 2, 5, 4} },
        { 0, 2, {18,17,-2, 2,18, 3, 2, 5,-3, 4, 7,18, 3, 8, 6, 2} },
        { 1, 1, { 3, 6, 5, 5, 1, 3, 7, 4, 2, 6, 4,18, 3, 7, 5, 6} },
        { 1, 2, { 1,18, 3, 2,-2, 1, 5, 4, 6, 2, 7, 1, 8, 3,-1, 1} },
        { 0, 1, {18,18, 2, 3, 6, 3, 5,-2, 2, 4,18, 3,-2,-1, 6, 7} },
        { 0, 1, {-2,18, 2,18, 7, 2, 6,-2, 3, 4,18,18, 2,-3, 8, 5} },
        { 0, 2, {18,18,18, 2, 4, 3,18, 5, 3, 6,-2, 2, 4,18, 8, 7} },
        { 0, 1, {-2, 1,18, 2,-2,18,-1, 5, 7, 2, 3, 4,18, 2, 6, 2} },
        { 1, 1, {17,18, 3, 2, 1, 7,-1, 2, 4, 3, 5, 6,-2,18, 7, 8} },
        { 1, 1, {18,18, 2,18, 3, 4, 6,-2,18, 5, 8, 2, 3, 7, 4,-1} },
        { 0, 1, {18,18,18,-1, 2, 3, 4, 6, 8,18, 3, 5, 2, 6, 7, 4} },
        { 1, 1, {17,-2,18,18, 2, 5, 3, 8, 2,-1, 6, 1, 3, 4, 7, 5} },
        { 0, 1, {17,17,18, 2, 3, 6,-2, 8, 1, 7, 5, 2, 3, 1, 4, 8} },
        { 1, 1, {17,17, 3, 2, 7, 1, 4, 3, 6, 2, 5,-2, 8, 7,18, 6} },
        { 0, 1, {18,17,-2, 2,18, 3,-3, 7, 6, 5, 2, 4,-1, 8, 3,17} },
        { 1, 1, { 2,18,18,-2, 2, 4,-1, 5,18, 3, 8, 6, 2, 7,17, 4} },
        { 0, 1, {17, 3, 6, 8, 5, 4, 3, 8, 1,18, 7, 2, 4, 5, 6, 3} },
        { 1, 2, {17,18, 4, 8, 3, 2, 5, 7, 6, 8, 2, 7,-2,18, 3, 4} },
        { 1, 1, { 6, 5, 5, 3, 4, 7, 3, 2, 4, 6, 3, 7, 1, 5, 2, 4} },
        { 1, 1, { 1,18,-1, 2, 1, 3, 8,-2, 2, 5, 6, 3, 8, 7,18, 4} },
        { 0, 1, { 1,17,-1,18, 3, 2, 5, 4, 6, 7, 8, 3, 4, 2, 1,-2} },
        { 0, 1, {18, 2,18,18, 2,18, 6,-2,18, 7, 5, 4, 3, 2,18,-2} },
        { 0, 3, { 1, 4,18, 3, 2, 4, 1, 5, 2, 3, 6,18, 8, 7, 2, 4} },
        { 0, 1, {17,-2, 1,-3, 2,18, 3,-2, 4,18, 3, 6, 7,-3, 2, 8} },
        { 1, 1, {17,18,18, 4, 2, 3, 7, 6,18, 8, 5,-1, 4, 2, 3,17} },
        { 1, 2, {18,-1,17,18, 2, 3,-2,18, 5, 8, 2, 4, 3, 7, 6,-1} },
        { 1, 1, {18,18,18,-2, 4, 2, 3,18, 5, 8, 2, 4, 6, 7,-2, 3} },
        { 1, 2, {18,18,-2,18,-1, 3, 2, 5,18,-2, 7, 2, 3, 4, 6, 8} },
        { 0, 1, {17,18,-1, 2, 4,18, 8, 3, 6, 5, 7,-3, 2, 4, 3,17} },
        { 1, 1, {18,18,17, 2,-1,18, 3, 2,18, 6, 5, 4,18, 7, 2,-1} },
        { 0, 2, { 1,18,-1,18, 3, 2, 4, 6,-3, 7,-1, 5, 1, 2, 3, 8} },
        { 1, 1, { 1,17,-2, 2,-3, 6, 3, 5, 1, 2, 7, 6, 8,-2, 4, 1} },
        { 0, 1, {17,-1, 5, 1, 4, 3, 6, 2,-2,18, 3, 2, 4, 5, 8,-1} },
        { 0, 2, {18,18,17, 2, 3,-2, 5,18, 2, 4, 7, 8, 6,17, 3, 5} },
        { 1, 1, { 1, 5, 1, 3, 4, 3, 7, 5, 1, 3, 6, 1, 2, 4, 3, 8} },
        { 1, 2, { 1,-1, 3, 2,18, 7,-2, 5, 2, 6, 4, 3,-1,18, 8, 7} },
        { 0, 2, {18,17, 3,18, 2, 5, 4, 3, 6, 2, 7, 8,18, 3, 4, 5} },
        { 1, 1, { 3, 6,17, 8, 7, 5,18,-1, 1, 2, 3, 4, 2, 6, 8, 1} },
        { 0, 2, {18,18, 3,-3,18, 2, 6, 5, 3, 7,18, 4,-2, 8, 2, 3} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {17, 1, 7, 2, 3,18,-2, 3, 6, 4, 2, 7, 8, 5, 3,17} },
        { 1, 1, { 3, 6, 5, 5, 1, 3, 7, 4, 2, 6, 4,18, 3, 7, 5, 6} },
        { 0, 1, {18,18,18, 2, 4,-1,18, 8,-1, 2, 3, 4, 6,-2, 1, 7} },
        { 1, 1, {18,-2,17,18, 2, 6, 3,-2, 5, 4, 7, 1,-3, 8, 2, 6} },
        { 0, 1, {17,18,18, 4, 2, 7, 3, 6,-2,18, 8, 4, 5, 2, 7,17} },
        { 1, 1, {18,18, 5, 4, 6, 4, 1, 5, 4, 3, 2, 5, 6, 1, 4, 5} },
        { 0, 1, {18,18,-2,18, 2,-3, 3, 8, 5,18, 6, 4, 3,-1, 7, 2} },
        { 1, 1, {18, 2,-2,-3,18, 5, 2, 3,-2, 4, 6, 1,-3, 2, 7, 8} },
        { 0, 1, {18, 3, 5, 8, 2, 6, 7, 3, 1, 5, 2,-1, 8, 6, 7, 4} },
        { 1, 1, { 4, 3, 8, 1, 5, 6, 2, 5, 8,-2, 2, 7, 3,18, 5, 4} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {17, 3,18,18, 7, 2, 4,18, 6, 2, 3,-1, 8, 5,18,-3} },
        { 0, 1, { 3,17,18, 2,18, 6, 7,-3,18, 2, 5, 6, 3, 8, 7,-1} },
        { 1, 1, {18,18, 2,18,18, 2,-1, 7, 3,18, 5, 2, 6, 4,-1,18} },
        { 0, 3, {18, 3, 4, 1, 5, 2,18, 4, 2, 3,18, 7, 6, 1, 2, 4} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {17, 1,18, 2, 3, 6, 4, 5, 7,18, 3, 8, 2, 4,-2,17} },
        { 1, 2, {18,17, 2, 3, 5,18, 6,-2, 7, 3, 2, 4,18, 8,-1, 5} },
        { 0, 2, { 1,18,-1,18, 3, 2, 4, 6,-3, 7,-1, 5, 1, 2, 3, 8} },
        { 1, 1, { 1,18,-1, 8, 2, 6, 3,-2, 1, 2, 5, 4,-3, 8, 6, 3} },
        { 0, 1, {18,18, 2,18, 2,18, 7, 6,18, 2,-2, 3, 5, 4,18, 8} },
        { 1, 2, {18,17, 2, 3,18,-1, 2, 3, 6,18, 5, 4, 3, 7, 2, 8} },
        { 1, 2, {18,18, 3,-2, 4,18, 5, 7, 6, 2, 4,-3, 8, 5,18, 3} },
        { 1, 1, {17,-2,18,18, 2, 5, 3, 8, 2,-1, 6, 1, 3, 4, 7, 5} },
        { 1, 1, { 3,17,18, 5, 7, 2, 4, 6, 1, 8,-1, 3, 7, 4, 1, 2} },
        { 0, 2, { 1,-2, 2,18, 3, 5, 2, 4, 7,-1, 2, 3, 5,18,-2, 4} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, { 1, 2,-2, 6,18,-3, 2, 7, 3,-2, 5, 6, 1, 8, 2, 4} },
        { 0, 1, {18,18,18, 3,-2, 6,18, 2, 4, 3, 5, 8, 7, 6, 2,-2} },
        { 1, 1, { 1, 5, 1, 3, 4, 3, 7, 5, 1, 3, 6, 1, 2, 4, 3, 8} },
        { 0, 1, { 3,17,18, 2, 5,18, 6, 7, 5,-2, 2, 4,18, 3, 6, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 2, {17,-1,18, 2, 4,-1, 8, 3,18, 7,-3, 4, 5, 1, 2,-2} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 8, 6, 4, 5, 7,-1} },
        { 1, 1, {18,18, 3, 6, 4, 8,-2, 2, 5, 3, 7,18, 6, 8, 4, 2} },
        { 1, 1, {17,18,18,-2, 5, 2, 3, 1, 4,-1, 8, 6, 5, 3, 2,18} },
        { 1, 1, {17,17, 1, 2, 4, 5, 2, 6,-1, 3, 1, 1,-2, 4, 2, 7} },
        { 1, 1, {17, 1, 7, 2, 3,18,-2, 3, 6, 4, 2, 7, 8, 5, 3,17} },
        { 0, 1, {18,17,-2,-3, 1, 2, 3, 2, 5, 4, 7,-3, 6,-2, 2, 1} },
        { 1, 1, { 1, 3, 5,18, 1, 2, 7, 3, 6, 2, 5, 8,-1, 1, 4, 7} },
        { 1, 1, {17, 3, 6, 8, 1, 4, 5, 3,-2, 7, 2, 8, 5, 6,18, 3} },
        { 1, 1, {17,18, 2, 4, 8,-2, 3, 1, 5, 6, 7, 1, 2, 3, 4, 7} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, { 3, 1, 8,18, 5, 2, 3,18, 6, 7,-2, 4, 3, 2, 8,18} },
        { 0, 1, {18,17, 2,18, 3, 4,-1,18, 7, 6, 2, 8, 4,18,18, 5} },
        { 0, 1, {18,18, 2,18,18, 2, 7,-2, 6, 5, 4, 3,18, 3, 2,17} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {17, 8,18, 3, 2, 1, 5, 4, 6,-1, 3,-3, 8,18, 7, 2} },
        { 1, 2, {18,17,18, 2, 3, 5,-2,18, 6,-1, 2, 3, 7, 4, 8,17} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 8, 6, 4, 5, 7,-1} },
        { 1, 2, {18,18,-2,17, 2,18, 3, 4,18, 8, 7,-1, 2, 4, 5,17} },
        { 0, 2, {17,-3,17, 3, 2,-2,18, 8, 4,-3, 2,18, 5, 3,-2, 6} },
        { 0, 1, {18,18, 2,18,18, 2, 7,-2, 6, 5, 4, 3,18, 3, 2,17} },
        { 0, 2, { 1,18,-1, 3, 5, 2,-3,18, 7, 3,-1, 6, 4, 2,17, 5} },
        { 1, 1, {17,-2,17, 2,-3, 1, 5,-1, 4, 6, 3, 2, 8, 7,-2, 5} },
        { 1, 1, { 1,18, 1, 3, 5, 8, 6, 2, 3,-1, 7, 1, 4, 8, 5,-3} },
        { 0, 2, { 3,18,18, 2,18,-2, 6, 5, 7, 2, 4,18, 3, 6,-3, 5} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, { 3, 6,17, 8, 7, 5,18,-1, 1, 2, 3, 4, 2, 6, 8, 1} },
        { 0, 4, {18, 2,17, 3,18,-2, 2, 6,18, 2, 7, 3, 5, 4, 8,18} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {18,18, 2, 3, 6, 3, 5,-2, 2, 4,18, 3,-2,-1, 6, 7} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {17, 1, 2, 5, 3,-2, 1, 4, 3, 7, 6,-3, 2, 1, 1, 2} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {18,18,-2,18,-2, 2, 3, 6,18, 4,-1, 2, 3, 8, 1, 4} },
        { 1, 1, {17,-2,17, 2,-3, 1, 5,-1, 4, 6, 3, 2, 8, 7,-2, 5} },
        { 0, 1, {17,17,18, 3, 2,18,18, 6, 8, 2,-2, 3, 5, 4,17,18} },
        { 1, 1, { 1, 5, 1, 3, 4, 3, 7, 5, 1, 3, 6, 1, 2, 4, 3, 8} },
        { 1, 1, { 1, 3,-3,18,18, 6, 5,18, 2,-1, 3, 8, 7,-3, 4,17} },
        { 1, 1, {18, 1, 2, 1, 3, 8, 7, 4, 1, 5, 2,-1,-3,18, 6, 2} },
        { 0, 1, {18, 3, 5, 2, 6, 8,18, 5, 7, 2, 3,-1, 6, 7, 8, 5} },
        { 0, 2, {18, 3,-2, 7, 8, 2, 5, 4,-3, 8, 3, 2,18, 5, 4, 6} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 3, { 1, 1, 2, 5, 2, 7, 4, 3,-1,18,-2, 8, 2, 1, 6, 7} },
        { 0, 1, { 3,17,18, 5, 2, 6, 7,18, 4, 5, 3, 6,18, 2, 7, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, { 1,18, 1, 2, 3, 5, 1, 2, 6, 7, 4, 3, 8, 1,17, 5} },
        { 1, 2, {17,-1,18,-2, 2, 3, 5,18, 2, 4, 6, 7, 3,-1, 5, 8} },
        { 1, 1, {18,18,-3,18,-2, 2, 3,-2,18, 6, 4, 5, 8, 3,17,-3} },
        { 1, 1, {18, 7, 6, 5, 5, 3, 1, 4, 2, 7, 3, 4,-3, 6,18, 8} },
        { 0, 2, {18,18, 2, 3, 5,18, 2, 4, 3, 6,18, 7, 8,-1, 5, 2} },
        { 0, 1, {18,17,-1, 2,18, 3, 2,18, 4, 3,18, 2, 6, 5, 8,17} },
        { 0, 2, {18,17, 2, 3,18, 5,-1, 6, 7, 8, 2, 3, 4, 5,18, 6} },
        { 1, 2, {18,-3,18, 2, 3,-2,-3, 5,18, 7, 6, 2, 4, 3, 8,-2} },
        { 1, 1, {17,18,18,-2, 2, 3, 5, 4, 8,18,-1, 5, 3, 6,-2, 7} },
        { 1, 2, {18,17, 2,-2,18, 3,-1, 4,18, 2, 7, 5, 3, 8, 6, 4} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, { 1, 5, 1, 3, 4, 3, 7, 5, 1, 3, 6, 1, 2, 4, 3, 8} },
        { 0, 2, {18,18, 3, 3,-2, 2, 5,18, 6, 3,-1, 4, 7,-1, 1, 2} },
        { 0, 1, {-2, 1,18, 2,-2, 5, 7,18, 3, 2, 6, 2,-1, 4,-2,17} },
        { 0, 2, {18,18,18, 2, 3,-2,18, 5, 4, 2, 6, 8, 3,-2, 4,18} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {17,18,-1, 3, 2, 5, 1, 3, 2, 8, 4, 7, 6, 2,-1, 5} },
        { 1, 1, {17,18,18, 4, 2, 3, 7, 6,18, 8, 5,-1, 4, 2, 3,17} },
        { 0, 1, {18,18,-2,18, 2, 3, 4, 5, 6,18, 8, 2, 3, 7,-2, 4} },
        { 0, 1, {18,-2,18,18,-3,-2, 2, 3, 5, 8, 1, 2, 6, 4, 7,-1} },
        { 0, 1, {18,17, 2,18, 3,-2, 2, 7, 6, 4,18, 3, 8, 7, 4, 2} },
        { 1, 1, {17,18,18, 4, 2, 3, 7, 6,18, 8, 5,-1, 4, 2, 3,17} },
        { 1, 1, {18,17,18, 2, 5, 3,-2,18, 6, 2, 3, 4, 8, 7, 5,-1} },
        { 0, 1, { 2,-1,18,-1, 2, 4,-3,18, 5, 3, 6,18, 2, 4, 7, 8} },
        { 1, 1, {17,18, 8, 3, 6, 4,-1, 5, 2, 7, 3, 8, 6, 5,18, 4} },
        { 0, 2, {18, 3,-2, 7, 8, 2, 5, 4,-3, 8, 3, 2,18, 5, 4, 6} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, { 1,18,-1, 8, 2, 6, 3,-2, 1, 2, 5, 4,-3, 8, 6, 3} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {17,18,18, 4, 2, 7, 3, 6,-2,18, 8, 4, 5, 2, 7,17} },
        { 1, 2, {18,-1,18, 3,-2,18, 2, 5, 3, 6, 7, 2,-1,18, 8, 4} },
        { 1, 2, { 1,18,-2, 4,18, 2, 3, 6,-1, 7, 5,-2,18, 8, 2, 4} },
        { 1, 2, { 1,18,-3, 2, 3,18,-1, 5, 6, 2, 8, 3, 4, 1,-2, 7} },
        { 0, 1, { 1,17,-1,18, 3, 2, 5, 4, 6, 7, 8, 3, 4, 2, 1,-2} },
        { 1, 1, {18,17,18, 4, 3, 5, 1, 2, 6, 3, 4, 7, 1, 8, 5, 2} },
        { 0, 1, {18,-2, 7, 1, 3, 2,-3, 4, 6,-2, 7, 8, 1, 5, 4, 3} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 2, {18,18,18,-2, 2, 5, 3, 7,18, 2, 4,-3, 5, 6, 3, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 3, { 3,18,-1, 5, 2, 7,18, 6, 5, 2, 4, 3,-1, 7,18, 6} },
        { 0, 2, {18,18,18, 4, 3, 2, 6, 4, 8,18, 5, 3, 2, 7,-2, 6} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 2, {18,18,18, 2, 3,-2,18, 5, 4, 2, 6, 8, 3,-2, 4,18} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {17, 8,18, 3, 2, 1, 5, 4, 6,-1, 3,-3, 8,18, 7, 2} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18,18, 2, 4, 6,-2, 2, 8, 3, 4,18, 7,-1, 6} },
        { 0, 1, {18, 1,-2, 2, 4, 1, 3,-1, 2, 5, 7, 1, 6, 8,-2,17} },
        { 0, 1, {17,17,18, 2, 5, 4,18, 3, 8, 7, 4, 6, 8, 1, 5, 2} },
        { 1, 2, {18,18, 5, 4, 6, 3, 4,18, 8, 4,-1, 7, 5, 3, 6, 2} },
        { 0, 1, {18,18,-3,18, 3, 6, 2, 5, 7,18, 3, 8,-1, 4, 5, 2} },
        { 1, 1, {18, 2,-2,-3,18, 5, 2,-2, 4, 3, 6,18, 8,-1, 2, 7} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {17, 1, 7, 2, 3,18,-2, 3, 6, 4, 2, 7, 8, 5, 3,17} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {17,18, 3,18, 2, 5, 4, 7,-3, 6, 3, 2,18, 4, 7, 3} },
        { 1, 1, { 1, 7, 4, 5, 3, 4, 5, 1, 3, 6, 3, 2, 4, 8,-2, 7} },
        { 0, 1, { 1,18,-1,-2,18, 3, 2,-1, 6, 7, 4, 5, 3,18, 2,-3} },
        { 1, 1, {18,18,-1, 3, 6,18, 5, 4, 8, 2, 3, 6,18, 7, 4,-2} },
        { 0, 2, {18,18, 2, 6,18, 2,18, 5, 3,18, 2, 4, 7, 8, 3,18} },
        { 1, 1, { 3,18,18, 5,18, 6, 2, 4, 7,-2,18, 5, 8, 6, 3, 2} },
        { 0, 1, {18,-2, 7, 1, 3, 2,-3, 4, 6,-2, 7, 8, 1, 5, 4, 3} },
        { 1, 1, {18,-2,18, 2, 5,18, 3,-2, 4, 7, 2,-1, 8, 6, 5, 1} },
        { 1, 1, {17,17, 5,18, 4, 1, 2, 8, 6, 4,-2, 3, 5,-1, 1, 8} },
        { 0, 2, { 1, 2,17, 3, 7,18, 2,-1, 4, 5,18, 2, 7, 3, 6, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, { 3, 6,17, 8, 7, 5,18,-1, 1, 2, 3, 4, 2, 6, 8, 1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 2, {18,18,18, 2,-2, 3, 6, 4, 8,18, 2, 5, 7, 4, 3, 6} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {18, 1, 8, 3, 5, 6, 4,-1, 8, 3, 7,18, 2, 5, 8, 4} },
        { 1, 1, {17,18, 5, 2, 4, 3, 1, 6,-2, 1, 3, 2, 4, 5,-1,17} },
        { 1, 1, {18,17, 2,18, 3,-3, 7, 2, 6, 4, 3, 5,18, 8, 2,-2} },
        { 1, 1, {18,17,18, 4, 3, 5,-1,18, 2, 7, 8, 4, 6, 3,18, 5} },
        { 0, 1, {18,17,18,-2, 2,-3, 3, 4, 8, 5, 2,18, 6, 3, 7,-2} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {17,18, 8, 3, 4, 6,18, 5,-2, 3, 8, 5, 2, 4, 7, 6} },
        { 0, 1, {18,-2, 3, 5, 1, 7, 3, 2, 6,-3, 4, 1, 5, 8, 3,-2} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, { 3,17,18, 5,-1,18, 2, 6, 7,18, 5, 3,-3,-1, 6, 2} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 3, {18,17,-2, 3,-1,18, 2, 5, 3, 7, 6, 2, 4, 8,18, 5} },
        { 0, 1, {18,-1,18, 2,18, 3, 5,18, 2, 8,18, 5, 4,-1, 6, 2} },
        { 1, 2, {18,-2,18,18, 2, 3, 4,-3, 2, 5,18, 7, 4, 3, 8, 6} },
        { 0, 2, {17,-1,18, 2,-1, 1, 7, 3, 8, 5,-2, 4, 1, 2,-3, 6} },
        { 0, 1, {18,17, 2,18, 2,18, 6, 7, 4, 3,18, 5, 2,-2,17, 8} },
        { 0, 3, {18,17, 2, 3,-3,-1,18, 2, 4, 5,18, 7, 3, 2,-3, 6} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 2, { 3,18,18,18, 2, 6, 5,18, 7, 2, 4, 6,18, 5, 3, 8} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {18,18, 3, 6, 3,-2, 2,18, 5,-1, 7, 3, 4,-2, 2, 6} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 1, 1, {18,17,18,18,-2, 2, 3,-3,18, 6, 4, 2,-2, 8, 3, 7} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {18,18,18, 4, 2, 7, 8,18, 3, 2,-2, 4, 7, 6,17, 5} },
        { 1, 1, {18,18,-1,-2, 8, 3,18, 6, 3, 5, 8, 2, 4, 7, 1, 6} },
        { 1, 1, { 1,-3, 3,18,18, 2,-1, 3, 6, 5,18, 4, 7,-2, 8, 3} },
        { 1, 1, { 1,18, 4, 2, 5,18, 1, 3,-1, 6, 1, 4, 8, 2, 5, 1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
        { 0, 1, {-1,18,18, 2,18, 3, 5,18, 2,18, 6, 8, 4, 5, 7,-1} },
};



const uint32_t bitset [] = {
    1L << 0, 1L << 1, 1L << 2, 1L << 3,
    1L << 4, 1L << 5, 1L << 6, 1L << 7,
    1L << 8, 1L << 9, 1L << 10, 1L << 11,
    1L << 12, 1L << 13, 1L << 14, 1L << 15,
    1L << 16, 1L << 17, 1L << 18, 1L << 19,
    1L << 20, 1L << 21, 1L << 22, 1L << 23,
    1L << 24, 1L << 25, 1L << 26, 1L << 27,
    1L << 28, 1L << 29, 1L << 30, 1L << 31
};

const uint32_t bitmask [] = {
    (1L << 0) - 1, (1L << 1) - 1, (1L << 2) - 1, (1L << 3) - 1,
    (1L << 4) - 1, (1L << 5) - 1, (1L << 6) - 1, (1L << 7) - 1,
    (1L << 8) - 1, (1L << 9) - 1, (1L << 10) - 1, (1L << 11) - 1,
    (1L << 12) - 1, (1L << 13) - 1, (1L << 14) - 1, (1L << 15) - 1,
    (1L << 16) - 1, (1L << 17) - 1, (1L << 18) - 1, (1L << 19) - 1,
    (1L << 20) - 1, (1L << 21) - 1, (1L << 22) - 1, (1L << 23) - 1,
    (1L << 24) - 1, (1L << 25) - 1, (1L << 26) - 1, (1L << 27) - 1,
    (1L << 28) - 1, (1L << 29) - 1, (1L << 30) - 1, 0x7fffffff
};

const char nbits_table [] = {
    0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,     // 0 - 15
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // 16 - 31
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,     // 32 - 47
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,     // 48 - 63
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,     // 64 - 79
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,     // 80 - 95
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,     // 96 - 111
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,     // 112 - 127
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // 128 - 143
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // 144 - 159
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // 160 - 175
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // 176 - 191
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // 192 - 207
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // 208 - 223
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // 224 - 239
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8      // 240 - 255
};

static const uint8_t log2_table [] = {
    0x00, 0x01, 0x03, 0x04, 0x06, 0x07, 0x09, 0x0a, 0x0b, 0x0d, 0x0e, 0x10, 0x11, 0x12, 0x14, 0x15,
    0x16, 0x18, 0x19, 0x1a, 0x1c, 0x1d, 0x1e, 0x20, 0x21, 0x22, 0x24, 0x25, 0x26, 0x28, 0x29, 0x2a,
    0x2c, 0x2d, 0x2e, 0x2f, 0x31, 0x32, 0x33, 0x34, 0x36, 0x37, 0x38, 0x39, 0x3b, 0x3c, 0x3d, 0x3e,
    0x3f, 0x41, 0x42, 0x43, 0x44, 0x45, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4d, 0x4e, 0x4f, 0x50, 0x51,
    0x52, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
    0x64, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x74, 0x75,
    0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,
    0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95,
    0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
    0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb2,
    0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc0,
    0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcb, 0xcc, 0xcd, 0xce,
    0xcf, 0xd0, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd8, 0xd9, 0xda, 0xdb,
    0xdc, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe4, 0xe5, 0xe6, 0xe7, 0xe7,
    0xe8, 0xe9, 0xea, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xee, 0xef, 0xf0, 0xf1, 0xf1, 0xf2, 0xf3, 0xf4,
    0xf4, 0xf5, 0xf6, 0xf7, 0xf7, 0xf8, 0xf9, 0xf9, 0xfa, 0xfb, 0xfc, 0xfc, 0xfd, 0xfe, 0xff, 0xff
};

static const uint8_t exp2_table [] = {
    0x00, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0a, 0x0b,
    0x0b, 0x0c, 0x0d, 0x0e, 0x0e, 0x0f, 0x10, 0x10, 0x11, 0x12, 0x13, 0x13, 0x14, 0x15, 0x16, 0x16,
    0x17, 0x18, 0x19, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1d, 0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23,
    0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3a, 0x3b, 0x3c, 0x3d,
    0x3e, 0x3f, 0x40, 0x41, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x48, 0x49, 0x4a, 0x4b,
    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,
    0x5b, 0x5c, 0x5d, 0x5e, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
    0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
    0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x87, 0x88, 0x89, 0x8a,
    0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,
    0x9c, 0x9d, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad,
    0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0,
    0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc8, 0xc9, 0xca, 0xcb, 0xcd, 0xce, 0xcf, 0xd0, 0xd2, 0xd3, 0xd4,
    0xd6, 0xd7, 0xd8, 0xd9, 0xdb, 0xdc, 0xdd, 0xde, 0xe0, 0xe1, 0xe2, 0xe4, 0xe5, 0xe6, 0xe8, 0xe9,
    0xea, 0xec, 0xed, 0xee, 0xf0, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf8, 0xf9, 0xfa, 0xfc, 0xfd, 0xff
};

#define NUM_FAST_SPECS (sizeof (fast_specs) / sizeof (fast_specs [0]))
#define NUM_DEFAULT_SPECS (sizeof (default_specs) / sizeof (default_specs [0]))
#define NUM_HIGH_SPECS (sizeof (high_specs) / sizeof (high_specs [0]))
#define NUM_VERY_HIGH_SPECS (sizeof (very_high_specs) / sizeof (very_high_specs [0]))

const uint32_t sample_rates [] = { 6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 64000, 88200, 96000, 192000 };

int WavpackGetMode (WavpackContext *wpc)
{
    int mode = 0;

    if (wpc) {
        if (wpc->config.flags & CONFIG_HYBRID_FLAG)
            mode |= MODE_HYBRID;
        else if (!(wpc->config.flags & CONFIG_LOSSY_MODE))
            mode |= MODE_LOSSLESS;

        if (wpc->wvc_flag)
            mode |= (MODE_LOSSLESS | MODE_WVC);

        if (wpc->lossy_blocks)
            mode &= ~MODE_LOSSLESS;

        if (wpc->config.flags & CONFIG_FLOAT_DATA)
            mode |= MODE_FLOAT;

        if (wpc->config.flags & (CONFIG_HIGH_FLAG | CONFIG_VERY_HIGH_FLAG)) {
            mode |= MODE_HIGH;

            if ((wpc->config.flags & CONFIG_VERY_HIGH_FLAG) ||
                (wpc->streams && wpc->streams [0] && wpc->streams [0]->wphdr.version < 0x405))
                    mode |= MODE_VERY_HIGH;
        }

        if (wpc->config.flags & CONFIG_FAST_FLAG)
            mode |= MODE_FAST;

        if (wpc->config.flags & CONFIG_EXTRA_MODE)
            mode |= (MODE_EXTRA | (wpc->config.xmode << 12));

        if (wpc->config.flags & CONFIG_CREATE_EXE)
            mode |= MODE_SFX;

        if (wpc->config.flags & CONFIG_MD5_CHECKSUM)
            mode |= MODE_MD5;

        if ((wpc->config.flags & CONFIG_HYBRID_FLAG) && (wpc->config.flags & CONFIG_DYNAMIC_SHAPING) &&
            wpc->streams && wpc->streams [0] && wpc->streams [0]->wphdr.version >= 0x407)
                mode |= MODE_DNS;

#if ! NO_TAGS
        if (valid_tag (&wpc->m_tag)) {
            mode |= MODE_VALID_TAG;

            if (valid_tag (&wpc->m_tag) == 'A')
                mode |= MODE_APETAG;
        }
#endif

        mode |= (wpc->config.qmode << 16) & 0xFF0000;
    }

    return mode;
}

int WavpackGetQualifyMode (WavpackContext *wpc)
{
    return wpc->config.qmode & 0xFF;
}

char *WavpackGetErrorMessage (WavpackContext *wpc)
{
    return wpc->error_message;
}

uint32_t WavpackGetNumSamples (WavpackContext *wpc)
{
    return (uint32_t) WavpackGetNumSamples64 (wpc);
}

int64_t WavpackGetNumSamples64 (WavpackContext *wpc)
{
    return wpc ? wpc->total_samples : -1;
}

uint32_t WavpackGetSampleIndex (WavpackContext *wpc)
{
    return (uint32_t) WavpackGetSampleIndex64 (wpc);
}

int64_t WavpackGetSampleIndex64 (WavpackContext *wpc)
{
    if (wpc) {
#if ENABLE_LEGACY
        if (wpc->stream3)
            return get_sample_index3 (wpc);
        else if (wpc->streams && wpc->streams [0])
            return wpc->streams [0]->sample_index;
#else
        if (wpc->streams && wpc->streams [0])
            return wpc->streams [0]->sample_index;
#endif
    }

    return -1;
}

int WavpackGetNumErrors (WavpackContext *wpc)
{
    return wpc ? wpc->crc_errors : 0;
}

int WavpackLossyBlocks (WavpackContext *wpc)
{
    return wpc ? wpc->lossy_blocks : 0;
}

double WavpackGetProgress (WavpackContext *wpc)
{
    if (wpc && wpc->total_samples != -1 && wpc->total_samples != 0)
        return (double) WavpackGetSampleIndex64 (wpc) / wpc->total_samples;

    return -1.0;
}

uint32_t WavpackGetFileSize (WavpackContext *wpc)
{
    return (uint32_t) (wpc ? wpc->filelen + wpc->file2len : 0);
}

int64_t WavpackGetFileSize64 (WavpackContext *wpc)
{
    return wpc ? wpc->filelen + wpc->file2len : 0;
}

double WavpackGetRatio (WavpackContext *wpc)
{
    if (wpc && wpc->total_samples != -1 && wpc->filelen) {
        auto output_size = (double) wpc->total_samples * wpc->config.num_channels * wpc->config.bytes_per_sample;
        auto input_size = (double) wpc->filelen + wpc->file2len;

        if (output_size >= 1.0 && input_size >= 1.0)
            return input_size / output_size;
    }

    return 0.0;
}

double WavpackGetAverageBitrate (WavpackContext *wpc, int count_wvc)
{
    if (wpc && wpc->total_samples != -1 && wpc->filelen && WavpackGetSampleRate (wpc)) {
        auto output_time = (double) wpc->total_samples / WavpackGetSampleRate (wpc);
        auto input_size = (double) wpc->filelen + (count_wvc ? wpc->file2len : 0);

        if (output_time >= 0.1 && input_size >= 1.0)
            return input_size * 8.0 / output_time;
    }

    return 0.0;
}

double WavpackGetInstantBitrate (WavpackContext *wpc)
{
    if (wpc && wpc->stream3)
        return WavpackGetAverageBitrate (wpc, true);

    if (wpc && wpc->streams && wpc->streams [0] && wpc->streams [0]->wphdr.block_samples && WavpackGetSampleRate (wpc)) {
        auto output_time = (double) wpc->streams [0]->wphdr.block_samples / WavpackGetSampleRate (wpc);
        auto input_size = 0;
        int si;

        for (si = 0; si < wpc->num_streams; ++si) {
            if (wpc->streams [si]->blockbuff)
                input_size += ((WavpackHeader *) wpc->streams [si]->blockbuff)->ckSize;

            if (wpc->streams [si]->block2buff)
                input_size += ((WavpackHeader *) wpc->streams [si]->block2buff)->ckSize;
        }

        if (output_time > 0.0 && input_size >= 1.0)
            return input_size * 8.0 / output_time;
    }

    return 0.0;
}

uint32_t WavpackGetChannelLayout (WavpackContext *wpc, uint8_t *reorder)
{
    if ((wpc->channel_layout & 0xff) && wpc->channel_reordering && reorder)
        memcpy (reorder, wpc->channel_reordering, wpc->channel_layout & 0xff);

    return wpc->channel_layout;
}

void WavpackGetChannelIdentities (WavpackContext *wpc, uint8_t *identities)
{
    int num_channels = wpc->config.num_channels, index = 1;
    auto channel_mask = wpc->config.channel_mask;
    auto *src = wpc->channel_identities;

    while (num_channels--) {
        if (channel_mask) {
            while (!(channel_mask & 1)) {
                channel_mask >>= 1;
                index++;
            }

            *identities++ = index++;
            channel_mask >>= 1;
        }
        else if (src && *src)
            *identities++ = *src++;
        else
            *identities++ = 0xff;
    }

    *identities = 0;
}

// For local use only. Install a callback to be executed when WavpackCloseFile() is called,
// usually used to dump some statistics accumulated during encode or decode.
void install_close_callback (WavpackContext *wpc, void cb_func (void *wpc))
{
    wpc->close_callback = cb_func;
}

WavpackContext *WavpackCloseFile (WavpackContext *wpc)
{
    if (wpc->close_callback)
        wpc->close_callback (wpc);

    if (wpc->streams) {
        free_streams (wpc);

        if (wpc->streams [0])
            free (wpc->streams [0]);

        free (wpc->streams);
    }

#if ENABLE_LEGACY
    if (wpc->stream3)
        free_stream3 (wpc);
#endif

    if (wpc->reader && wpc->reader->close && wpc->wv_in)
        wpc->reader->close (wpc->wv_in);

    if (wpc->reader && wpc->reader->close && wpc->wvc_in)
        wpc->reader->close (wpc->wvc_in);

    WavpackFreeWrapper (wpc);

    if (wpc->metadata) {
        int i;

        for (i = 0; i < wpc->metacount; ++i)
            if (wpc->metadata [i].data)
                free (wpc->metadata [i].data);

        free (wpc->metadata);
    }

    if (wpc->channel_identities)
        free (wpc->channel_identities);

    if (wpc->channel_reordering)
        free (wpc->channel_reordering);

#if ! NO_TAGS
    free_tag (&wpc->m_tag);
#endif

#if ENABLE_DSD
    if (wpc->decimation_context)
        decimate_dsd_destroy (wpc->decimation_context);
#endif

    free (wpc);

    return nullptr;
}

uint32_t WavpackGetWrapperBytes (WavpackContext *wpc)
{
    return wpc ? wpc->wrapper_bytes : 0;
}

uint8_t *WavpackGetWrapperData (WavpackContext *wpc)
{
    return wpc ? wpc->wrapper_data : nullptr;
}

void WavpackFreeWrapper (WavpackContext *wpc)
{
    if (wpc && wpc->wrapper_data) {
        free (wpc->wrapper_data);
        wpc->wrapper_data = nullptr;
        wpc->wrapper_bytes = 0;
    }
}

uint32_t WavpackGetSampleRate (WavpackContext *wpc)
{
    return wpc ? (wpc->dsd_multiplier ? wpc->config.sample_rate * wpc->dsd_multiplier : wpc->config.sample_rate) : 44100;
}

uint32_t WavpackGetNativeSampleRate (WavpackContext *wpc)
{
    return wpc ? (wpc->dsd_multiplier ? wpc->config.sample_rate * wpc->dsd_multiplier * 8 : wpc->config.sample_rate) : 44100;
}

int WavpackGetNumChannels (WavpackContext *wpc)
{
    return wpc ? wpc->config.num_channels : 2;
}

int WavpackGetChannelMask (WavpackContext *wpc)
{
    return wpc ? wpc->config.channel_mask : 0;
}

int WavpackGetFloatNormExp (WavpackContext *wpc)
{
    return (wpc->open_flags & OPEN_NORMALIZE) ? 127 + wpc->norm_offset : wpc->config.float_norm_exp;
}

int WavpackGetBitsPerSample (WavpackContext *wpc)
{
    return wpc ? wpc->config.bits_per_sample : 16;
}

int WavpackGetBytesPerSample (WavpackContext *wpc)
{
    return wpc ? wpc->config.bytes_per_sample : 2;
}

int WavpackGetReducedChannels (WavpackContext *wpc)
{
    if (wpc)
        return wpc->reduced_channels ? wpc->reduced_channels : wpc->config.num_channels;
    return 2;
}

// Free all memory allocated for raw WavPack blocks (for all allocated streams)
// and free all additional streams. This does not free the default stream ([0])
// which is always kept around.
void free_streams (WavpackContext *wpc)
{
    auto si = wpc->num_streams;

    while (si--) {
        if (wpc->streams [si]->blockbuff) {
            free (wpc->streams [si]->blockbuff);
            wpc->streams [si]->blockbuff = nullptr;
        }

        if (wpc->streams [si]->block2buff) {
            free (wpc->streams [si]->block2buff);
            wpc->streams [si]->block2buff = nullptr;
        }

        if (wpc->streams [si]->sample_buffer) {
            free (wpc->streams [si]->sample_buffer);
            wpc->streams [si]->sample_buffer = nullptr;
        }

        if (wpc->streams [si]->dc.shaping_data) {
            free (wpc->streams [si]->dc.shaping_data);
            wpc->streams [si]->dc.shaping_data = nullptr;
        }

#if ENABLE_DSD
        free_dsd_tables (wpc->streams [si]);
#endif

        if (si) {
            wpc->num_streams--;
            free (wpc->streams [si]);
            wpc->streams [si] = nullptr;
        }
    }

    wpc->current_stream = 0;
}

void free_dsd_tables (WavpackStream *wps)
{
    if (wps->dsd.probabilities) {
        free (wps->dsd.probabilities);
        wps->dsd.probabilities = nullptr;
    }

    if (wps->dsd.summed_probabilities) {
        free (wps->dsd.summed_probabilities);
        wps->dsd.summed_probabilities = nullptr;
    }

    if (wps->dsd.lookup_buffer) {
        free (wps->dsd.lookup_buffer);
        wps->dsd.lookup_buffer = nullptr;
    }

    if (wps->dsd.value_lookup) {
        free (wps->dsd.value_lookup);
        wps->dsd.value_lookup = nullptr;
    }

    if (wps->dsd.ptable) {
        free (wps->dsd.ptable);
        wps->dsd.ptable = nullptr;
    }
}

void WavpackFloatNormalize (int32_t *values, int32_t num_values, int delta_exp)
{
    int32_t *fvalues = (int32_t *) values;
    int exp;

    if (!delta_exp)
        return;

    while (num_values--) {
        if ((exp = get_exponent (*fvalues)) == 0 || exp + delta_exp <= 0)
            *fvalues = 0;
        else if (exp == 255 || (exp += delta_exp) >= 255) {
            set_exponent (*fvalues, 255);
            set_mantissa (*fvalues, 0);
        }
        else
            set_exponent (*fvalues, exp);

        fvalues++;
    }
}

void WavpackLittleEndianToNative (void *data, char *format)
{
    uint8_t *cp = (uint8_t *) data;
    int64_t temp;

    while (*format) {
        switch (*format) {
            case 'D':
                temp = cp [0] + ((int64_t) cp [1] << 8) + ((int64_t) cp [2] << 16) + ((int64_t) cp [3] << 24) +
                    ((int64_t) cp [4] << 32) + ((int64_t) cp [5] << 40) + ((int64_t) cp [6] << 48) + ((uint64_t) cp [7] << 56);
                * (int64_t *) cp = temp;
                cp += 8;
                break;

            case 'L':
                temp = cp [0] + ((int32_t) cp [1] << 8) + ((int32_t) cp [2] << 16) + ((int64_t) cp [3] << 24);
                * (int32_t *) cp = (int32_t) temp;
                cp += 4;
                break;

            case 'S':
                temp = cp [0] + (cp [1] << 8);
                * (int16_t *) cp = (int16_t) temp;
                cp += 2;
                break;

            default:
                if (isdigit (*format))
                    cp += *format - '0';

                break;
        }

        format++;
    }
}

void WavpackNativeToLittleEndian (void *data, char *format)
{
    uint8_t *cp = (uint8_t *) data;
    int64_t temp;

    while (*format) {
        switch (*format) {
            case 'D':
                temp = * (int64_t *) cp;
                *cp++ = (uint8_t) temp;
                *cp++ = (uint8_t) (temp >> 8);
                *cp++ = (uint8_t) (temp >> 16);
                *cp++ = (uint8_t) (temp >> 24);
                *cp++ = (uint8_t) (temp >> 32);
                *cp++ = (uint8_t) (temp >> 40);
                *cp++ = (uint8_t) (temp >> 48);
                *cp++ = (uint8_t) (temp >> 56);
                break;

            case 'L':
                temp = * (int32_t *) cp;
                *cp++ = (uint8_t) temp;
                *cp++ = (uint8_t) (temp >> 8);
                *cp++ = (uint8_t) (temp >> 16);
                *cp++ = (uint8_t) (temp >> 24);
                break;

            case 'S':
                temp = * (int16_t *) cp;
                *cp++ = (uint8_t) temp;
                *cp++ = (uint8_t) (temp >> 8);
                break;

            default:
                if (isdigit (*format))
                    cp += *format - '0';

                break;
        }

        format++;
    }
}

void WavpackBigEndianToNative (void *data, char *format)
{
    uint8_t *cp = (uint8_t *) data;
    int64_t temp;

    while (*format) {
        switch (*format) {
            case 'D':
                temp = cp [7] + ((int64_t) cp [6] << 8) + ((int64_t) cp [5] << 16) + ((int64_t) cp [4] << 24) +
                    ((int64_t) cp [3] << 32) + ((int64_t) cp [2] << 40) + ((int64_t) cp [1] << 48) + ((uint64_t) cp [0] << 56);
                * (int64_t *) cp = temp;
                cp += 8;
                break;

            case 'L':
                temp = cp [3] + ((int32_t) cp [2] << 8) + ((int32_t) cp [1] << 16) + ((int64_t) cp [0] << 24);
                * (int32_t *) cp = (int32_t) temp;
                cp += 4;
                break;

            case 'S':
                temp = cp [1] + (cp [0] << 8);
                * (int16_t *) cp = (int16_t) temp;
                cp += 2;
                break;

            default:
                if (isdigit (*format))
                    cp += *format - '0';

                break;
        }

        format++;
    }
}

void WavpackNativeToBigEndian (void *data, char *format)
{
    uint8_t *cp = (uint8_t *) data;
    int64_t temp;

    while (*format) {
        switch (*format) {
            case 'D':
                temp = * (int64_t *) cp;
                *cp++ = (uint8_t) (temp >> 56);
                *cp++ = (uint8_t) (temp >> 48);
                *cp++ = (uint8_t) (temp >> 40);
                *cp++ = (uint8_t) (temp >> 32);
                *cp++ = (uint8_t) (temp >> 24);
                *cp++ = (uint8_t) (temp >> 16);
                *cp++ = (uint8_t) (temp >> 8);
                *cp++ = (uint8_t) temp;
                break;

            case 'L':
                temp = * (int32_t *) cp;
                *cp++ = (uint8_t) (temp >> 24);
                *cp++ = (uint8_t) (temp >> 16);
                *cp++ = (uint8_t) (temp >> 8);
                *cp++ = (uint8_t) temp;
                break;

            case 'S':
                temp = * (int16_t *) cp;
                *cp++ = (uint8_t) (temp >> 8);
                *cp++ = (uint8_t) temp;
                break;

            default:
                if (isdigit (*format))
                    cp += *format - '0';

                break;
        }

        format++;
    }
}

uint32_t WavpackGetLibraryVersion (void)
{
    return (LIBWAVPACK_MAJOR<<16)
          |(LIBWAVPACK_MINOR<<8)
          |(LIBWAVPACK_MICRO<<0);
}

const char *WavpackGetLibraryVersionString (void)
{
    return LIBWAVPACK_VERSION_STRING;
}

int read_entropy_vars (WavpackStream *wps, WavpackMetadata *wpmd)
{
    uint8_t *byteptr = (uint8_t *)wpmd->data;

    if (wpmd->byte_length != ((wps->wphdr.flags & MONO_DATA) ? 6 : 12))
        return false;

    wps->w.c [0].median [0] = wp_exp2s (byteptr [0] + (byteptr [1] << 8));
    wps->w.c [0].median [1] = wp_exp2s (byteptr [2] + (byteptr [3] << 8));
    wps->w.c [0].median [2] = wp_exp2s (byteptr [4] + (byteptr [5] << 8));

    if (!(wps->wphdr.flags & MONO_DATA)) {
        wps->w.c [1].median [0] = wp_exp2s (byteptr [6] + (byteptr [7] << 8));
        wps->w.c [1].median [1] = wp_exp2s (byteptr [8] + (byteptr [9] << 8));
        wps->w.c [1].median [2] = wp_exp2s (byteptr [10] + (byteptr [11] << 8));
    }

    return true;
}

int read_hybrid_profile (WavpackStream *wps, WavpackMetadata *wpmd)
{
    uint8_t *byteptr = (uint8_t *)wpmd->data;
    uint8_t *endptr = byteptr + wpmd->byte_length;

    if (wps->wphdr.flags & HYBRID_BITRATE) {
        if (byteptr + (wps->wphdr.flags & MONO_DATA ? 2 : 4) > endptr)
            return false;

        wps->w.c [0].slow_level = wp_exp2s (byteptr [0] + (byteptr [1] << 8));
        byteptr += 2;

        if (!(wps->wphdr.flags & MONO_DATA)) {
            wps->w.c [1].slow_level = wp_exp2s (byteptr [0] + (byteptr [1] << 8));
            byteptr += 2;
        }
    }

    if (byteptr + (wps->wphdr.flags & MONO_DATA ? 2 : 4) > endptr)
        return false;

    wps->w.bitrate_acc [0] = (uint32_t)(byteptr [0] + (byteptr [1] << 8)) << 16;
    byteptr += 2;

    if (!(wps->wphdr.flags & MONO_DATA)) {
        wps->w.bitrate_acc [1] = (uint32_t)(byteptr [0] + (byteptr [1] << 8)) << 16;
        byteptr += 2;
    }

    if (byteptr < endptr) {
        if (byteptr + (wps->wphdr.flags & MONO_DATA ? 2 : 4) > endptr)
            return false;

        wps->w.bitrate_delta [0] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
        byteptr += 2;

        if (!(wps->wphdr.flags & MONO_DATA)) {
            wps->w.bitrate_delta [1] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
            byteptr += 2;
        }

        if (byteptr < endptr)
            return false;
    }
    else
        wps->w.bitrate_delta [0] = wps->w.bitrate_delta [1] = 0;

    return true;
}

void update_error_limit (WavpackStream *wps)
{
    int bitrate_0 = (wps->w.bitrate_acc [0] += wps->w.bitrate_delta [0]) >> 16;

    if (wps->wphdr.flags & MONO_DATA) {
        if (wps->wphdr.flags & HYBRID_BITRATE) {
            int slow_log_0 = (wps->w.c [0].slow_level + SLO) >> SLS;

            if (slow_log_0 - bitrate_0 > -0x100)
                wps->w.c [0].error_limit = wp_exp2s (slow_log_0 - bitrate_0 + 0x100);
            else
                wps->w.c [0].error_limit = 0;
        }
        else
            wps->w.c [0].error_limit = wp_exp2s (bitrate_0);
    }
    else {
        int bitrate_1 = (wps->w.bitrate_acc [1] += wps->w.bitrate_delta [1]) >> 16;

        if (wps->wphdr.flags & HYBRID_BITRATE) {
            int slow_log_0 = (wps->w.c [0].slow_level + SLO) >> SLS;
            int slow_log_1 = (wps->w.c [1].slow_level + SLO) >> SLS;

            if (wps->wphdr.flags & HYBRID_BALANCE) {
                int balance = (slow_log_1 - slow_log_0 + bitrate_1 + 1) >> 1;

                if (balance > bitrate_0) {
                    bitrate_1 = bitrate_0 * 2;
                    bitrate_0 = 0;
                }
                else if (-balance > bitrate_0) {
                    bitrate_0 = bitrate_0 * 2;
                    bitrate_1 = 0;
                }
                else {
                    bitrate_1 = bitrate_0 + balance;
                    bitrate_0 = bitrate_0 - balance;
                }
            }

            if (slow_log_0 - bitrate_0 > -0x100)
                wps->w.c [0].error_limit = wp_exp2s (slow_log_0 - bitrate_0 + 0x100);
            else
                wps->w.c [0].error_limit = 0;

            if (slow_log_1 - bitrate_1 > -0x100)
                wps->w.c [1].error_limit = wp_exp2s (slow_log_1 - bitrate_1 + 0x100);
            else
                wps->w.c [1].error_limit = 0;
        }
        else {
            wps->w.c [0].error_limit = wp_exp2s (bitrate_0);
            wps->w.c [1].error_limit = wp_exp2s (bitrate_1);
        }
    }
}

int FASTCALL wp_log2 (uint32_t avalue)
{
    int dbits;

    if ((avalue += avalue >> 9) < (1 << 8)) {
        dbits = nbits_table [avalue];
        return (dbits << 8) + log2_table [(avalue << (9 - dbits)) & 0xff];
    }
    else {
        if (avalue < (1L << 16))
            dbits = nbits_table [avalue >> 8] + 8;
        else if (avalue < (1L << 24))
            dbits = nbits_table [avalue >> 16] + 16;
        else
            dbits = nbits_table [avalue >> 24] + 24;

        return (dbits << 8) + log2_table [(avalue >> (dbits - 9)) & 0xff];
    }
}

#if !defined(OPT_ASM_X86) && !defined(OPT_ASM_X64)

uint32_t log2buffer (int32_t *samples, uint32_t num_samples, int limit)
{
    uint32_t result = 0, avalue;
    int dbits;

    while (num_samples--) {
        avalue = abs (*samples++);

        if ((avalue += avalue >> 9) < (1 << 8)) {
            dbits = nbits_table [avalue];
            result += (dbits << 8) + log2_table [(avalue << (9 - dbits)) & 0xff];
        }
        else {
            if (avalue < (1L << 16))
                dbits = nbits_table [avalue >> 8] + 8;
            else if (avalue < (1L << 24))
                dbits = nbits_table [avalue >> 16] + 16;
            else
                dbits = nbits_table [avalue >> 24] + 24;

            result += dbits = (dbits << 8) + log2_table [(avalue >> (dbits - 9)) & 0xff];

            if (limit && dbits >= limit)
                return (uint32_t) -1;
        }
    }

    return result;
}

#endif

int wp_log2s (int32_t value)
{
    return (value < 0) ? -wp_log2 (-value) : wp_log2 (value);
}

int32_t wp_exp2s (int log)
{
    uint32_t value;

    if (log < 0)
        return -wp_exp2s (-log);

    value = exp2_table [log & 0xff] | 0x100;

    if ((log >>= 8) <= 9)
        return value >> (9 - log);
    else
        return value << ((log - 9) & 0x1f);
}

signed char store_weight (int weight)
{
    if (weight > 1024)
        weight = 1024;
    else if (weight < -1024)
        weight = -1024;

    if (weight > 0)
        weight -= (weight + 64) >> 7;

    return (weight + 4) >> 3;
}

int restore_weight (signed char weight)
{
    int result;

    if ((result = (int) weight * 8) > 0)
        result += (result + 64) >> 7;

    return result;
}


int read_decorr_terms (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int termcnt = wpmd->byte_length;
    uint8_t *byteptr = (uint8_t *)wpmd->data;
    struct decorr_pass *dpp;

    if (termcnt > MAX_NTERMS)
        return false;

    wps->num_terms = termcnt;

    for (dpp = wps->decorr_passes + termcnt - 1; termcnt--; dpp--) {
        dpp->term = (int)(*byteptr & 0x1f) - 5;
        dpp->delta = (*byteptr++ >> 5) & 0x7;

        if (!dpp->term || dpp->term < -3 || (dpp->term > MAX_TERM && dpp->term < 17) || dpp->term > 18 ||
            ((wps->wphdr.flags & MONO_DATA) && dpp->term < 0))
                return false;
    }

    return true;
}

int read_decorr_weights (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int termcnt = wpmd->byte_length, tcount;
    char *byteptr = (char *)wpmd->data;
    struct decorr_pass *dpp;

    if (!(wps->wphdr.flags & MONO_DATA))
        termcnt /= 2;

    if (termcnt > wps->num_terms)
        return false;

    for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++)
        dpp->weight_A = dpp->weight_B = 0;

    while (--dpp >= wps->decorr_passes && termcnt--) {
        dpp->weight_A = restore_weight (*byteptr++);

        if (!(wps->wphdr.flags & MONO_DATA))
            dpp->weight_B = restore_weight (*byteptr++);
    }

    return true;
}

int read_decorr_samples (WavpackStream *wps, WavpackMetadata *wpmd)
{
    uint8_t *byteptr = (uint8_t *)wpmd->data;
    uint8_t *endptr = byteptr + wpmd->byte_length;
    struct decorr_pass *dpp;
    int tcount;

    for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
        CLEAR (dpp->samples_A);
        CLEAR (dpp->samples_B);
    }

    if (wps->wphdr.version == 0x402 && (wps->wphdr.flags & HYBRID_FLAG)) {
        if (byteptr + (wps->wphdr.flags & MONO_DATA ? 2 : 4) > endptr)
            return false;

        wps->dc.error [0] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
        byteptr += 2;

        if (!(wps->wphdr.flags & MONO_DATA)) {
            wps->dc.error [1] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
            byteptr += 2;
        }
    }

    while (dpp-- > wps->decorr_passes && byteptr < endptr)
        if (dpp->term > MAX_TERM) {
            if (byteptr + (wps->wphdr.flags & MONO_DATA ? 4 : 8) > endptr)
                return false;

            dpp->samples_A [0] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
            dpp->samples_A [1] = wp_exp2s ((int16_t)(byteptr [2] + (byteptr [3] << 8)));
            byteptr += 4;

            if (!(wps->wphdr.flags & MONO_DATA)) {
                dpp->samples_B [0] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
                dpp->samples_B [1] = wp_exp2s ((int16_t)(byteptr [2] + (byteptr [3] << 8)));
                byteptr += 4;
            }
        }
        else if (dpp->term < 0) {
            if (byteptr + 4 > endptr)
                return false;

            dpp->samples_A [0] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
            dpp->samples_B [0] = wp_exp2s ((int16_t)(byteptr [2] + (byteptr [3] << 8)));
            byteptr += 4;
        }
        else {
            int m = 0, cnt = dpp->term;

            while (cnt--) {
                if (byteptr + (wps->wphdr.flags & MONO_DATA ? 2 : 4) > endptr)
                    return false;

                dpp->samples_A [m] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
                byteptr += 2;

                if (!(wps->wphdr.flags & MONO_DATA)) {
                    dpp->samples_B [m] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
                    byteptr += 2;
                }

                m++;
            }
        }

    return byteptr == endptr;
}

int read_shaping_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    if (wpmd->byte_length == 2) {
        char *byteptr = (char *)wpmd->data;

        wps->dc.shaping_acc [0] = (uint32_t) restore_weight (*byteptr++) << 16;
        wps->dc.shaping_acc [1] = (uint32_t) restore_weight (*byteptr++) << 16;
        return true;
    }
    else if (wpmd->byte_length >= (wps->wphdr.flags & MONO_DATA ? 4 : 8)) {
        uint8_t *byteptr = (uint8_t *)wpmd->data;

        wps->dc.error [0] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
        wps->dc.shaping_acc [0] = wp_exp2s ((int16_t)(byteptr [2] + (byteptr [3] << 8)));
        byteptr += 4;

        if (!(wps->wphdr.flags & MONO_DATA)) {
            wps->dc.error [1] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));
            wps->dc.shaping_acc [1] = wp_exp2s ((int16_t)(byteptr [2] + (byteptr [3] << 8)));
            byteptr += 4;
        }

        if (wpmd->byte_length == (wps->wphdr.flags & MONO_DATA ? 6 : 12)) {
            wps->dc.shaping_delta [0] = wp_exp2s ((int16_t)(byteptr [0] + (byteptr [1] << 8)));

            if (!(wps->wphdr.flags & MONO_DATA))
                wps->dc.shaping_delta [1] = wp_exp2s ((int16_t)(byteptr [2] + (byteptr [3] << 8)));
        }

        return true;
    }

    return false;
}


int load_tag (WavpackContext *wpc)
{
    int ape_tag_length, ape_tag_items;
    M_Tag *m_tag = &wpc->m_tag;

    CLEAR (*m_tag);

    // This is a loop because we can try up to three times to look for an APEv2 tag. In order, we look:
    //
    //  1. At the end of the file for a APEv2 footer (this is the preferred location)
    //  2. If there's instead an ID3v1 tag at the end of the file, try looking for an APEv2 footer right before that
    //  3. If all else fails, look for an APEv2 header the the beginning of the file (use is strongly discouraged)

    while (1) {

        // seek based on specific location that we are looking for tag (see above list)

        if (m_tag->tag_begins_file)                     // case #3
            wpc->reader->set_pos_abs (wpc->wv_in, 0);
        else if (m_tag->id3_tag.tag_id [0] == 'T')      // case #2
            wpc->reader->set_pos_rel (wpc->wv_in, -(int32_t)(sizeof (APE_Tag_Hdr) + sizeof (ID3_Tag)), SEEK_END);
        else                                            // case #1
            wpc->reader->set_pos_rel (wpc->wv_in, -(int32_t)sizeof (APE_Tag_Hdr), SEEK_END);

        // read a possible APEv2 tag header/footer and see if there's one there...

        if (wpc->reader->read_bytes (wpc->wv_in, &m_tag->ape_tag_hdr, sizeof (APE_Tag_Hdr)) == sizeof (APE_Tag_Hdr) &&
            !strncmp (m_tag->ape_tag_hdr.ID, "APETAGEX", 8)) {

                WavpackLittleEndianToNative (&m_tag->ape_tag_hdr, APE_Tag_Hdr_Format);

                if (m_tag->ape_tag_hdr.version == 2000 && m_tag->ape_tag_hdr.item_count &&
                    m_tag->ape_tag_hdr.length > (int) sizeof (m_tag->ape_tag_hdr) &&
                    m_tag->ape_tag_hdr.length <= APE_TAG_MAX_LENGTH &&
                    (m_tag->ape_tag_data = (uint8_t *)malloc (m_tag->ape_tag_hdr.length)) != nullptr) {

                        ape_tag_items = m_tag->ape_tag_hdr.item_count;
                        ape_tag_length = m_tag->ape_tag_hdr.length;

                        // If this is a APEv2 footer (which is normal if we are searching at the end of the file)...

                        if (!(m_tag->ape_tag_hdr.flags & APE_TAG_THIS_IS_HEADER)) {

                            if (m_tag->id3_tag.tag_id [0] == 'T')
                                m_tag->tag_file_pos = -(int32_t)sizeof (ID3_Tag);
                            else
                                m_tag->tag_file_pos = 0;

                            m_tag->tag_file_pos -= ape_tag_length;

                            // if the footer claims there is a header present also, we will read that and use it
                            // instead of the footer (after verifying it, of course) for enhanced robustness

                            if (m_tag->ape_tag_hdr.flags & APE_TAG_CONTAINS_HEADER)
                                m_tag->tag_file_pos -= sizeof (APE_Tag_Hdr);

                            wpc->reader->set_pos_rel (wpc->wv_in, m_tag->tag_file_pos, SEEK_END);

                            if (m_tag->ape_tag_hdr.flags & APE_TAG_CONTAINS_HEADER) {
                                if (wpc->reader->read_bytes (wpc->wv_in, &m_tag->ape_tag_hdr, sizeof (APE_Tag_Hdr)) !=
                                    sizeof (APE_Tag_Hdr) || strncmp (m_tag->ape_tag_hdr.ID, "APETAGEX", 8)) {
                                        free (m_tag->ape_tag_data);
                                        CLEAR (*m_tag);
                                        return false;       // something's wrong...
                                }

                                WavpackLittleEndianToNative (&m_tag->ape_tag_hdr, APE_Tag_Hdr_Format);

                                if (m_tag->ape_tag_hdr.version != 2000 || m_tag->ape_tag_hdr.item_count != ape_tag_items ||
                                    m_tag->ape_tag_hdr.length != ape_tag_length) {
                                        free (m_tag->ape_tag_data);
                                        CLEAR (*m_tag);
                                        return false;       // something's wrong...
                                }
                            }
                        }

                        if (wpc->reader->read_bytes (wpc->wv_in, m_tag->ape_tag_data,
                            ape_tag_length - sizeof (APE_Tag_Hdr)) != ape_tag_length - sizeof (APE_Tag_Hdr)) {
                                free (m_tag->ape_tag_data);
                                CLEAR (*m_tag);
                                return false;       // something's wrong...
                        }
                        else {
                            CLEAR (m_tag->id3_tag); // ignore ID3v1 tag if we found APEv2 tag
                            return true;
                        }
                }
        }

        // we come here if the search for the APEv2 tag failed (otherwise we would have returned with it)

        if (m_tag->id3_tag.tag_id [0] == 'T') {     // settle for the ID3v1 tag that we found
            CLEAR (m_tag->ape_tag_hdr);
            return true;
        }

        // if this was the search for the APEv2 tag at the beginning of the file (which is our
        // last resort) then we have nothing, so return failure

        if (m_tag->tag_begins_file) {
            CLEAR (*m_tag);
            return false;
        }

        // If we get here, then we have failed the first APEv2 tag search (at end of file) and so now we
        // look for an ID3v1 tag at the same position. If that succeeds, then we'll loop back and look for
        // an APEv2 tag immediately before the ID3v1 tag, otherwise our last resort is to look for an
        // APEv2 tag at the beginning of the file. These are strongly discouraged (and not editable) but
        // they have been seen in the wild so we attempt to handle them here (at least well enough to
        // allow a proper transcoding).

        m_tag->tag_file_pos = -(int32_t)sizeof (ID3_Tag);
        wpc->reader->set_pos_rel (wpc->wv_in, m_tag->tag_file_pos, SEEK_END);

        if (wpc->reader->read_bytes (wpc->wv_in, &m_tag->id3_tag, sizeof (ID3_Tag)) != sizeof (ID3_Tag) ||
            strncmp (m_tag->id3_tag.tag_id, "TAG", 3)) {
                m_tag->tag_begins_file = 1;     // failed ID3v1, so look for APEv2 at beginning of file
                CLEAR (m_tag->id3_tag);
            }
    }
}

int valid_tag (M_Tag *m_tag)
{
    if (m_tag->ape_tag_hdr.ID [0] == 'A')
        return 'A';
    else if (m_tag->id3_tag.tag_id [0] == 'T')
        return 'T';
    else
        return 0;
}

int editable_tag (M_Tag *m_tag)
{
    return !m_tag->tag_begins_file;
}

void free_tag (M_Tag *m_tag)
{
    if (m_tag->ape_tag_data) {
        free (m_tag->ape_tag_data);
        m_tag->ape_tag_data = nullptr;
    }
}

static int32_t trans_read_bytes (void *id, void *data, int32_t bcount)
{
    WavpackReaderTranslator *trans = (WavpackReaderTranslator *)id;
    return trans->reader->read_bytes (trans->id, data, bcount);
}

static int32_t trans_write_bytes (void *id, void *data, int32_t bcount)
{
    WavpackReaderTranslator *trans = (WavpackReaderTranslator *)id;
    return trans->reader->write_bytes (trans->id, data, bcount);
}

static int64_t trans_get_pos (void *id)
{
    WavpackReaderTranslator *trans = (WavpackReaderTranslator *)id;
    return trans->reader->get_pos (trans->id);
}

static int trans_set_pos_abs (void *id, int64_t pos)
{
    WavpackReaderTranslator *trans = (WavpackReaderTranslator *)id;
    return trans->reader->set_pos_abs (trans->id, (uint32_t) pos);
}

static int trans_set_pos_rel (void *id, int64_t delta, int mode)
{
    WavpackReaderTranslator *trans = (WavpackReaderTranslator *)id;
    return trans->reader->set_pos_rel (trans->id, (int32_t) delta, mode);
}

static int trans_push_back_byte (void *id, int c)
{
    WavpackReaderTranslator *trans = (WavpackReaderTranslator *)id;
    return trans->reader->push_back_byte (trans->id, c);
}

static int64_t trans_get_length (void *id)
{
    WavpackReaderTranslator *trans = (WavpackReaderTranslator *)id;
    return trans->reader->get_length (trans->id);
}

static int trans_can_seek (void *id)
{
    WavpackReaderTranslator *trans = (WavpackReaderTranslator *)id;
    return trans->reader->can_seek (trans->id);
}

static int trans_close_stream (void *id)
{
    free (id);
    return 0;
}

static WavpackStreamReader64 trans_reader = {
    trans_read_bytes, trans_write_bytes, trans_get_pos, trans_set_pos_abs, trans_set_pos_rel,
    trans_push_back_byte, trans_get_length, trans_can_seek, nullptr, trans_close_stream
};

WavpackContext *WavpackOpenFileInputEx (WavpackStreamReader *reader, void *wv_id, void *wvc_id, char *error, int flags, int norm_offset)
{
    WavpackReaderTranslator *trans_wv = nullptr, *trans_wvc = nullptr;

    // this prevents existing streaming applications from failing if they try to pass
    // in blocks that have been modified from the original (e.g., Matroska blocks)

    if (flags & OPEN_STREAMING)
        flags |= OPEN_NO_CHECKSUM;

    if (wv_id) {
        trans_wv = (WavpackReaderTranslator *)malloc (sizeof (WavpackReaderTranslator));
        trans_wv->reader = reader;
        trans_wv->id = wv_id;
    }

    if (wvc_id) {
        trans_wvc = (WavpackReaderTranslator *)malloc (sizeof (WavpackReaderTranslator));
        trans_wvc->reader = reader;
        trans_wvc->id = wvc_id;
    }

    return WavpackOpenFileInputEx64 (&trans_reader, trans_wv, trans_wvc, error, flags, norm_offset);
}


static int seek_eof_information (WavpackContext *wpc, int64_t *final_index, int get_wrapper);

WavpackContext *WavpackOpenFileInputEx64 (WavpackStreamReader64 *reader, void *wv_id, void *wvc_id, char *error, int flags, int norm_offset)
{
    WavpackContext *wpc = (WavpackContext *)malloc (sizeof (WavpackContext));
    WavpackStream *wps;
    int num_blocks = 0;
    uint8_t first_byte;
    uint32_t bcount;

    if (!wpc) {
        if (error) strcpy (error, "can't allocate memory");
        return nullptr;
    }

    CLEAR (*wpc);
    wpc->wv_in = wv_id;
    wpc->wvc_in = wvc_id;
    wpc->reader = reader;
    wpc->total_samples = -1;
    wpc->norm_offset = norm_offset;
    wpc->max_streams = OLD_MAX_STREAMS;     // use this until overwritten with actual number
    wpc->open_flags = flags;

    wpc->filelen = wpc->reader->get_length (wpc->wv_in);

#if ! NO_TAGS
    if ((flags & (OPEN_TAGS | OPEN_EDIT_TAGS)) && wpc->reader->can_seek (wpc->wv_in)) {
        load_tag (wpc);
        wpc->reader->set_pos_abs (wpc->wv_in, 0);

        if ((flags & OPEN_EDIT_TAGS) && !editable_tag (&wpc->m_tag)) {
            if (error) strcpy (error, "can't edit tags located at the beginning of files!");
            return WavpackCloseFile (wpc);
        }
    }
#endif

    if (wpc->reader->read_bytes (wpc->wv_in, &first_byte, 1) != 1) {
        if (error) strcpy (error, "can't read all of WavPack file!");
        return WavpackCloseFile (wpc);
    }

    wpc->reader->push_back_byte (wpc->wv_in, first_byte);

    if (first_byte == 'R') {
#if ENABLE_LEGACY
        return open_file3 (wpc, error);
#else
        if (error) strcpy (error, "this legacy WavPack file is deprecated, use version 4.80.0 to transcode");
        return WavpackCloseFile (wpc);
#endif
    }

    wpc->streams = (WavpackStream **)(malloc ((wpc->num_streams = 1) * sizeof (wpc->streams [0])));
    if (!wpc->streams) {
        if (error) strcpy (error, "can't allocate memory");
        return WavpackCloseFile (wpc);
    }

    wpc->streams [0] = wps = (WavpackStream *)malloc (sizeof (WavpackStream));
    if (!wps) {
        if (error) strcpy (error, "can't allocate memory");
        return WavpackCloseFile (wpc);
    }
    CLEAR (*wps);

    while (!wps->wphdr.block_samples) {

        wpc->filepos = wpc->reader->get_pos (wpc->wv_in);
        bcount = read_next_header (wpc->reader, wpc->wv_in, &wps->wphdr);

        if (bcount == (uint32_t) -1 ||
            (!wps->wphdr.block_samples && num_blocks++ > 16)) {
                if (error) strcpy (error, "not compatible with this version of WavPack file!");
                return WavpackCloseFile (wpc);
        }

        wpc->filepos += bcount;
        wps->blockbuff = (uint8_t *)malloc (wps->wphdr.ckSize + 8);
        if (!wps->blockbuff) {
            if (error) strcpy (error, "can't allocate memory");
            return WavpackCloseFile (wpc);
        }
        memcpy (wps->blockbuff, &wps->wphdr, 32);

        if (wpc->reader->read_bytes (wpc->wv_in, wps->blockbuff + 32, wps->wphdr.ckSize - 24) != wps->wphdr.ckSize - 24) {
            if (error) strcpy (error, "can't read all of WavPack file!");
            return WavpackCloseFile (wpc);
        }

        // if block does not verify, flag error, free buffer, and continue
        if (!WavpackVerifySingleBlock (wps->blockbuff, !(flags & OPEN_NO_CHECKSUM))) {
            wps->wphdr.block_samples = 0;
            free (wps->blockbuff);
            wps->blockbuff = nullptr;
            wpc->crc_errors++;
            continue;
        }

        wps->init_done = false;

        if (wps->wphdr.block_samples) {
            if (flags & OPEN_STREAMING)
                SET_BLOCK_INDEX (wps->wphdr, 0);
            else if (wpc->total_samples == -1) {
                if (GET_BLOCK_INDEX (wps->wphdr) || GET_TOTAL_SAMPLES (wps->wphdr) == -1) {
                    wpc->initial_index = GET_BLOCK_INDEX (wps->wphdr);
                    SET_BLOCK_INDEX (wps->wphdr, 0);

                    if (wpc->reader->can_seek (wpc->wv_in)) {
                        int64_t final_index = -1;

                        seek_eof_information (wpc, &final_index, false);

                        if (final_index != -1)
                            wpc->total_samples = final_index - wpc->initial_index;
                    }
                }
                else
                    wpc->total_samples = GET_TOTAL_SAMPLES (wps->wphdr);
            }
        }
        else if (wpc->total_samples == -1 && !GET_BLOCK_INDEX (wps->wphdr) && GET_TOTAL_SAMPLES (wps->wphdr))
            wpc->total_samples = GET_TOTAL_SAMPLES (wps->wphdr);

        if (wpc->wvc_in && wps->wphdr.block_samples && (wps->wphdr.flags & HYBRID_FLAG)) {
            uint8_t ch;

            if (wpc->reader->read_bytes (wpc->wvc_in, &ch, 1) == 1) {
                wpc->reader->push_back_byte (wpc->wvc_in, ch);
                wpc->file2len = wpc->reader->get_length (wpc->wvc_in);
                wpc->wvc_flag = true;
            }
        }

        if (wpc->wvc_flag && !read_wvc_block (wpc)) {
            if (error) strcpy (error, "not compatible with this version of correction file!");
            return WavpackCloseFile (wpc);
        }

        if (!wps->init_done && !unpack_init (wpc)) {
            if (error) strcpy (error, wpc->error_message [0] ? wpc->error_message :
                "not compatible with this version of WavPack file!");

            return WavpackCloseFile (wpc);
        }

        if (!wps->wphdr.block_samples) {    // free blockbuff if we're going to loop again
            free (wps->blockbuff);
            wps->blockbuff = nullptr;
        }

        wps->init_done = true;
    }

    wpc->config.flags &= ~0xff;
    wpc->config.flags |= wps->wphdr.flags & 0xff;

    if (!wpc->config.num_channels) {
        wpc->config.num_channels = (wps->wphdr.flags & MONO_FLAG) ? 1 : 2;
        wpc->config.channel_mask = 0x5 - wpc->config.num_channels;
    }

    if ((flags & OPEN_2CH_MAX) && !(wps->wphdr.flags & FINAL_BLOCK))
        wpc->reduced_channels = (wps->wphdr.flags & MONO_FLAG) ? 1 : 2;

    if (wps->wphdr.flags & DSD_FLAG) {
#if ENABLE_DSD
        if (flags & OPEN_DSD_NATIVE) {
            wpc->config.bytes_per_sample = 1;
            wpc->config.bits_per_sample = 8;
        }
        else if (flags & OPEN_DSD_AS_PCM) {
            wpc->decimation_context = decimate_dsd_init (wpc->reduced_channels ?
                wpc->reduced_channels : wpc->config.num_channels);

            wpc->config.bytes_per_sample = 3;
            wpc->config.bits_per_sample = 24;
        }
        else {
            if (error) strcpy (error, "not configured to handle DSD WavPack files!");
            return WavpackCloseFile (wpc);
        }
#else
        if (error) strcpy (error, "not configured to handle DSD WavPack files!");
        return WavpackCloseFile (wpc);
#endif
    }
    else {
        wpc->config.bytes_per_sample = (wps->wphdr.flags & BYTES_STORED) + 1;
        wpc->config.float_norm_exp = wps->float_norm_exp;

        wpc->config.bits_per_sample = (wpc->config.bytes_per_sample * 8) -
            ((wps->wphdr.flags & SHIFT_MASK) >> SHIFT_LSB);
    }

    if (!wpc->config.sample_rate) {
        if (!wps->wphdr.block_samples || (wps->wphdr.flags & SRATE_MASK) == SRATE_MASK)
            wpc->config.sample_rate = 44100;
        else
            wpc->config.sample_rate = sample_rates [(wps->wphdr.flags & SRATE_MASK) >> SRATE_LSB];
    }

    return wpc;
}

int WavpackGetVersion (WavpackContext *wpc)
{
    if (wpc) {
#if ENABLE_LEGACY
        if (wpc->stream3)
            return get_version3 (wpc);
#endif
        return wpc->version_five ? 5 : 4;
    }

    return 0;
}

uint8_t WavpackGetFileFormat (WavpackContext *wpc)
{
    return wpc->file_format;
}

char *WavpackGetFileExtension (WavpackContext *wpc)
{
    if (wpc && wpc->file_extension [0])
        return wpc->file_extension;
    else
        return "wav";
}

int unpack_init (WavpackContext *wpc)
{
    WavpackStream *wps = wpc->streams [wpc->current_stream];
    uint8_t *blockptr, *block2ptr;
    WavpackMetadata wpmd;

    wps->num_terms = 0;
    wps->mute_error = false;
    wps->crc = wps->crc_x = 0xffffffff;
    wps->dsd.ready = 0;
    CLEAR (wps->wvbits);
    CLEAR (wps->wvcbits);
    CLEAR (wps->wvxbits);
    CLEAR (wps->decorr_passes);
    CLEAR (wps->dc);
    CLEAR (wps->w);

    if (!(wps->wphdr.flags & MONO_FLAG) && wpc->config.num_channels && wps->wphdr.block_samples &&
        (wpc->reduced_channels == 1 || wpc->config.num_channels == 1)) {
            wps->mute_error = true;
            return false;
    }

    if ((wps->wphdr.flags & UNKNOWN_FLAGS) || (wps->wphdr.flags & MONO_DATA) == MONO_DATA) {
        wps->mute_error = true;
        return false;
    }

    blockptr = wps->blockbuff + sizeof (WavpackHeader);

    while (read_metadata_buff (&wpmd, wps->blockbuff, &blockptr))
        if (!process_metadata (wpc, &wpmd)) {
            wps->mute_error = true;
            return false;
        }

    if (wps->wphdr.block_samples && wpc->wvc_flag && wps->block2buff) {
        block2ptr = wps->block2buff + sizeof (WavpackHeader);

        while (read_metadata_buff (&wpmd, wps->block2buff, &block2ptr))
            if (!process_metadata (wpc, &wpmd)) {
                wps->mute_error = true;
                return false;
            }
    }

    if (wps->wphdr.block_samples && ((wps->wphdr.flags & DSD_FLAG) ? !wps->dsd.ready : !bs_is_open (&wps->wvbits))) {
        if (bs_is_open (&wps->wvcbits))
            strcpy (wpc->error_message, "can't unpack correction files alone!");

        wps->mute_error = true;
        return false;
    }

    if (wps->wphdr.block_samples && !bs_is_open (&wps->wvxbits)) {
        if ((wps->wphdr.flags & INT32_DATA) && wps->int32_sent_bits)
            wpc->lossy_blocks = true;

        if ((wps->wphdr.flags & FLOAT_DATA) &&
            wps->float_flags & (FLOAT_EXCEPTIONS | FLOAT_ZEROS_SENT | FLOAT_SHIFT_SENT | FLOAT_SHIFT_SAME))
                wpc->lossy_blocks = true;
    }

    if (wps->wphdr.block_samples)
        wps->sample_index = GET_BLOCK_INDEX (wps->wphdr);

    return true;
}

// These functions handle specific metadata types and are called directly
// during WavPack block parsing by process_metadata() at the bottom.

// This function initializes the main bitstream for audio samples, which must
// be in the "wv" file.

static int init_wv_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)
{
    if (!wpmd->byte_length || (wpmd->byte_length & 1))
        return false;

    bs_open_read (&wps->wvbits, wpmd->data, (uint8_t *) wpmd->data + wpmd->byte_length);
    return true;
}

// This function initializes the "correction" bitstream for audio samples,
// which currently must be in the "wvc" file.

static int init_wvc_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)
{
    if (!wpmd->byte_length || (wpmd->byte_length & 1))
        return false;

    bs_open_read (&wps->wvcbits, wpmd->data, (uint8_t *) wpmd->data + wpmd->byte_length);
    return true;
}

// This function initializes the "extra" bitstream for audio samples which
// contains the information required to losslessly decompress 32-bit float data
// or integer data that exceeds 24 bits. This bitstream is in the "wv" file
// for pure lossless data or the "wvc" file for hybrid lossless. This data
// would not be used for hybrid lossy mode. There is also a 32-bit CRC stored
// in the first 4 bytes of these blocks.

static int init_wvx_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)
{
    uint8_t *cp = (uint8_t *)wpmd->data;

    if (wpmd->byte_length <= 4 || (wpmd->byte_length & 1))
        return false;

    wps->crc_wvx = *cp++;
    wps->crc_wvx |= (uint32_t) *cp++ << 8;
    wps->crc_wvx |= (uint32_t) *cp++ << 16;
    wps->crc_wvx |= (uint32_t) *cp++ << 24;

    bs_open_read (&wps->wvxbits, cp, (uint8_t *) wpmd->data + wpmd->byte_length);
    return true;
}

// Read the int32 data from the specified metadata into the specified stream.
// This data is used for integer data that has more than 24 bits of magnitude
// or, in some cases, used to eliminate redundant bits from any audio stream.

static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;

    if (bytecnt != 4)
        return false;

    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;

    return true;
}

static int read_float_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;

    if (bytecnt != 4)
        return false;

    wps->float_flags = *byteptr++;
    wps->float_shift = *byteptr++;
    wps->float_max_exp = *byteptr++;
    wps->float_norm_exp = *byteptr;
    return true;
}

// Read multichannel information from metadata. The first byte is the total
// number of channels and the following bytes represent the channel_mask
// as described for Microsoft WAVEFORMATEX.

static int read_channel_info (WavpackContext *wpc, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length, shift = 0, mask_bits;
    uint8_t *byteptr = (uint8_t *)wpmd->data;
    uint32_t mask = 0;

    if (!bytecnt || bytecnt > 7)
        return false;

    if (!wpc->config.num_channels) {

        // if bytecnt is 6 or 7 we are using new configuration with "unlimited" streams

        if (bytecnt >= 6) {
            wpc->config.num_channels = (byteptr [0] | ((byteptr [2] & 0xf) << 8)) + 1;
            wpc->max_streams = (byteptr [1] | ((byteptr [2] & 0xf0) << 4)) + 1;

            if (wpc->config.num_channels < wpc->max_streams)
                return false;

            byteptr += 3;
            mask = *byteptr++;
            mask |= (uint32_t) *byteptr++ << 8;
            mask |= (uint32_t) *byteptr++ << 16;

            if (bytecnt == 7)                           // this was introduced in 5.0
                mask |= (uint32_t) *byteptr << 24;
        }
        else {
            wpc->config.num_channels = *byteptr++;

            while (--bytecnt) {
                mask |= (uint32_t) *byteptr++ << shift;
                shift += 8;
            }
        }

        if (wpc->config.num_channels > wpc->max_streams * 2)
            return false;

        wpc->config.channel_mask = mask;

        for (mask_bits = 0; mask; mask >>= 1)
            if ((mask & 1) && ++mask_bits > wpc->config.num_channels)
                return false;
    }

    return true;
}

// Read multichannel identity information from metadata. Data is an array of
// uint8_tacters representing any channels in the file that DO NOT
// match one the 18 Microsoft standard channels (and are represented in the
// channel mask). A value of 0 is not allowed and 0xff means an unknown or
// undefined channel identity.

static int read_channel_identities (WavpackContext *wpc, WavpackMetadata *wpmd)
{
    uint8_t *idents = (uint8_t *)wpmd->data;
    int i;

    if (!wpmd->data || !wpmd->byte_length)
        return false;

    for (i = 0; i < wpmd->byte_length; ++i)
        if (!idents [i])
            return false;

    if (!wpc->channel_identities) {
        wpc->channel_identities = (uint8_t *)malloc (wpmd->byte_length + 1);
        memcpy (wpc->channel_identities, wpmd->data, wpmd->byte_length);
        wpc->channel_identities [wpmd->byte_length] = 0;
    }

    return true;
}

// Read configuration information from metadata.

static int read_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    uint8_t *byteptr = (uint8_t *)wpmd->data;

    if (bytecnt >= 3) {
        wpc->config.flags &= 0xff;
        wpc->config.flags |= (uint32_t) *byteptr++ << 8;
        wpc->config.flags |= (uint32_t) *byteptr++ << 16;
        wpc->config.flags |= (uint32_t) *byteptr++ << 24;
        bytecnt -= 3;

        if (bytecnt && (wpc->config.flags & CONFIG_EXTRA_MODE)) {
            wpc->config.xmode = *byteptr++;
            bytecnt--;
        }

        // we used an extra config byte here for the 5.0.0 alpha, so still
        // honor it now (but this has been replaced with NEW_CONFIG)

        if (bytecnt) {
            wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr;
            wpc->version_five = 1;
        }
    }

    return true;
}

// Read "new" configuration information from metadata.

static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    uint8_t *byteptr = (uint8_t *)wpmd->data;

    wpc->version_five = 1;      // just having this block signals version 5.0

    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;

    if (wpc->channel_reordering) {
        free (wpc->channel_reordering);
        wpc->channel_reordering = nullptr;
    }

    // if there's any data, the first two bytes are file_format and qmode flags

    if (bytecnt >= 2) {
        wpc->file_format = *byteptr++;
        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;
        bytecnt -= 2;

        // another byte indicates a channel layout

        if (bytecnt) {
            int nchans, i;

            wpc->channel_layout = (uint32_t) *byteptr++ << 16;
            bytecnt--;

            // another byte means we have a channel count for the layout and maybe a reordering

            if (bytecnt) {
                wpc->channel_layout += nchans = *byteptr++;
                bytecnt--;

                // any more means there's a reordering string

                if (bytecnt) {
                    if (bytecnt > nchans)
                        return false;

                    wpc->channel_reordering = (uint8_t *)malloc (nchans);

                    // note that redundant reordering info is not stored, so we fill in the rest

                    if (wpc->channel_reordering) {
                        for (i = 0; i < nchans; ++i)
                            if (bytecnt) {
                                wpc->channel_reordering [i] = *byteptr++;

                                if (wpc->channel_reordering [i] >= nchans)  // make sure index is in range
                                    wpc->channel_reordering [i] = 0;

                                bytecnt--;
                            }
                            else
                                wpc->channel_reordering [i] = i;
                    }
                }
            }
            else
                wpc->channel_layout += wpc->config.num_channels;
        }
    }

    return true;
}

// Read non-standard sampling rate from metadata.

static int read_sample_rate (WavpackContext *wpc, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    uint8_t *byteptr = (uint8_t *)wpmd->data;

    if (bytecnt == 3 || bytecnt == 4) {
        wpc->config.sample_rate = (int32_t) *byteptr++;
        wpc->config.sample_rate |= (int32_t) *byteptr++ << 8;
        wpc->config.sample_rate |= (int32_t) *byteptr++ << 16;

        // for sampling rates > 16777215 (non-audio probably, or ...)

        if (bytecnt == 4)
            wpc->config.sample_rate |= (int32_t) (*byteptr & 0x7f) << 24;
    }

    return true;
}

// Read wrapper data from metadata. Currently, this consists of the RIFF
// header and trailer that wav files contain around the audio data but could
// be used for other formats as well. Because WavPack files contain all the
// information required for decoding and playback, this data can probably
// be ignored except when an exact wavefile restoration is needed.

static int read_wrapper_data (WavpackContext *wpc, WavpackMetadata *wpmd)
{
    if ((wpc->open_flags & OPEN_WRAPPER) && wpc->wrapper_bytes < MAX_WRAPPER_BYTES && wpmd->byte_length) {
        wpc->wrapper_data = (uint8_t *)realloc (wpc->wrapper_data, wpc->wrapper_bytes + wpmd->byte_length);
    if (!wpc->wrapper_data)
        return false;
        memcpy (wpc->wrapper_data + wpc->wrapper_bytes, wpmd->data, wpmd->byte_length);
        wpc->wrapper_bytes += wpmd->byte_length;
    }

    return true;
}

static int read_metadata_buff (WavpackMetadata *wpmd, uint8_t *blockbuff, uint8_t **buffptr)
{
    WavpackHeader *wphdr = (WavpackHeader *) blockbuff;
    uint8_t *buffend = blockbuff + wphdr->ckSize + 8;

    if (buffend - *buffptr < 2)
        return false;

    wpmd->id = *(*buffptr)++;
    wpmd->byte_length = *(*buffptr)++ << 1;

    if (wpmd->id & ID_LARGE) {
        wpmd->id &= ~ID_LARGE;

        if (buffend - *buffptr < 2)
            return false;

        wpmd->byte_length += *(*buffptr)++ << 9;
        wpmd->byte_length += *(*buffptr)++ << 17;
    }

    if (wpmd->id & ID_ODD_SIZE) {
        if (!wpmd->byte_length)         // odd size and zero length makes no sense
            return false;
        wpmd->id &= ~ID_ODD_SIZE;
        wpmd->byte_length--;
    }

    if (wpmd->byte_length) {
        if (buffend - *buffptr < wpmd->byte_length + (wpmd->byte_length & 1)) {
            wpmd->data = nullptr;
            return false;
        }

        wpmd->data = *buffptr;
        (*buffptr) += wpmd->byte_length + (wpmd->byte_length & 1);
    }
    else
        wpmd->data = nullptr;

    return true;
}

static int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd)
{
    WavpackStream *wps = wpc->streams [wpc->current_stream];

    switch (wpmd->id) {
        case ID_DUMMY:
            return true;

        case ID_DECORR_TERMS:
            return read_decorr_terms (wps, wpmd);

        case ID_DECORR_WEIGHTS:
            return read_decorr_weights (wps, wpmd);

        case ID_DECORR_SAMPLES:
            return read_decorr_samples (wps, wpmd);

        case ID_ENTROPY_VARS:
            return read_entropy_vars (wps, wpmd);

        case ID_HYBRID_PROFILE:
            return read_hybrid_profile (wps, wpmd);

        case ID_SHAPING_WEIGHTS:
            return read_shaping_info (wps, wpmd);

        case ID_FLOAT_INFO:
            return read_float_info (wps, wpmd);

        case ID_INT32_INFO:
            return read_int32_info (wps, wpmd);

        case ID_CHANNEL_INFO:
            return read_channel_info (wpc, wpmd);

        case ID_CHANNEL_IDENTITIES:
            return read_channel_identities (wpc, wpmd);

        case ID_CONFIG_BLOCK:
            return read_config_info (wpc, wpmd);

        case ID_NEW_CONFIG_BLOCK:
            return read_new_config_info (wpc, wpmd);

        case ID_SAMPLE_RATE:
            return read_sample_rate (wpc, wpmd);

        case ID_WV_BITSTREAM:
            return init_wv_bitstream (wps, wpmd);

        case ID_WVC_BITSTREAM:
            return init_wvc_bitstream (wps, wpmd);

        case ID_WVX_BITSTREAM:
            return init_wvx_bitstream (wps, wpmd);

        case ID_DSD_BLOCK:
#if ENABLE_DSD
            return init_dsd_block (wpc, wpmd);
#else
            strcpy (wpc->error_message, "not configured to handle DSD WavPack files!");
            return false;
#endif

        case ID_ALT_HEADER: case ID_ALT_TRAILER:
            if (!(wpc->open_flags & OPEN_ALT_TYPES))
                return true;

        case ID_RIFF_HEADER: case ID_RIFF_TRAILER:
            return read_wrapper_data (wpc, wpmd);

        case ID_ALT_MD5_CHECKSUM:
            if (!(wpc->open_flags & OPEN_ALT_TYPES))
                return true;

        case ID_MD5_CHECKSUM:
            if (wpmd->byte_length == 16) {
                memcpy (wpc->config.md5_checksum, wpmd->data, 16);
                wpc->config.flags |= CONFIG_MD5_CHECKSUM;
                wpc->config.md5_read = 1;
            }

            return true;

        case ID_ALT_EXTENSION:
            if (wpmd->byte_length && wpmd->byte_length < sizeof (wpc->file_extension)) {
                memcpy (wpc->file_extension, wpmd->data, wpmd->byte_length);
                wpc->file_extension [wpmd->byte_length] = 0;
            }

            return true;

        // we don't actually verify the checksum here (it's done right after the
        // block is read), but it's a good indicator of version 5 files

        case ID_BLOCK_CHECKSUM:
            wpc->version_five = 1;
            return true;

        default:
            return (wpmd->id & ID_OPTIONAL_DATA) ? true : false;
    }
}

//////////////////////////////// bitstream management ///////////////////////////////

// Open the specified BitStream and associate with the specified buffer.

static void bs_read (Bitstream *bs);

static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->buf = (uint16_t *)buffer_start;
    bs->ptr = bs->buf - 1;
    bs->end = (uint16_t *)buffer_end;
    bs->wrap = bs_read;
}

// This function is only called from the getbit() and getbits() macros when
// the BitStream has been exhausted and more data is required. Sinve these
// bistreams no longer access files, this function simple sets an error and
// resets the buffer.

static void bs_read (Bitstream *bs)
{
    bs->ptr = bs->buf;
    bs->error = 1;
}

// This function is called to close the bitstream. It returns the number of
// full bytes actually read as bits.

uint32_t bs_close_read (Bitstream *bs)
{
    uint32_t bytes_read;

    if (bs->bc < sizeof (*(bs->ptr)) * 8)
        bs->ptr++;

    bytes_read = (uint32_t)(bs->ptr - bs->buf) * sizeof (*(bs->ptr));

    if (!(bytes_read & 1))
        ++bytes_read;

    CLEAR (*bs);
    return bytes_read;
}

// Normally the trailing wrapper will not be available when a WavPack file is first
// opened for reading because it is stored in the final block of the file. This
// function forces a seek to the end of the file to pick up any trailing wrapper
// stored there (then use WavPackGetWrapper**() to obtain). This can obviously only
// be used for seekable files (not pipes) and is not available for pre-4.0 WavPack
// files.

void WavpackSeekTrailingWrapper (WavpackContext *wpc)
{
    if ((wpc->open_flags & OPEN_WRAPPER) &&
        wpc->reader->can_seek (wpc->wv_in) && !wpc->stream3)
            seek_eof_information (wpc, nullptr, true);
}

// Get any MD5 checksum stored in the metadata (should be called after reading
// last sample or an extra seek will occur). A return value of false indicates
// that no MD5 checksum was stored.

int WavpackGetMD5Sum (WavpackContext *wpc, uint8_t data [16])
{
    if (wpc->config.flags & CONFIG_MD5_CHECKSUM) {
        if (!wpc->config.md5_read && wpc->reader->can_seek (wpc->wv_in))
            seek_eof_information (wpc, nullptr, false);

        if (wpc->config.md5_read) {
            memcpy (data, wpc->config.md5_checksum, 16);
            return true;
        }
    }

    return false;
}

// Read from current file position until a valid 32-byte WavPack 4.0 header is
// found and read into the specified pointer. The number of bytes skipped is
// returned. If no WavPack header is found within 1 meg, then a -1 is returned
// to indicate the error. No additional bytes are read past the header and it
// is returned in the processor's native endian mode. Seeking is not required.

uint32_t read_next_header (WavpackStreamReader64 *reader, void *id, WavpackHeader *wphdr)
{
    uint8_t buffer [sizeof (*wphdr)], *sp = buffer + sizeof (*wphdr), *ep = sp;
    uint32_t bytes_skipped = 0;
    int bleft;

    while (1) {
        if (sp < ep) {
            bleft = (int)(ep - sp);
            memmove (buffer, sp, bleft);
        }
        else
            bleft = 0;

        if (reader->read_bytes (id, buffer + bleft, sizeof (*wphdr) - bleft) != sizeof (*wphdr) - bleft)
            return -1;

        sp = buffer;

        if (*sp++ == 'w' && *sp == 'v' && *++sp == 'p' && *++sp == 'k' &&
            !(*++sp & 1) && sp [2] < 16 && !sp [3] && (sp [2] || sp [1] || *sp >= 24) && sp [5] == 4 &&
            sp [4] >= (MIN_STREAM_VERS & 0xff) && sp [4] <= (MAX_STREAM_VERS & 0xff) && sp [18] < 3 && !sp [19]) {
                memcpy (wphdr, buffer, sizeof (*wphdr));
                WavpackLittleEndianToNative (wphdr, WavpackHeaderFormat);
                return bytes_skipped;
            }

        while (sp < ep && *sp != 'w')
            sp++;

        if ((bytes_skipped += (uint32_t)(sp - buffer)) > 1024 * 1024)
            return -1;
    }
}

// Compare the regular wv file block header to a potential matching wvc
// file block header and return action code based on analysis:
//
//   0 = use wvc block (assuming rest of block is readable)
//   1 = bad match; try to read next wvc block
//  -1 = bad match; ignore wvc file for this block and backup fp (if
//       possible) and try to use this block next time

static int match_wvc_header (WavpackHeader *wv_hdr, WavpackHeader *wvc_hdr)
{
    if (GET_BLOCK_INDEX (*wv_hdr) == GET_BLOCK_INDEX (*wvc_hdr) &&
        wv_hdr->block_samples == wvc_hdr->block_samples) {
            int wvi = 0, wvci = 0;

            if (wv_hdr->flags == wvc_hdr->flags)
                return 0;

            if (wv_hdr->flags & INITIAL_BLOCK)
                wvi -= 1;

            if (wv_hdr->flags & FINAL_BLOCK)
                wvi += 1;

            if (wvc_hdr->flags & INITIAL_BLOCK)
                wvci -= 1;

            if (wvc_hdr->flags & FINAL_BLOCK)
                wvci += 1;

            return (wvci - wvi < 0) ? 1 : -1;
        }

    if ((GET_BLOCK_INDEX (*wvc_hdr) - GET_BLOCK_INDEX (*wv_hdr)) & 0x8000000000LL)
        return 1;
    else
        return -1;
}

// Read the wvc block that matches the regular wv block that has been
// read for the current stream. If an exact match is not found then
// we either keep reading or back up and (possibly) use the block
// later. The skip_wvc flag is set if not matching wvc block is found
// so that we can still decode using only the lossy version (although
// we flag this as an error). A return of false indicates a serious
// error (not just that we missed one wvc block).

int read_wvc_block (WavpackContext *wpc)
{
    WavpackStream *wps = wpc->streams [wpc->current_stream];
    int64_t bcount, file2pos;
    WavpackHeader orig_wphdr;
    WavpackHeader wphdr;
    int compare_result;

    while (1) {
        file2pos = wpc->reader->get_pos (wpc->wvc_in);
        bcount = read_next_header (wpc->reader, wpc->wvc_in, &wphdr);

        if (bcount == (uint32_t) -1) {
            wps->wvc_skip = true;
            wpc->crc_errors++;
            return false;
        }

        memcpy (&orig_wphdr, &wphdr, 32);       // save original header for verify step

        if (wpc->open_flags & OPEN_STREAMING)
            SET_BLOCK_INDEX (wphdr, wps->sample_index = 0);
        else
            SET_BLOCK_INDEX (wphdr, GET_BLOCK_INDEX (wphdr) - wpc->initial_index);

        if (wphdr.flags & INITIAL_BLOCK)
            wpc->file2pos = file2pos + bcount;

        compare_result = match_wvc_header (&wps->wphdr, &wphdr);

        if (!compare_result) {
            wps->block2buff = (uint8_t *)malloc (wphdr.ckSize + 8);
        if (!wps->block2buff)
            return false;

            if (wpc->reader->read_bytes (wpc->wvc_in, wps->block2buff + 32, wphdr.ckSize - 24) !=
                wphdr.ckSize - 24) {
                    free (wps->block2buff);
                    wps->block2buff = nullptr;
                    wps->wvc_skip = true;
                    wpc->crc_errors++;
                    return false;
            }

            memcpy (wps->block2buff, &orig_wphdr, 32);

            // don't use corrupt blocks
            if (!WavpackVerifySingleBlock (wps->block2buff, !(wpc->open_flags & OPEN_NO_CHECKSUM))) {
                free (wps->block2buff);
                wps->block2buff = nullptr;
                wps->wvc_skip = true;
                wpc->crc_errors++;
                return true;
            }

            wps->wvc_skip = false;
            memcpy (wps->block2buff, &wphdr, 32);
            memcpy (&wps->wphdr, &wphdr, 32);
            return true;
        }
        else if (compare_result == -1) {
            wps->wvc_skip = true;
            wpc->reader->set_pos_rel (wpc->wvc_in, -32, SEEK_CUR);
            wpc->crc_errors++;
            return true;
        }
    }
}

// This function is used to seek to end of a file to obtain certain information
// that is stored there at the file creation time because it is not known at
// the start. This includes the MD5 sum and and trailing part of the file
// wrapper, and in some rare cases may include the total number of samples in
// the file (although we usually try to back up and write that at the front of
// the file). Note this function restores the file position to its original
// location (and obviously requires a seekable file). The normal return value
// is true indicating no errors, although this does not actually mean that any
// information was retrieved. An error return of false usually means the file
// terminated unexpectedly. Note that this could be used to get all three
// types of information in one go, but it's not actually used that way now.

static int seek_eof_information (WavpackContext *wpc, int64_t *final_index, int get_wrapper)
{
    int64_t restore_pos, last_pos = -1;
    WavpackStreamReader64 *reader = wpc->reader;
    int alt_types = wpc->open_flags & OPEN_ALT_TYPES;
    uint32_t blocks = 0, audio_blocks = 0;
    void *id = wpc->wv_in;
    WavpackHeader wphdr;

    restore_pos = reader->get_pos (id);    // we restore file position when done

    // start 1MB from the end-of-file, or from the start if the file is not that big

    if (reader->get_length (id) > (int64_t) 1048576)
        reader->set_pos_rel (id, -1048576, SEEK_END);
    else
        reader->set_pos_abs (id, 0);

    // Note that we go backward (without parsing inside blocks) until we find a block
    // with audio (careful to not get stuck in a loop). Only then do we go forward
    // parsing all blocks in their entirety.

    while (1) {
        uint32_t bcount = read_next_header (reader, id, &wphdr);
        int64_t current_pos = reader->get_pos (id);

        // if we just got to the same place as last time, we're stuck and need to give up

        if (current_pos == last_pos) {
            reader->set_pos_abs (id, restore_pos);
            return false;
        }

        last_pos = current_pos;

        // We enter here if we just read 1 MB without seeing any WavPack block headers.
        // Since WavPack blocks are < 1 MB, that means we're in a big APE tag, or we got
        // to the end-of-file.

        if (bcount == (uint32_t) -1) {

            // if we have not seen any blocks at all yet, back up almost 2 MB (or to the
            // beginning of the file) and try again

            if (!blocks) {
                if (current_pos > (int64_t) 2000000)
                    reader->set_pos_rel (id, -2000000, SEEK_CUR);
                else
                    reader->set_pos_abs (id, 0);

                continue;
            }

            // if we have seen WavPack blocks, then this means we've done all we can do here

            reader->set_pos_abs (id, restore_pos);
            return true;
        }

        blocks++;

        // If the block has audio samples, calculate a final index, although this is not
        // final since this may not be the last block with audio. On the other hand, if
        // this block does not have audio, and we haven't seen one with audio, we have
        // to go back some more.

        if (wphdr.block_samples) {
            if (final_index)
                *final_index = GET_BLOCK_INDEX (wphdr) + wphdr.block_samples;

            audio_blocks++;
        }
        else if (!audio_blocks) {
            if (current_pos > (int64_t) 1048576)
                reader->set_pos_rel (id, -1048576, SEEK_CUR);
            else
                reader->set_pos_abs (id, 0);

            continue;
        }

        // at this point we have seen at least one block with audio, so we parse the
        // entire block looking for MD5 metadata or (conditionally) trailing wrappers

        bcount = wphdr.ckSize - sizeof (WavpackHeader) + 8;

        while (bcount >= 2) {
            uint8_t meta_id, c1, c2;
            uint32_t meta_bc, meta_size;

            if (reader->read_bytes (id, &meta_id, 1) != 1 ||
                reader->read_bytes (id, &c1, 1) != 1) {
                    reader->set_pos_abs (id, restore_pos);
                    return false;
            }

            meta_bc = c1 << 1;
            bcount -= 2;

            if (meta_id & ID_LARGE) {
                if (bcount < 2 || reader->read_bytes (id, &c1, 1) != 1 ||
                    reader->read_bytes (id, &c2, 1) != 1) {
                        reader->set_pos_abs (id, restore_pos);
                        return false;
                }

                meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);
                bcount -= 2;
            }

            meta_size = (meta_id & ID_ODD_SIZE) ? meta_bc - 1 : meta_bc;
            meta_id &= ID_UNIQUE;

            if (get_wrapper && (meta_id == ID_RIFF_TRAILER || (alt_types && meta_id == ID_ALT_TRAILER)) && meta_bc) {
                wpc->wrapper_data = (uint8_t *)realloc (wpc->wrapper_data, wpc->wrapper_bytes + meta_bc);

                if (!wpc->wrapper_data) {
                    reader->set_pos_abs (id, restore_pos);
                    return false;
                }

                if (reader->read_bytes (id, wpc->wrapper_data + wpc->wrapper_bytes, meta_bc) == meta_bc)
                    wpc->wrapper_bytes += meta_size;
                else {
                    reader->set_pos_abs (id, restore_pos);
                    return false;
                }
            }
            else if (meta_id == ID_MD5_CHECKSUM || (alt_types && meta_id == ID_ALT_MD5_CHECKSUM)) {
                if (meta_bc == 16 && bcount >= 16) {
                    if (reader->read_bytes (id, wpc->config.md5_checksum, 16) == 16)
                        wpc->config.md5_read = true;
                    else {
                        reader->set_pos_abs (id, restore_pos);
                        return false;
                    }
                }
                else
                    reader->set_pos_rel (id, meta_bc, SEEK_CUR);
            }
            else
                reader->set_pos_rel (id, meta_bc, SEEK_CUR);

            bcount -= meta_bc;
        }
    }
}

// Quickly verify the referenced block. It is assumed that the WavPack header has been converted
// to native endian format. If a block checksum is performed, that is done in little-endian
// (file) format. It is also assumed that the caller has made sure that the block length
// indicated in the header is correct (we won't overflow the buffer). If a checksum is present,
// then it is checked, otherwise we just check that all the metadata blocks are formatted
// correctly (without looking at their contents). Returns false for bad block.

int WavpackVerifySingleBlock (uint8_t *buffer, int verify_checksum)
{
    WavpackHeader *wphdr = (WavpackHeader *) buffer;
    uint32_t checksum_passed = 0, bcount, meta_bc;
    uint8_t *dp, meta_id, c1, c2;

    if (strncmp (wphdr->ckID, "wvpk", 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader))
        return false;

    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;
    dp = (uint8_t *)(wphdr + 1);

    while (bcount >= 2) {
        meta_id = *dp++;
        c1 = *dp++;

        meta_bc = c1 << 1;
        bcount -= 2;

        if (meta_id & ID_LARGE) {
            if (bcount < 2)
                return false;

            c1 = *dp++;
            c2 = *dp++;
            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);
            bcount -= 2;
        }

        if (bcount < meta_bc)
            return false;

        if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {
#if BITSTREAM_SHORTS
            uint16_t *csptr = (uint16_t*) buffer;
#else
            uint8_t *csptr = buffer;
#endif
            int wcount = (int)(dp - 2 - buffer) >> 1;
            uint32_t csum = (uint32_t) -1;

            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)
                return false;

#if BITSTREAM_SHORTS
            while (wcount--)
                csum = (csum * 3) + *csptr++;
#else
            WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat);

            while (wcount--) {
                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);
                csptr += 2;
            }

            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);
#endif

            if (meta_bc == 4) {
                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff))
                    return false;
            }
            else {
                csum ^= csum >> 16;

                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff))
                    return false;
            }

            checksum_passed++;
        }

        bcount -= meta_bc;
        dp += meta_bc;
    }

    return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed);
}


#if defined (HAVE___BUILTIN_CTZ) || defined (_WIN64)
#define USE_CTZ_OPTIMIZATION    // use ctz intrinsic (or Windows equivalent) to count trailing ones
#else
#define USE_NEXT8_OPTIMIZATION  // optimization using a table to count trailing ones
#endif

#define USE_BITMASK_TABLES      // use tables instead of shifting for certain masking operations

///////////////////////////// local table storage ////////////////////////////

#if USE_NEXT8_OPTIMIZATION
static const char ones_count_table [] = {
    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,
    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,
    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,
    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,
    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,
    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,
    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,
    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,8
};
#endif

///////////////////////////// executable code ////////////////////////////////

static uint32_t __inline read_code (Bitstream *bs, uint32_t maxcode);

int32_t FASTCALL get_word (WavpackStream *wps, int chan, int32_t *correction)
{
    struct entropy_data *c = wps->w.c + chan;
    uint32_t ones_count, low, mid, high;
    int32_t value;
    int sign;

    if (!wps->wvbits.ptr)
        return WORD_EOF;

    if (correction)
        *correction = 0;

    if (!(wps->w.c [0].median [0] & ~1) && !wps->w.holding_zero && !wps->w.holding_one && !(wps->w.c [1].median [0] & ~1)) {
        uint32_t mask;
        int cbits;

        if (wps->w.zeros_acc) {
            if (--wps->w.zeros_acc) {
                c->slow_level -= (c->slow_level + SLO) >> SLS;
                return 0;
            }
        }
        else {
            for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);

            if (cbits == 33)
                return WORD_EOF;

            if (cbits < 2)
                wps->w.zeros_acc = cbits;
            else {
                for (mask = 1, wps->w.zeros_acc = 0; --cbits; mask <<= 1)
                    if (getbit (&wps->wvbits))
                        wps->w.zeros_acc |= mask;

                wps->w.zeros_acc |= mask;
            }

            if (wps->w.zeros_acc) {
                c->slow_level -= (c->slow_level + SLO) >> SLS;
                CLEAR (wps->w.c [0].median);
                CLEAR (wps->w.c [1].median);
                return 0;
            }
        }
    }

    if (wps->w.holding_zero)
        ones_count = wps->w.holding_zero = 0;
    else {
#if USE_CTZ_OPTIMIZATION
        while (wps->wvbits.bc < LIMIT_ONES) {
            if (++(wps->wvbits.ptr) == wps->wvbits.end)
                wps->wvbits.wrap (&wps->wvbits);

            wps->wvbits.sr |= *(wps->wvbits.ptr) << wps->wvbits.bc;
            wps->wvbits.bc += sizeof (*(wps->wvbits.ptr)) * 8;
        }

#if _MSC_VER
        { unsigned long res; _BitScanForward (&res, (unsigned long)~wps->wvbits.sr); ones_count = (uint32_t) res; }
#else
        ones_count = __builtin_ctz (~wps->wvbits.sr);
#endif

        if (ones_count >= LIMIT_ONES) {
            wps->wvbits.bc -= ones_count;
            wps->wvbits.sr >>= ones_count;

            for (; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);

            if (ones_count == (LIMIT_ONES + 1))
                return WORD_EOF;

            if (ones_count == LIMIT_ONES) {
                uint32_t mask;
                int cbits;

                for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);

                if (cbits == 33)
                    return WORD_EOF;

                if (cbits < 2)
                    ones_count = cbits;
                else {
                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)
                        if (getbit (&wps->wvbits))
                            ones_count |= mask;

                    ones_count |= mask;
                }

                ones_count += LIMIT_ONES;
            }
        }
        else {
            wps->wvbits.bc -= ones_count + 1;
            wps->wvbits.sr >>= ones_count + 1;
        }
#elif defined (USE_NEXT8_OPTIMIZATION)
        int next8;

        if (wps->wvbits.bc < 8) {
            if (++(wps->wvbits.ptr) == wps->wvbits.end)
                wps->wvbits.wrap (&wps->wvbits);

            next8 = (wps->wvbits.sr |= *(wps->wvbits.ptr) << wps->wvbits.bc) & 0xff;
            wps->wvbits.bc += sizeof (*(wps->wvbits.ptr)) * 8;
        }
        else
            next8 = wps->wvbits.sr & 0xff;

        if (next8 == 0xff) {
            wps->wvbits.bc -= 8;
            wps->wvbits.sr >>= 8;

            for (ones_count = 8; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);

            if (ones_count == (LIMIT_ONES + 1))
                return WORD_EOF;

            if (ones_count == LIMIT_ONES) {
                uint32_t mask;
                int cbits;

                for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);

                if (cbits == 33)
                    return WORD_EOF;

                if (cbits < 2)
                    ones_count = cbits;
                else {
                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)
                        if (getbit (&wps->wvbits))
                            ones_count |= mask;

                    ones_count |= mask;
                }

                ones_count += LIMIT_ONES;
            }
        }
        else {
            wps->wvbits.bc -= (ones_count = ones_count_table [next8]) + 1;
            wps->wvbits.sr >>= ones_count + 1;
        }
#else
        for (ones_count = 0; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);

        if (ones_count >= LIMIT_ONES) {
            uint32_t mask;
            int cbits;

            if (ones_count == (LIMIT_ONES + 1))
                return WORD_EOF;

            for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);

            if (cbits == 33)
                return WORD_EOF;

            if (cbits < 2)
                ones_count = cbits;
            else {
                for (mask = 1, ones_count = 0; --cbits; mask <<= 1)
                    if (getbit (&wps->wvbits))
                        ones_count |= mask;

                ones_count |= mask;
            }

            ones_count += LIMIT_ONES;
        }
#endif

        if (wps->w.holding_one) {
            wps->w.holding_one = ones_count & 1;
            ones_count = (ones_count >> 1) + 1;
        }
        else {
            wps->w.holding_one = ones_count & 1;
            ones_count >>= 1;
        }

        wps->w.holding_zero = ~wps->w.holding_one & 1;
    }

    if ((wps->wphdr.flags & HYBRID_FLAG) && !chan)
        update_error_limit (wps);

    if (ones_count == 0) {
        low = 0;
        high = GET_MED (0) - 1;
        DEC_MED0 ();
    }
    else {
        low = GET_MED (0);
        INC_MED0 ();

        if (ones_count == 1) {
            high = low + GET_MED (1) - 1;
            DEC_MED1 ();
        }
        else {
            low += GET_MED (1);
            INC_MED1 ();

            if (ones_count == 2) {
                high = low + GET_MED (2) - 1;
                DEC_MED2 ();
            }
            else {
                low += (ones_count - 2) * GET_MED (2);
                high = low + GET_MED (2) - 1;
                INC_MED2 ();
            }
        }
    }

    low &= 0x7fffffff;
    high &= 0x7fffffff;

    if (low > high)         // make sure high and low make sense
        high = low;

    mid = (high + low + 1) >> 1;

    if (!c->error_limit)
        mid = read_code (&wps->wvbits, high - low) + low;
    else while (high - low > c->error_limit) {
        if (getbit (&wps->wvbits))
            mid = (high + (low = mid) + 1) >> 1;
        else
            mid = ((high = mid - 1) + low + 1) >> 1;
    }

    sign = getbit (&wps->wvbits);

    if (bs_is_open (&wps->wvcbits) && c->error_limit) {
        value = read_code (&wps->wvcbits, high - low) + low;

        if (correction)
            *correction = sign ? (mid - value) : (value - mid);
    }

    if (wps->wphdr.flags & HYBRID_BITRATE) {
        c->slow_level -= (c->slow_level + SLO) >> SLS;
        c->slow_level += wp_log2 (mid);
    }

    return sign ? ~mid : mid;
}

int32_t get_words_lossless (WavpackStream *wps, int32_t *buffer, int32_t nsamples)
{
    struct entropy_data *c = wps->w.c;
    uint32_t ones_count, low, high;
    Bitstream *bs = &wps->wvbits;
    int32_t csamples;
#if USE_NEXT8_OPTIMIZATION
    int32_t next8;
#endif

    if (nsamples && !bs->ptr) {
        memset (buffer, 0, (wps->wphdr.flags & MONO_DATA) ? nsamples * 4 : nsamples * 8);
        return nsamples;
    }

    if (!(wps->wphdr.flags & MONO_DATA))
        nsamples *= 2;

    for (csamples = 0; csamples < nsamples; ++csamples) {
        if (!(wps->wphdr.flags & MONO_DATA))
            c = wps->w.c + (csamples & 1);

        if (wps->w.holding_zero) {
            wps->w.holding_zero = 0;
            low = read_code (bs, GET_MED (0) - 1);
            DEC_MED0 ();
            buffer [csamples] = (getbit (bs)) ? ~low : low;

            if (++csamples == nsamples)
                break;

            if (!(wps->wphdr.flags & MONO_DATA))
                c = wps->w.c + (csamples & 1);
        }

        if (wps->w.c [0].median [0] < 2 && !wps->w.holding_one && wps->w.c [1].median [0] < 2) {
            uint32_t mask;
            int cbits;

            if (wps->w.zeros_acc) {
                if (--wps->w.zeros_acc) {
                    buffer [csamples] = 0;
                    continue;
                }
            }
            else {
                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);

                if (cbits == 33)
                    break;

                if (cbits < 2)
                    wps->w.zeros_acc = cbits;
                else {
                    for (mask = 1, wps->w.zeros_acc = 0; --cbits; mask <<= 1)
                        if (getbit (bs))
                            wps->w.zeros_acc |= mask;

                    wps->w.zeros_acc |= mask;
                }

                if (wps->w.zeros_acc) {
                    CLEAR (wps->w.c [0].median);
                    CLEAR (wps->w.c [1].median);
                    buffer [csamples] = 0;
                    continue;
                }
            }
        }

#if USE_CTZ_OPTIMIZATION
        while (bs->bc < LIMIT_ONES) {
            if (++(bs->ptr) == bs->end)
                bs->wrap (bs);

            bs->sr |= *(bs->ptr) << bs->bc;
            bs->bc += sizeof (*(bs->ptr)) * 8;
        }

#if _MSC_VER
        { unsigned long res; _BitScanForward (&res, (unsigned long)~wps->wvbits.sr); ones_count = (uint32_t) res; }
#else
        ones_count = __builtin_ctz (~wps->wvbits.sr);
#endif

        if (ones_count >= LIMIT_ONES) {
            bs->bc -= ones_count;
            bs->sr >>= ones_count;

            for (; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);

            if (ones_count == (LIMIT_ONES + 1))
                break;

            if (ones_count == LIMIT_ONES) {
                uint32_t mask;
                int cbits;

                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);

                if (cbits == 33)
                    break;

                if (cbits < 2)
                    ones_count = cbits;
                else {
                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)
                        if (getbit (bs))
                            ones_count |= mask;

                    ones_count |= mask;
                }

                ones_count += LIMIT_ONES;
            }
        }
        else {
            bs->bc -= ones_count + 1;
            bs->sr >>= ones_count + 1;
        }
#elif defined (USE_NEXT8_OPTIMIZATION)
        if (bs->bc < 8) {
            if (++(bs->ptr) == bs->end)
                bs->wrap (bs);

            next8 = (bs->sr |= *(bs->ptr) << bs->bc) & 0xff;
            bs->bc += sizeof (*(bs->ptr)) * 8;
        }
        else
            next8 = bs->sr & 0xff;

        if (next8 == 0xff) {
            bs->bc -= 8;
            bs->sr >>= 8;

            for (ones_count = 8; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);

            if (ones_count == (LIMIT_ONES + 1))
                break;

            if (ones_count == LIMIT_ONES) {
                uint32_t mask;
                int cbits;

                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);

                if (cbits == 33)
                    break;

                if (cbits < 2)
                    ones_count = cbits;
                else {
                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)
                        if (getbit (bs))
                            ones_count |= mask;

                    ones_count |= mask;
                }

                ones_count += LIMIT_ONES;
            }
        }
        else {
            bs->bc -= (ones_count = ones_count_table [next8]) + 1;
            bs->sr >>= ones_count + 1;
        }
#else
        for (ones_count = 0; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);

        if (ones_count >= LIMIT_ONES) {
            uint32_t mask;
            int cbits;

            if (ones_count == (LIMIT_ONES + 1))
                break;

            for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);

            if (cbits == 33)
                break;

            if (cbits < 2)
                ones_count = cbits;
            else {
                for (mask = 1, ones_count = 0; --cbits; mask <<= 1)
                    if (getbit (bs))
                        ones_count |= mask;

                ones_count |= mask;
            }

            ones_count += LIMIT_ONES;
        }
#endif

        low = wps->w.holding_one;
        wps->w.holding_one = ones_count & 1;
        wps->w.holding_zero = ~ones_count & 1;
        ones_count = (ones_count >> 1) + low;

        if (ones_count == 0) {
            low = 0;
            high = GET_MED (0) - 1;
            DEC_MED0 ();
        }
        else {
            low = GET_MED (0);
            INC_MED0 ();

            if (ones_count == 1) {
                high = low + GET_MED (1) - 1;
                DEC_MED1 ();
            }
            else {
                low += GET_MED (1);
                INC_MED1 ();

                if (ones_count == 2) {
                    high = low + GET_MED (2) - 1;
                    DEC_MED2 ();
                }
                else {
                    low += (ones_count - 2) * GET_MED (2);
                    high = low + GET_MED (2) - 1;
                    INC_MED2 ();
                }
            }
        }

        low += read_code (bs, high - low);
        buffer [csamples] = (getbit (bs)) ? ~low : low;
    }

    return (wps->wphdr.flags & MONO_DATA) ? csamples : (csamples / 2);
}

// Read a single unsigned value from the specified bitstream with a value
// from 0 to maxcode. If there are exactly a power of two number of possible
// codes then this will read a fixed number of bits; otherwise it reads the
// minimum number of bits and then determines whether another bit is needed
// to define the code.

static uint32_t __inline read_code (Bitstream *bs, uint32_t maxcode)
{
    unsigned long local_sr;
    uint32_t extras, code;
    int bitcount;

    if (maxcode < 2)
        return maxcode ? getbit (bs) : 0;

    bitcount = count_bits (maxcode);
#if USE_BITMASK_TABLES
    extras = bitset [bitcount] - maxcode - 1;
#else
    extras = (1 << bitcount) - maxcode - 1;
#endif

    local_sr = bs->sr;

    while (bs->bc < bitcount) {
        if (++(bs->ptr) == bs->end)
            bs->wrap (bs);

        local_sr |= (long)*(bs->ptr) << bs->bc;
        bs->bc += sizeof (*(bs->ptr)) * 8;
    }

#if USE_BITMASK_TABLES
    if ((code = local_sr & bitmask [bitcount - 1]) >= extras)
#else
    if ((code = local_sr & ((1 << (bitcount - 1)) - 1)) >= extras)
#endif
        code = (code << 1) - extras + ((local_sr >> (bitcount - 1)) & 1);
    else
        bitcount--;

    if (sizeof (local_sr) < 8 && bs->bc > sizeof (local_sr) * 8) {
        bs->bc -= bitcount;
        bs->sr = *(bs->ptr) >> (sizeof (*(bs->ptr)) * 8 - bs->bc);
    }
    else {
        bs->bc -= bitcount;
        bs->sr = local_sr >> bitcount;
    }

    return code;
}


static int get_ape_tag_item (M_Tag *m_tag, const char *item, char *value, int size, int type);
static int get_id3_tag_item (M_Tag *m_tag, const char *item, char *value, int size);
static int get_ape_tag_item_indexed (M_Tag *m_tag, int index, char *item, int size, int type);
static int get_id3_tag_item_indexed (M_Tag *m_tag, int index, char *item, int size);
static int append_ape_tag_item (WavpackContext *wpc, const char *item, const char *value, int vsize, int type);
static int write_tag_blockout (WavpackContext *wpc);
static int write_tag_reader (WavpackContext *wpc);
static void tagcpy (char *dest, char *src, int tag_size);
static int tagdata (char *src, int tag_size);


int WavpackGetNumTagItems (WavpackContext *wpc)
{
    int i = 0;

    while (WavpackGetTagItemIndexed (wpc, i, nullptr, 0))
        ++i;

    return i;
}

int WavpackGetNumBinaryTagItems (WavpackContext *wpc)
{
    int i = 0;

    while (WavpackGetBinaryTagItemIndexed (wpc, i, nullptr, 0))
        ++i;

    return i;
}

int WavpackGetTagItem (WavpackContext *wpc, const char *item, char *value, int size)
{
    M_Tag *m_tag = &wpc->m_tag;

    if (value && size)
        *value = 0;

    if (m_tag->ape_tag_hdr.ID [0] == 'A')
        return get_ape_tag_item (m_tag, item, value, size, APE_TAG_TYPE_TEXT);
    else if (m_tag->id3_tag.tag_id [0] == 'T')
        return get_id3_tag_item (m_tag, item, value, size);
    else
        return 0;
}

int WavpackGetBinaryTagItem (WavpackContext *wpc, const char *item, char *value, int size)
{
    M_Tag *m_tag = &wpc->m_tag;

    if (value && size)
        *value = 0;

    if (m_tag->ape_tag_hdr.ID [0] == 'A')
        return get_ape_tag_item (m_tag, item, value, size, APE_TAG_TYPE_BINARY);
    else
        return 0;
}

int WavpackGetTagItemIndexed (WavpackContext *wpc, int index, char *item, int size)
{
    M_Tag *m_tag = &wpc->m_tag;

    if (item && size)
        *item = 0;

    if (m_tag->ape_tag_hdr.ID [0] == 'A')
        return get_ape_tag_item_indexed (m_tag, index, item, size, APE_TAG_TYPE_TEXT);
    else if (m_tag->id3_tag.tag_id [0] == 'T')
        return get_id3_tag_item_indexed (m_tag, index, item, size);
    else
        return 0;
}

int WavpackGetBinaryTagItemIndexed (WavpackContext *wpc, int index, char *item, int size)
{
    M_Tag *m_tag = &wpc->m_tag;

    if (item && size)
        *item = 0;

    if (m_tag->ape_tag_hdr.ID [0] == 'A')
        return get_ape_tag_item_indexed (m_tag, index, item, size, APE_TAG_TYPE_BINARY);
    else
        return 0;
}

int WavpackAppendTagItem (WavpackContext *wpc, const char *item, const char *value, int vsize)
{
    while (WavpackDeleteTagItem (wpc, item));
    return append_ape_tag_item (wpc, item, value, vsize, APE_TAG_TYPE_TEXT);
}

int WavpackAppendBinaryTagItem (WavpackContext *wpc, const char *item, const char *value, int vsize)
{
    while (WavpackDeleteTagItem (wpc, item));
    return append_ape_tag_item (wpc, item, value, vsize, APE_TAG_TYPE_BINARY);
}

int WavpackDeleteTagItem (WavpackContext *wpc, const char *item)
{
    M_Tag *m_tag = &wpc->m_tag;

    if (m_tag->ape_tag_hdr.ID [0] == 'A') {
        uint8_t *p = m_tag->ape_tag_data;
        uint8_t *q = p + m_tag->ape_tag_hdr.length - sizeof (APE_Tag_Hdr);
        int i;

        for (i = 0; i < m_tag->ape_tag_hdr.item_count && q - p > 8; ++i) {
            int vsize, isize;

            vsize = p[0] + (p[1] << 8) + (p[2] << 16) + ((uint32_t) p[3] << 24); p += 8;   // skip flags because we don't need them
            for (isize = 0; p + isize < q && p[isize]; ++isize);

            if (vsize < 0 || vsize > m_tag->ape_tag_hdr.length || p + isize + vsize + 1 > q)
                break;

            if (isize && vsize && !stricmp (item, (char *) p)) {
                uint8_t *d = p - 8;

                p += isize + vsize + 1;

                while (p < q)
                    *d++ = *p++;

                m_tag->ape_tag_hdr.length = (int32_t)(d - m_tag->ape_tag_data) + sizeof (APE_Tag_Hdr);
                m_tag->ape_tag_hdr.item_count--;
                return 1;
            }
            else
                p += isize + vsize + 1;
        }
    }

    return 0;
}

int WavpackWriteTag (WavpackContext *wpc)
{
    if (wpc->blockout)      // this is the case for creating fresh WavPack files
        return write_tag_blockout (wpc);
    else                    // otherwise we are editing existing tags (OPEN_EDIT_TAGS)
        return write_tag_reader (wpc);
}

static int get_ape_tag_item (M_Tag *m_tag, const char *item, char *value, int size, int type)
{
    uint8_t *p = m_tag->ape_tag_data;
    uint8_t *q = p + m_tag->ape_tag_hdr.length - sizeof (APE_Tag_Hdr);
    int i;

    for (i = 0; i < m_tag->ape_tag_hdr.item_count && q - p > 8; ++i) {
        int vsize, flags, isize;

        vsize = p[0] + (p[1] << 8) + (p[2] << 16) + ((uint32_t) p[3] << 24); p += 4;
        flags = p[0] + (p[1] << 8) + (p[2] << 16) + ((uint32_t) p[3] << 24); p += 4;
        for (isize = 0; p + isize < q && p[isize]; ++isize);

        if (vsize < 0 || vsize > m_tag->ape_tag_hdr.length || p + isize + vsize + 1 > q)
            break;

        if (isize && vsize && !stricmp (item, (char *) p) && ((flags & 6) >> 1) == type) {

            if (!value || !size)
                return vsize;

            if (type == APE_TAG_TYPE_BINARY) {
                if (vsize <= size) {
                    memcpy (value, p + isize + 1, vsize);
                    return vsize;
                }
                else
                    return 0;
            }
            else if (vsize < size) {
                memcpy (value, p + isize + 1, vsize);
                value [vsize] = 0;
                return vsize;
            }
            else if (size >= 4) {
                memcpy (value, p + isize + 1, size - 1);
                value [size - 4] = value [size - 3] = value [size - 2] = '.';
                value [size - 1] = 0;
                return size - 1;
            }
            else
                return 0;
        }
        else
            p += isize + vsize + 1;
    }

    return 0;
}

static int get_id3_tag_item (M_Tag *m_tag, const char *item, char *value, int size)
{
    char lvalue [64];
    int len;

    lvalue [0] = 0;

    if (!stricmp (item, "title"))
        tagcpy (lvalue, m_tag->id3_tag.title, sizeof (m_tag->id3_tag.title));
    else if (!stricmp (item, "artist"))
        tagcpy (lvalue, m_tag->id3_tag.artist, sizeof (m_tag->id3_tag.artist));
    else if (!stricmp (item, "album"))
        tagcpy (lvalue, m_tag->id3_tag.album, sizeof (m_tag->id3_tag.album));
    else if (!stricmp (item, "year"))
        tagcpy (lvalue, m_tag->id3_tag.year, sizeof (m_tag->id3_tag.year));
    else if (!stricmp (item, "comment"))
        tagcpy (lvalue, m_tag->id3_tag.comment, sizeof (m_tag->id3_tag.comment));
    else if (!stricmp (item, "track") && m_tag->id3_tag.comment [29] && !m_tag->id3_tag.comment [28])
        sprintf (lvalue, "%d", m_tag->id3_tag.comment [29]);
    else
        return 0;

    len = (int) strlen (lvalue);

    if (!value || !size)
        return len;

    if (len < size) {
        strcpy (value, lvalue);
        return len;
    }
    else if (size >= 4) {
        strncpy (value, lvalue, size - 1);
        value [size - 4] = value [size - 3] = value [size - 2] = '.';
        value [size - 1] = 0;
        return size - 1;
    }
    else
        return 0;
}

static int get_ape_tag_item_indexed (M_Tag *m_tag, int index, char *item, int size, int type)
{
    uint8_t *p = m_tag->ape_tag_data;
    uint8_t *q = p + m_tag->ape_tag_hdr.length - sizeof (APE_Tag_Hdr);
    int i;

    for (i = 0; i < m_tag->ape_tag_hdr.item_count && index >= 0 && q - p > 8; ++i) {
        int vsize, flags, isize;

        vsize = p[0] + (p[1] << 8) + (p[2] << 16) + ((uint32_t) p[3] << 24); p += 4;
        flags = p[0] + (p[1] << 8) + (p[2] << 16) + ((uint32_t) p[3] << 24); p += 4;
        for (isize = 0; p + isize < q && p[isize]; ++isize);

        if (vsize < 0 || vsize > m_tag->ape_tag_hdr.length || p + isize + vsize + 1 > q)
            break;

        if (isize && vsize && ((flags & 6) >> 1) == type && !index--) {

            if (!item || !size)
                return isize;

            if (isize < size) {
                memcpy (item, p, isize);
                item [isize] = 0;
                return isize;
            }
            else if (size >= 4) {
                memcpy (item, p, size - 1);
                item [size - 4] = item [size - 3] = item [size - 2] = '.';
                item [size - 1] = 0;
                return size - 1;
            }
            else
                return 0;
        }
        else
            p += isize + vsize + 1;
    }

    return 0;
}

static int get_id3_tag_item_indexed (M_Tag *m_tag, int index, char *item, int size)
{
    char lvalue [16];
    int len;

    lvalue [0] = 0;

    if (tagdata (m_tag->id3_tag.title, sizeof (m_tag->id3_tag.title)) && !index--)
        strcpy (lvalue, "Title");
    else if (tagdata (m_tag->id3_tag.artist, sizeof (m_tag->id3_tag.artist)) && !index--)
        strcpy (lvalue, "Artist");
    else if (tagdata (m_tag->id3_tag.album, sizeof (m_tag->id3_tag.album)) && !index--)
        strcpy (lvalue, "Album");
    else if (tagdata (m_tag->id3_tag.year, sizeof (m_tag->id3_tag.year)) && !index--)
        strcpy (lvalue, "Year");
    else if (tagdata (m_tag->id3_tag.comment, sizeof (m_tag->id3_tag.comment)) && !index--)
        strcpy (lvalue, "Comment");
    else if (m_tag->id3_tag.comment [29] && !m_tag->id3_tag.comment [28] && !index--)
        strcpy (lvalue, "Track");
    else
        return 0;

    len = (int) strlen (lvalue);

    if (!item || !size)
        return len;

    if (len < size) {
        strcpy (item, lvalue);
        return len;
    }
    else if (size >= 4) {
        strncpy (item, lvalue, size - 1);
        item [size - 4] = item [size - 3] = item [size - 2] = '.';
        item [size - 1] = 0;
        return size - 1;
    }
    else
        return 0;
}

static int append_ape_tag_item (WavpackContext *wpc, const char *item, const char *value, int vsize, int type)
{
    M_Tag *m_tag = &wpc->m_tag;
    int isize = (int) strlen (item);

    if (!m_tag->ape_tag_hdr.ID [0]) {
        memcpy (m_tag->ape_tag_hdr.ID, "APETAGEX", sizeof (m_tag->ape_tag_hdr.ID));
        m_tag->ape_tag_hdr.version = 2000;
        m_tag->ape_tag_hdr.length = sizeof (m_tag->ape_tag_hdr);
        m_tag->ape_tag_hdr.item_count = 0;
        m_tag->ape_tag_hdr.flags = APE_TAG_CONTAINS_HEADER;  // we will include header on tags we originate
    }

    if (m_tag->ape_tag_hdr.ID [0] == 'A') {
        int new_item_len = vsize + isize + 9, flags = type << 1;
        uint8_t *p;

        if (m_tag->ape_tag_hdr.length + new_item_len > APE_TAG_MAX_LENGTH) {
            strcpy (wpc->error_message, "APEv2 tag exceeds maximum allowed length!");
            return false;
        }

        m_tag->ape_tag_hdr.item_count++;
        m_tag->ape_tag_hdr.length += new_item_len;
        p = m_tag->ape_tag_data = (uint8_t*)realloc (m_tag->ape_tag_data, m_tag->ape_tag_hdr.length);
        p += m_tag->ape_tag_hdr.length - sizeof (APE_Tag_Hdr) - new_item_len;

        *p++ = (uint8_t) vsize;
        *p++ = (uint8_t) (vsize >> 8);
        *p++ = (uint8_t) (vsize >> 16);
        *p++ = (uint8_t) (vsize >> 24);

        *p++ = (uint8_t) flags;
        *p++ = (uint8_t) (flags >> 8);
        *p++ = (uint8_t) (flags >> 16);
        *p++ = (uint8_t) (flags >> 24);

        strcpy ((char *) p, item);
        p += isize + 1;
        memcpy (p, value, vsize);

        return true;
    }

    return false;
}

// Append the stored APEv2 tag to the file being created using the "blockout" function callback.
static int write_tag_blockout (WavpackContext *wpc)
{
    M_Tag *m_tag = &wpc->m_tag;
    int result = true;

    if (m_tag->ape_tag_hdr.ID [0] == 'A' && m_tag->ape_tag_hdr.item_count) {

        // only write header if it's specified in the flags

        if (m_tag->ape_tag_hdr.flags & APE_TAG_CONTAINS_HEADER) {
            m_tag->ape_tag_hdr.flags |= APE_TAG_THIS_IS_HEADER;
            WavpackNativeToLittleEndian (&m_tag->ape_tag_hdr, APE_Tag_Hdr_Format);
            result = wpc->blockout (wpc->wv_out, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr));
            WavpackLittleEndianToNative (&m_tag->ape_tag_hdr, APE_Tag_Hdr_Format);
        }

        if (m_tag->ape_tag_hdr.length > sizeof (m_tag->ape_tag_hdr))
            result = wpc->blockout (wpc->wv_out, m_tag->ape_tag_data, m_tag->ape_tag_hdr.length - sizeof (m_tag->ape_tag_hdr));

        m_tag->ape_tag_hdr.flags &= ~APE_TAG_THIS_IS_HEADER;    // this is NOT header
        WavpackNativeToLittleEndian (&m_tag->ape_tag_hdr, APE_Tag_Hdr_Format);
        result = wpc->blockout (wpc->wv_out, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr));
        WavpackLittleEndianToNative (&m_tag->ape_tag_hdr, APE_Tag_Hdr_Format);
    }

    if (!result)
        strcpy (wpc->error_message, "can't write WavPack data, disk probably full!");

    return result;
}

// Write the [potentially] edited tag to the existing WavPack file using the reader callback functions.
static int write_tag_reader (WavpackContext *wpc)
{
    M_Tag *m_tag = &wpc->m_tag;
    int32_t tag_size = 0;
    int result;

    // before we write an edited (or new) tag into an existing file, make sure it's safe and possible

    if (m_tag->tag_begins_file) {
        strcpy (wpc->error_message, "can't edit tags located at the beginning of files!");
        return false;
    }

    if (!wpc->reader->can_seek (wpc->wv_in)) {
        strcpy (wpc->error_message, "can't edit tags on pipes or unseekable files!");
        return false;
    }

    if (!(wpc->open_flags & OPEN_EDIT_TAGS)) {
        strcpy (wpc->error_message, "can't edit tags without OPEN_EDIT_TAGS flag!");
        return false;
    }

    if (m_tag->ape_tag_hdr.ID [0] == 'A' && m_tag->ape_tag_hdr.item_count &&
        m_tag->ape_tag_hdr.length > sizeof (m_tag->ape_tag_hdr))
            tag_size = m_tag->ape_tag_hdr.length;

    // only write header if it's specified in the flags

    if (tag_size && (m_tag->ape_tag_hdr.flags & APE_TAG_CONTAINS_HEADER))
        tag_size += sizeof (m_tag->ape_tag_hdr);

    result = !wpc->reader->set_pos_rel (wpc->wv_in, m_tag->tag_file_pos, SEEK_END);

    if (result && tag_size < -m_tag->tag_file_pos && !wpc->reader->truncate_here) {
        int nullcnt = (int) (-m_tag->tag_file_pos - tag_size);
        char zero [1] = { 0 };

        while (nullcnt--)
            wpc->reader->write_bytes (wpc->wv_in, &zero, 1);
    }

    if (result && tag_size) {
        if (m_tag->ape_tag_hdr.flags & APE_TAG_CONTAINS_HEADER) {
            m_tag->ape_tag_hdr.flags |= APE_TAG_THIS_IS_HEADER;
            WavpackNativeToLittleEndian (&m_tag->ape_tag_hdr, APE_Tag_Hdr_Format);
            result = (wpc->reader->write_bytes (wpc->wv_in, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr)) == sizeof (m_tag->ape_tag_hdr));
            WavpackLittleEndianToNative (&m_tag->ape_tag_hdr, APE_Tag_Hdr_Format);
        }

        result = (wpc->reader->write_bytes (wpc->wv_in, m_tag->ape_tag_data, m_tag->ape_tag_hdr.length - sizeof (m_tag->ape_tag_hdr)) == sizeof (m_tag->ape_tag_hdr));
        m_tag->ape_tag_hdr.flags &= ~APE_TAG_THIS_IS_HEADER;    // this is NOT header
        WavpackNativeToLittleEndian (&m_tag->ape_tag_hdr, APE_Tag_Hdr_Format);
        result = (wpc->reader->write_bytes (wpc->wv_in, &m_tag->ape_tag_hdr, sizeof (m_tag->ape_tag_hdr)) == sizeof (m_tag->ape_tag_hdr));
        WavpackLittleEndianToNative (&m_tag->ape_tag_hdr, APE_Tag_Hdr_Format);
    }

    if (result && tag_size < -m_tag->tag_file_pos && wpc->reader->truncate_here)
        result = !wpc->reader->truncate_here (wpc->wv_in);

    if (!result)
        strcpy (wpc->error_message, "can't write WavPack data, disk probably full!");

    return result;
}

// Copy the specified ID3v1 tag value (with specified field size) from the
// source pointer to the destination, eliminating leading spaces and trailing
// spaces and nulls.
static void tagcpy (char *dest, char *src, int tag_size)
{
    char *s1 = src, *s2 = src + tag_size - 1;

    if (*s2 && !s2 [-1])
        s2--;

    while (s1 <= s2)
        if (*s1 == ' ')
            ++s1;
        else if (!*s2 || *s2 == ' ')
            --s2;
        else
            break;

    while (*s1 && s1 <= s2)
        *dest++ = *s1++;

    *dest = 0;
}

static int tagdata (char *src, int tag_size)
{
    char *s1 = src, *s2 = src + tag_size - 1;

    if (*s2 && !s2 [-1])
        s2--;

    while (s1 <= s2)
        if (*s1 == ' ')
            ++s1;
        else if (!*s2 || *s2 == ' ')
            --s2;
        else
            break;

    return (*s1 && s1 <= s2);
}


#if ENABLE_DSD

// This function initializes the main range-encoded data for DSD audio samples
static int init_dsd_block_fast (WavpackStream *wps, WavpackMetadata *wpmd);
static int init_dsd_block_high (WavpackStream *wps, WavpackMetadata *wpmd);
static int decode_fast (WavpackStream *wps, int32_t *output, int sample_count);
static int decode_high (WavpackStream *wps, int32_t *output, int sample_count);

int init_dsd_block (WavpackContext *wpc, WavpackMetadata *wpmd)
{
    WavpackStream *wps = wpc->streams [wpc->current_stream];

    if (wpmd->byte_length < 2)
        return false;

    wps->dsd.byteptr = (uint8_t *)wpmd->data;
    wps->dsd.endptr = wps->dsd.byteptr + wpmd->byte_length;

    if (*wps->dsd.byteptr > 31)
        return false;

    wpc->dsd_multiplier = 1U << *wps->dsd.byteptr++;
    wps->dsd.mode = *wps->dsd.byteptr++;

    if (!wps->dsd.mode) {
        if (wps->dsd.endptr - wps->dsd.byteptr != wps->wphdr.block_samples * (wps->wphdr.flags & MONO_DATA ? 1 : 2)) {
            return false;
        }

        wps->dsd.ready = 1;
        return true;
    }

    if (wps->dsd.mode == 1)
        return init_dsd_block_fast (wps, wpmd);
    else if (wps->dsd.mode == 3)
        return init_dsd_block_high (wps, wpmd);
    else
        return false;
}

int32_t unpack_dsd_samples (WavpackContext *wpc, int32_t *buffer, uint32_t sample_count)
{
    WavpackStream *wps = wpc->streams [wpc->current_stream];
    uint32_t flags = wps->wphdr.flags;

    // don't attempt to decode past the end of the block, but watch out for overflow!

    if (wps->sample_index + sample_count > GET_BLOCK_INDEX (wps->wphdr) + wps->wphdr.block_samples &&
        (uint32_t) (GET_BLOCK_INDEX (wps->wphdr) + wps->wphdr.block_samples - wps->sample_index) < sample_count)
            sample_count = (uint32_t) (GET_BLOCK_INDEX (wps->wphdr) + wps->wphdr.block_samples - wps->sample_index);

    if (GET_BLOCK_INDEX (wps->wphdr) > wps->sample_index || wps->wphdr.block_samples < sample_count)
        wps->mute_error = true;

    if (!wps->mute_error) {
        if (!wps->dsd.mode) {
            int total_samples = sample_count * ((flags & MONO_DATA) ? 1 : 2);
            int32_t *bptr = buffer;

            if (wps->dsd.endptr - wps->dsd.byteptr < total_samples)
                total_samples = (int)(wps->dsd.endptr - wps->dsd.byteptr);

            while (total_samples--)
                wps->crc += (wps->crc << 1) + (*bptr++ = *wps->dsd.byteptr++);
        }
        else if (wps->dsd.mode == 1) {
            if (!decode_fast (wps, buffer, sample_count))
                wps->mute_error = true;
        }
        else if (!decode_high (wps, buffer, sample_count))
            wps->mute_error = true;
    }

    if (wps->mute_error) {
        int samples_to_null;
        if (wpc->reduced_channels == 1 || wpc->config.num_channels == 1 || (flags & MONO_FLAG))
            samples_to_null = sample_count;
        else
            samples_to_null = sample_count * 2;

        while (samples_to_null--)
            *buffer++ = 0x55;

        wps->sample_index += sample_count;
        return sample_count;
    }

    if (flags & FALSE_STEREO) {
        int32_t *dptr = buffer + sample_count * 2;
        int32_t *sptr = buffer + sample_count;
        int32_t c = sample_count;

        while (c--) {
            *--dptr = *--sptr;
            *--dptr = *sptr;
        }
    }

    wps->sample_index += sample_count;

    return sample_count;
}

/*------------------------------------------------------------------------------------------------------------------------*/

// #define DSD_BYTE_READY(low,high) (((low) >> 24) == ((high) >> 24))
// #define DSD_BYTE_READY(low,high) (!(((low) ^ (high)) >> 24))
#define DSD_BYTE_READY(low,high) (!(((low) ^ (high)) & 0xff000000))

static int init_dsd_block_fast (WavpackStream *wps, WavpackMetadata *wpmd)
{
    uint8_t history_bits, max_probability, *lb_ptr;
    int total_summed_probabilities = 0, bi, i;

    if (wps->dsd.byteptr == wps->dsd.endptr)
        return false;

    history_bits = *wps->dsd.byteptr++;

    if (wps->dsd.byteptr == wps->dsd.endptr || history_bits > MAX_HISTORY_BITS)
        return false;

    wps->dsd.history_bins = 1 << history_bits;

    free_dsd_tables (wps);
    lb_ptr = wps->dsd.lookup_buffer = (uint8_t *)malloc (wps->dsd.history_bins * MAX_BYTES_PER_BIN);
    wps->dsd.value_lookup = (uint8_t **)malloc (sizeof (*wps->dsd.value_lookup) * wps->dsd.history_bins);
    memset (wps->dsd.value_lookup, 0, sizeof (*wps->dsd.value_lookup) * wps->dsd.history_bins);
    wps->dsd.summed_probabilities = (uint16_t (*)[256])malloc (sizeof (*wps->dsd.summed_probabilities) * wps->dsd.history_bins);
    wps->dsd.probabilities = (uint8_t (*)[256])malloc (sizeof (*wps->dsd.probabilities) * wps->dsd.history_bins);

    max_probability = *wps->dsd.byteptr++;

    if (max_probability < 0xff) {
        uint8_t *outptr = (uint8_t *) wps->dsd.probabilities;
        uint8_t *outend = outptr + sizeof (*wps->dsd.probabilities) * wps->dsd.history_bins;

        while (outptr < outend && wps->dsd.byteptr < wps->dsd.endptr) {
            int code = *wps->dsd.byteptr++;

            if (code > max_probability) {
                int zcount = code - max_probability;

                while (outptr < outend && zcount--)
                    *outptr++ = 0;
            }
            else if (code)
                *outptr++ = code;
            else
                break;
        }

        if (outptr < outend || (wps->dsd.byteptr < wps->dsd.endptr && *wps->dsd.byteptr++))
            return false;
    }
    else if (wps->dsd.endptr - wps->dsd.byteptr > (int) sizeof (*wps->dsd.probabilities) * wps->dsd.history_bins) {
        memcpy (wps->dsd.probabilities, wps->dsd.byteptr, sizeof (*wps->dsd.probabilities) * wps->dsd.history_bins);
        wps->dsd.byteptr += sizeof (*wps->dsd.probabilities) * wps->dsd.history_bins;
    }
    else
        return false;

    for (bi = 0; bi < wps->dsd.history_bins; ++bi) {
        int32_t sum_values;

        for (sum_values = i = 0; i < 256; ++i)
            wps->dsd.summed_probabilities [bi] [i] = sum_values += wps->dsd.probabilities [bi] [i];

        if (sum_values) {
            if ((total_summed_probabilities += sum_values) > wps->dsd.history_bins * MAX_BYTES_PER_BIN)
                return false;

            wps->dsd.value_lookup [bi] = lb_ptr;

            for (i = 0; i < 256; i++) {
                int c = wps->dsd.probabilities [bi] [i];

                while (c--)
                    *lb_ptr++ = i;
            }
        }
    }

    if (wps->dsd.endptr - wps->dsd.byteptr < 4 || total_summed_probabilities > wps->dsd.history_bins * MAX_BYTES_PER_BIN)
        return false;

    for (i = 4; i--;)
        wps->dsd.value = (wps->dsd.value << 8) | *wps->dsd.byteptr++;

    wps->dsd.p0 = wps->dsd.p1 = 0;
    wps->dsd.low = 0; wps->dsd.high = 0xffffffff;
    wps->dsd.ready = 1;

    return true;
}

static int decode_fast (WavpackStream *wps, int32_t *output, int sample_count)
{
    int total_samples = sample_count;

    if (!(wps->wphdr.flags & MONO_DATA))
        total_samples *= 2;

    while (total_samples--) {
        unsigned int mult, index, code, i;

        if (!wps->dsd.summed_probabilities [wps->dsd.p0] [255])
            return 0;

        mult = (wps->dsd.high - wps->dsd.low) / wps->dsd.summed_probabilities [wps->dsd.p0] [255];

        if (!mult) {
            if (wps->dsd.endptr - wps->dsd.byteptr >= 4)
                for (i = 4; i--;)
                    wps->dsd.value = (wps->dsd.value << 8) | *wps->dsd.byteptr++;

            wps->dsd.low = 0;
            wps->dsd.high = 0xffffffff;
            mult = wps->dsd.high / wps->dsd.summed_probabilities [wps->dsd.p0] [255];

            if (!mult)
                return 0;
        }

        index = (wps->dsd.value - wps->dsd.low) / mult;

        if (index >= wps->dsd.summed_probabilities [wps->dsd.p0] [255])
            return 0;

        if ((*output++ = code = wps->dsd.value_lookup [wps->dsd.p0] [index]))
            wps->dsd.low += wps->dsd.summed_probabilities [wps->dsd.p0] [code-1] * mult;

        wps->dsd.high = wps->dsd.low + wps->dsd.probabilities [wps->dsd.p0] [code] * mult - 1;
        wps->crc += (wps->crc << 1) + code;

        if (wps->wphdr.flags & MONO_DATA)
            wps->dsd.p0 = code & (wps->dsd.history_bins-1);
        else {
            wps->dsd.p0 = wps->dsd.p1;
            wps->dsd.p1 = code & (wps->dsd.history_bins-1);
        }

        while (DSD_BYTE_READY (wps->dsd.high, wps->dsd.low) && wps->dsd.byteptr < wps->dsd.endptr) {
            wps->dsd.value = (wps->dsd.value << 8) | *wps->dsd.byteptr++;
            wps->dsd.high = (wps->dsd.high << 8) | 0xff;
            wps->dsd.low <<= 8;
        }
    }

    return sample_count;
}

/*------------------------------------------------------------------------------------------------------------------------*/

#define PTABLE_BITS 8
#define PTABLE_BINS (1<<PTABLE_BITS)
#define PTABLE_MASK (PTABLE_BINS-1)

#define UP   0x010000fe
#define DOWN 0x00010000
#define DECAY 8

#define PRECISION 20
#define VALUE_ONE (1 << PRECISION)
#define PRECISION_USE 12

#define RATE_S 20

static void init_ptable (int *table, int rate_i, int rate_s)
{
    int value = 0x808000, rate = rate_i << 8, c, i;

    for (c = (rate + 128) >> 8; c--;)
        value += (DOWN - value) >> DECAY;

    for (i = 0; i < PTABLE_BINS/2; ++i) {
        table [i] = value;
        table [PTABLE_BINS-1-i] = 0x100ffff - value;

        if (value > 0x010000) {
            rate += (rate * rate_s + 128) >> 8;

            for (c = (rate + 64) >> 7; c--;)
                value += (DOWN - value) >> DECAY;
        }
    }
}

static int init_dsd_block_high (WavpackStream *wps, WavpackMetadata *wpmd)
{
    uint32_t flags = wps->wphdr.flags;
    int channel, rate_i, rate_s, i;

    if (wps->dsd.endptr - wps->dsd.byteptr < ((flags & MONO_DATA) ? 13 : 20))
        return false;

    rate_i = *wps->dsd.byteptr++;
    rate_s = *wps->dsd.byteptr++;

    if (rate_s != RATE_S)
        return false;

    if (!wps->dsd.ptable)
        wps->dsd.ptable = (int32_t *)malloc (PTABLE_BINS * sizeof (*wps->dsd.ptable));

    init_ptable (wps->dsd.ptable, rate_i, rate_s);

    for (channel = 0; channel < ((flags & MONO_DATA) ? 1 : 2); ++channel) {
        DSDfilters *sp = wps->dsd.filters + channel;

        sp->filter1 = *wps->dsd.byteptr++ << (PRECISION - 8);
        sp->filter2 = *wps->dsd.byteptr++ << (PRECISION - 8);
        sp->filter3 = *wps->dsd.byteptr++ << (PRECISION - 8);
        sp->filter4 = *wps->dsd.byteptr++ << (PRECISION - 8);
        sp->filter5 = *wps->dsd.byteptr++ << (PRECISION - 8);
        sp->filter6 = 0;
        sp->factor = *wps->dsd.byteptr++ & 0xff;
        sp->factor |= (*wps->dsd.byteptr++ << 8) & 0xff00;
        sp->factor = (int32_t)((uint32_t)sp->factor << 16) >> 16;
    }

    wps->dsd.high = 0xffffffff;
    wps->dsd.low = 0x0;

    for (i = 4; i--;)
        wps->dsd.value = (wps->dsd.value << 8) | *wps->dsd.byteptr++;

    wps->dsd.ready = 1;

    return true;
}

static int decode_high (WavpackStream *wps, int32_t *output, int sample_count)
{
    int total_samples = sample_count, stereo = (wps->wphdr.flags & MONO_DATA) ? 0 : 1;
    DSDfilters *sp = wps->dsd.filters;

    while (total_samples--) {
        int bitcount = 8;

        sp [0].value = sp [0].filter1 - sp [0].filter5 + ((sp [0].filter6 * sp [0].factor) >> 2);

        if (stereo)
            sp [1].value = sp [1].filter1 - sp [1].filter5 + ((sp [1].filter6 * sp [1].factor) >> 2);

        while (bitcount--) {
            int32_t *pp = wps->dsd.ptable + ((sp [0].value >> (PRECISION - PRECISION_USE)) & PTABLE_MASK);
            uint32_t split = wps->dsd.low + ((wps->dsd.high - wps->dsd.low) >> 8) * (*pp >> 16);

            if (wps->dsd.value <= split) {
                wps->dsd.high = split;
                *pp += (UP - *pp) >> DECAY;
                sp [0].filter0 = -1;
            }
            else {
                wps->dsd.low = split + 1;
                *pp += (DOWN - *pp) >> DECAY;
                sp [0].filter0 = 0;
            }

            while (DSD_BYTE_READY (wps->dsd.high, wps->dsd.low) && wps->dsd.byteptr < wps->dsd.endptr) {
                wps->dsd.value = (wps->dsd.value << 8) | *wps->dsd.byteptr++;
                wps->dsd.high = (wps->dsd.high << 8) | 0xff;
                wps->dsd.low <<= 8;
            }

            sp [0].value += sp [0].filter6 * 8;
            sp [0].byte = (sp [0].byte << 1) | (sp [0].filter0 & 1);
            sp [0].factor += (((sp [0].value ^ sp [0].filter0) >> 31) | 1) & ((sp [0].value ^ (sp [0].value - (sp [0].filter6 * 16))) >> 31);
            sp [0].filter1 += ((sp [0].filter0 & VALUE_ONE) - sp [0].filter1) >> 6;
            sp [0].filter2 += ((sp [0].filter0 & VALUE_ONE) - sp [0].filter2) >> 4;
            sp [0].filter3 += (sp [0].filter2 - sp [0].filter3) >> 4;
            sp [0].filter4 += (sp [0].filter3 - sp [0].filter4) >> 4;
            sp [0].value = (sp [0].filter4 - sp [0].filter5) >> 4;
            sp [0].filter5 += sp [0].value;
            sp [0].filter6 += (sp [0].value - sp [0].filter6) >> 3;
            sp [0].value = sp [0].filter1 - sp [0].filter5 + ((sp [0].filter6 * sp [0].factor) >> 2);

            if (!stereo)
                continue;

            pp = wps->dsd.ptable + ((sp [1].value >> (PRECISION - PRECISION_USE)) & PTABLE_MASK);
            split = wps->dsd.low + ((wps->dsd.high - wps->dsd.low) >> 8) * (*pp >> 16);

            if (wps->dsd.value <= split) {
                wps->dsd.high = split;
                *pp += (UP - *pp) >> DECAY;
                sp [1].filter0 = -1;
            }
            else {
                wps->dsd.low = split + 1;
                *pp += (DOWN - *pp) >> DECAY;
                sp [1].filter0 = 0;
            }

            while (DSD_BYTE_READY (wps->dsd.high, wps->dsd.low) && wps->dsd.byteptr < wps->dsd.endptr) {
                wps->dsd.value = (wps->dsd.value << 8) | *wps->dsd.byteptr++;
                wps->dsd.high = (wps->dsd.high << 8) | 0xff;
                wps->dsd.low <<= 8;
            }

            sp [1].value += sp [1].filter6 * 8;
            sp [1].byte = (sp [1].byte << 1) | (sp [1].filter0 & 1);
            sp [1].factor += (((sp [1].value ^ sp [1].filter0) >> 31) | 1) & ((sp [1].value ^ (sp [1].value - (sp [1].filter6 * 16))) >> 31);
            sp [1].filter1 += ((sp [1].filter0 & VALUE_ONE) - sp [1].filter1) >> 6;
            sp [1].filter2 += ((sp [1].filter0 & VALUE_ONE) - sp [1].filter2) >> 4;
            sp [1].filter3 += (sp [1].filter2 - sp [1].filter3) >> 4;
            sp [1].filter4 += (sp [1].filter3 - sp [1].filter4) >> 4;
            sp [1].value = (sp [1].filter4 - sp [1].filter5) >> 4;
            sp [1].filter5 += sp [1].value;
            sp [1].filter6 += (sp [1].value - sp [1].filter6) >> 3;
            sp [1].value = sp [1].filter1 - sp [1].filter5 + ((sp [1].filter6 * sp [1].factor) >> 2);
        }

        wps->crc += (wps->crc << 1) + (*output++ = sp [0].byte & 0xff);
        sp [0].factor -= (sp [0].factor + 512) >> 10;

        if (stereo) {
            wps->crc += (wps->crc << 1) + (*output++ = wps->dsd.filters [1].byte & 0xff);
            wps->dsd.filters [1].factor -= (wps->dsd.filters [1].factor + 512) >> 10;
        }
    }

    return sample_count;
}

#if 0

// 80 term DSD decimation filter
// < 1 dB down at 20 kHz
// > 108 dB stopband attenuation (fs/16)

static const int32_t decm_filter [] = {
    4, 17, 56, 147, 336, 693, 1320, 2359,
    4003, 6502, 10170, 15392, 22623, 32389, 45275, 61920,
    82994, 109174, 141119, 179431, 224621, 277068, 336983, 404373,
    479004, 560384, 647741, 740025, 835917, 933849, 1032042, 1128551,
    1221329, 1308290, 1387386, 1456680, 1514425, 1559128, 1589610, 1605059,
    1605059, 1589610, 1559128, 1514425, 1456680, 1387386, 1308290, 1221329,
    1128551, 1032042, 933849, 835917, 740025, 647741, 560384, 479004,
    404373, 336983, 277068, 224621, 179431, 141119, 109174, 82994,
    61920, 45275, 32389, 22623, 15392, 10170, 6502, 4003,
    2359, 1320, 693, 336, 147, 56, 17, 4,
};

#define NUM_FILTER_TERMS 80

#else

// 56 term decimation filter
// < 0.5 dB down at 20 kHz
// > 100 dB stopband attenuation (fs/12)

static const int32_t decm_filter [] = {
    4, 17, 56, 147, 336, 692, 1315, 2337,
    3926, 6281, 9631, 14216, 20275, 28021, 37619, 49155,
    62616, 77870, 94649, 112551, 131049, 149507, 167220, 183448,
    197472, 208636, 216402, 220385, 220385, 216402, 208636, 197472,
    183448, 167220, 149507, 131049, 112551, 94649, 77870, 62616,
    49155, 37619, 28021, 20275, 14216, 9631, 6281, 3926,
    2337, 1315, 692, 336, 147, 56, 17, 4,
};

#define NUM_FILTER_TERMS 56

#endif

#define HISTORY_BYTES ((NUM_FILTER_TERMS+7)/8)

struct DecimationChannel {
    uint8_t delay [HISTORY_BYTES];
};

struct DecimationContext {
    int32_t conv_tables [HISTORY_BYTES] [256];
    DecimationChannel *chans;
    int num_channels;
};

void *decimate_dsd_init (int num_channels)
{
    DecimationContext *context = (DecimationContext *)malloc (sizeof (DecimationContext));
    double filter_sum = 0, filter_scale;
    int skipped_terms, i, j;

    if (!context)
        return context;

    memset (context, 0, sizeof (*context));
    context->num_channels = num_channels;
    context->chans = (DecimationChannel *)malloc (num_channels * sizeof (DecimationChannel));

    if (!context->chans) {
        free (context);
        return nullptr;
    }

    for (i = 0; i < NUM_FILTER_TERMS; ++i)
        filter_sum += decm_filter [i];

    filter_scale = ((1 << 23) - 1) / filter_sum * 16.0;
    // fprintf (stderr, "convolution, %d terms, %f sum, %f scale\n", NUM_FILTER_TERMS, filter_sum, filter_scale);

    for (skipped_terms = i = 0; i < NUM_FILTER_TERMS; ++i) {
        int scaled_term = (int) floor (decm_filter [i] * filter_scale + 0.5);

        if (scaled_term) {
            for (j = 0; j < 256; ++j)
                if (j & (0x80 >> (i & 0x7)))
                    context->conv_tables [i >> 3] [j] += scaled_term;
                else
                    context->conv_tables [i >> 3] [j] -= scaled_term;
        }
        else
            skipped_terms++;
    }

    // fprintf (stderr, "%d terms skipped\n", skipped_terms);

    decimate_dsd_reset (context);

    return context;
}

void decimate_dsd_reset (void *decimate_context)
{
    DecimationContext *context = (DecimationContext *) decimate_context;
    int chan = 0, i;

    if (!context)
        return;

    for (chan = 0; chan < context->num_channels; ++chan)
        for (i = 0; i < HISTORY_BYTES; ++i)
            context->chans [chan].delay [i] = 0x55;
}

void decimate_dsd_run (void *decimate_context, int32_t *samples, int num_samples)
{
    DecimationContext *context = (DecimationContext *) decimate_context;
    int chan = 0;

    if (!context)
        return;

    while (num_samples) {
        DecimationChannel *sp = context->chans + chan;
        int sum = 0;

#if (HISTORY_BYTES == 10)
        sum += context->conv_tables [0] [sp->delay [0] = sp->delay [1]];
        sum += context->conv_tables [1] [sp->delay [1] = sp->delay [2]];
        sum += context->conv_tables [2] [sp->delay [2] = sp->delay [3]];
        sum += context->conv_tables [3] [sp->delay [3] = sp->delay [4]];
        sum += context->conv_tables [4] [sp->delay [4] = sp->delay [5]];
        sum += context->conv_tables [5] [sp->delay [5] = sp->delay [6]];
        sum += context->conv_tables [6] [sp->delay [6] = sp->delay [7]];
        sum += context->conv_tables [7] [sp->delay [7] = sp->delay [8]];
        sum += context->conv_tables [8] [sp->delay [8] = sp->delay [9]];
        sum += context->conv_tables [9] [sp->delay [9] = *samples];
#elif (HISTORY_BYTES == 7)
        sum += context->conv_tables [0] [sp->delay [0] = sp->delay [1]];
        sum += context->conv_tables [1] [sp->delay [1] = sp->delay [2]];
        sum += context->conv_tables [2] [sp->delay [2] = sp->delay [3]];
        sum += context->conv_tables [3] [sp->delay [3] = sp->delay [4]];
        sum += context->conv_tables [4] [sp->delay [4] = sp->delay [5]];
        sum += context->conv_tables [5] [sp->delay [5] = sp->delay [6]];
        sum += context->conv_tables [6] [sp->delay [6] = *samples];
#else
        int i;

        for (i = 0; i < HISTORY_BYTES-1; ++i)
            sum += context->conv_tables [i] [sp->delay [i] = sp->delay [i+1]];

        sum += context->conv_tables [i] [sp->delay [i] = *samples];
#endif

        *samples++ = sum >> 4;

        if (++chan == context->num_channels) {
            num_samples--;
            chan = 0;
        }
    }
}

void decimate_dsd_destroy (void *decimate_context)
{
    DecimationContext *context = (DecimationContext *) decimate_context;

    if (!context)
        return;

    if (context->chans)
        free (context->chans);

    free (context);
}

#endif      // ENABLE_DSD


int scan_float_data (WavpackStream *wps, int32_t *values, int32_t num_values)
{
    int32_t shifted_ones = 0, shifted_zeros = 0, shifted_both = 0;
    int32_t false_zeros = 0, neg_zeros = 0;
#if DISPLAY_DIAGNOSTICS
    int32_t true_zeros = 0, denormals = 0, exceptions = 0;
#endif
    uint32_t ordata = 0, crc = 0xffffffff;
    int32_t count, value, shift_count;
    int max_mag = 0, max_exp = 0;
    int32_t *dp;

    wps->float_shift = wps->float_flags = 0;

    // First loop goes through all the data and (1) calculates the CRC and (2) finds the
    // max magnitude that does not have an exponent of 255 (reserved for +/-inf and NaN).
    for (dp = values, count = num_values; count--; dp++) {
        crc = crc * 27 + get_mantissa (*dp) * 9 + get_exponent (*dp) * 3 + get_sign (*dp);

        if (get_exponent (*dp) < 255 && get_magnitude (*dp) > max_mag)
            max_mag = get_magnitude (*dp);
    }

    wps->crc_x = crc;

    // round up the magnitude so that when we convert the floating-point values to integers,
    // they will be (at most) just over 24-bits signed precision
    if (get_exponent (max_mag))
        max_exp = get_exponent (max_mag + 0x7F0000);

    for (dp = values, count = num_values; count--; dp++) {
        // Exponent of 255 is reserved for +/-inf (mantissa = 0) or NaN (mantissa != 0).
        // we use a value one greater than 24-bits unsigned for this.
        if (get_exponent (*dp) == 255) {
#if DISPLAY_DIAGNOSTICS
            exceptions++;
#endif
            wps->float_flags |= FLOAT_EXCEPTIONS;
            value = 0x1000000;
            shift_count = 0;
        }
        // This is the regular case. We generate a 24-bit unsigned value with the implied
        // '1' MSB set and calculate a shift that will make it line up with the biggest
        // samples in this block (although that shift would obviously shift out real data).
        else if (get_exponent (*dp)) {
            shift_count = max_exp - get_exponent (*dp);
            value = 0x800000 + get_mantissa (*dp);
        }
        // Zero exponent means either +/- zero (mantissa = 0) or denormals (mantissa != 0).
        // shift_count is set so that denormals (without an implied '1') will line up with
        // regular values (with their implied '1' added at bit 23). Trust me. We don't care
        // about the shift with zero.
        else {
            shift_count = max_exp ? max_exp - 1 : 0;
            value = get_mantissa (*dp);

#if DISPLAY_DIAGNOSTICS
            if (get_mantissa (*dp))
                denormals++;
#endif
        }

        if (shift_count < 25)
            value >>= shift_count;      // perform the shift if there could be anything left
        else
            value = 0;                  // else just zero the value

        // If we are going to encode an integer zero, then this might be a "false zero" which
        // means that there are significant bits but they're completely shifted out, or a
        // "negative zero" which is simply a floating point value that we have to encode
        // (and converting it to a positive zero would be an error).
        if (!value) {
            if (get_exponent (*dp) || get_mantissa (*dp))
                ++false_zeros;
            else if (get_sign (*dp))
                ++neg_zeros;
#if DISPLAY_DIAGNOSTICS
            else
                ++true_zeros;
#endif
        }
        // If we are going to shift something (but not everything) out of our integer before
        // encoding, then we generate a mask corresponding to the bits that will be shifted
        // out and increment the counter for the 3 possible cases of (1) all zeros, (2) all
        // ones, and (3) a mix of ones and zeros.
        else if (shift_count) {
            int32_t mask = (1 << shift_count) - 1;

            if (!(get_mantissa (*dp) & mask))
                shifted_zeros++;
            else if ((get_mantissa (*dp) & mask) == mask)
                shifted_ones++;
            else
                shifted_both++;
        }

        // "or" all the integer values together, and store the final integer with applied sign

        ordata |= value;
        * (int32_t *) dp = (get_sign (*dp)) ? -value : value;
    }

    wps->float_max_exp = max_exp;   // on decode, we use this to calculate actual exponent

    // Now, based on our various counts, we determine the scheme required to encode the bits
    // shifted out. Usually these will simply have to be sent literally, but in some rare cases
    // we can get away with always assuming ones shifted out, or assuming all the bits shifted
    // out in each value are the same (which means we only have to send a single bit).
    if (shifted_both)
        wps->float_flags |= FLOAT_SHIFT_SENT;
    else if (shifted_ones && !shifted_zeros)
        wps->float_flags |= FLOAT_SHIFT_ONES;
    else if (shifted_ones && shifted_zeros)
        wps->float_flags |= FLOAT_SHIFT_SAME;
    // Another case is that we only shift out zeros (or maybe nothing), and in that case we
    // check to see if our data actually has less than 24 or 25 bits of resolution, which means
    // that we reduce can the magnitude of the integers we are encoding (which saves all those
    // bits). The number of bits of reduced resolution is stored in float_shift.
    else if (ordata && !(ordata & 1)) {
        while (!(ordata & 1)) {
            wps->float_shift++;
            ordata >>= 1;
        }

        // here we shift out all those zeros in the integer data we will encode
        for (dp = values, count = num_values; count--; dp++)
            * (int32_t *) dp >>= wps->float_shift;
    }

    // Here we calculate the actual magnitude used by our integer data, although this is just
    // used for informational purposes during encode/decode to possibly use faster math.

    wps->wphdr.flags &= ~MAG_MASK;

    while (ordata) {
        wps->wphdr.flags += 1 << MAG_LSB;
        ordata >>= 1;
    }

    // Finally, we have to set some flags that guide how we encode various types of "zeros".
    // If none of these are set (which is the most common situation), then every integer
    // zero in the decoded data will simply become a floating-point zero.

    if (false_zeros || neg_zeros)
        wps->float_flags |= FLOAT_ZEROS_SENT;

    if (neg_zeros)
        wps->float_flags |= FLOAT_NEG_ZEROS;

#if DISPLAY_DIAGNOSTICS
    {
        int32_t *ip, min = 0x7fffffff, max = 0x80000000;
        for (ip = (int32_t *) values, count = num_values; count--; ip++) {
            if (*ip < min) min = *ip;
            if (*ip > max) max = *ip;
        }

        fprintf (stderr, "integer range = %d to %d\n", min, max);
    }

    fprintf (stderr, "samples = %d, max exp = %d, pre-shift = %d, denormals = %d, exceptions = %d, max_mag = %x\n",
        num_values, max_exp, wps->float_shift, denormals, exceptions, max_mag);
    fprintf (stderr, "shifted ones/zeros/both = %d/%d/%d, true/neg/false zeros = %d/%d/%d\n",
        shifted_ones, shifted_zeros, shifted_both, true_zeros, neg_zeros, false_zeros);
#endif

    return wps->float_flags & (FLOAT_EXCEPTIONS | FLOAT_ZEROS_SENT | FLOAT_SHIFT_SENT | FLOAT_SHIFT_SAME);
}

void send_float_data (WavpackStream *wps, int32_t *values, int32_t num_values)
{
    int max_exp = wps->float_max_exp;
    int32_t count, value, shift_count;
    int32_t *dp;

    for (dp = values, count = num_values; count--; dp++) {
        if (get_exponent (*dp) == 255) {
            if (get_mantissa (*dp)) {
                putbit_1 (&wps->wvxbits);
                putbits (get_mantissa (*dp), 23, &wps->wvxbits);
            }
            else {
                putbit_0 (&wps->wvxbits);
            }

            value = 0x1000000;
            shift_count = 0;
        }
        else if (get_exponent (*dp)) {
            shift_count = max_exp - get_exponent (*dp);
            value = 0x800000 + get_mantissa (*dp);
        }
        else {
            shift_count = max_exp ? max_exp - 1 : 0;
            value = get_mantissa (*dp);
        }

        if (shift_count < 25)
            value >>= shift_count;
        else
            value = 0;

        if (!value) {
            if (wps->float_flags & FLOAT_ZEROS_SENT) {
                if (get_exponent (*dp) || get_mantissa (*dp)) {
                    putbit_1 (&wps->wvxbits);
                    putbits (get_mantissa (*dp), 23, &wps->wvxbits);

                    if (max_exp >= 25) {
                        putbits (get_exponent (*dp), 8, &wps->wvxbits);
                    }

                    putbit (get_sign (*dp), &wps->wvxbits);
                }
                else {
                    putbit_0 (&wps->wvxbits);

                    if (wps->float_flags & FLOAT_NEG_ZEROS)
                        putbit (get_sign (*dp), &wps->wvxbits);
                }
            }
        }
        else if (shift_count) {
            if (wps->float_flags & FLOAT_SHIFT_SENT) {
                int32_t data = get_mantissa (*dp) & ((1 << shift_count) - 1);
                putbits (data, shift_count, &wps->wvxbits);
            }
            else if (wps->float_flags & FLOAT_SHIFT_SAME) {
                putbit (get_mantissa (*dp) & 1, &wps->wvxbits);
            }
        }
    }
}



#if OPT_ASM_X86
    #define DECORR_STEREO_PASS_CONT unpack_decorr_stereo_pass_cont_x86
    #define DECORR_STEREO_PASS_CONT_AVAILABLE unpack_cpu_has_feature_x86(CPU_FEATURE_MMX)
    #define DECORR_MONO_PASS_CONT unpack_decorr_mono_pass_cont_x86
#elif defined(OPT_ASM_X64) && (defined (_WIN64) || defined(__CYGWIN__) || defined(__MINGW64__) || defined(__midipix__))
    #define DECORR_STEREO_PASS_CONT unpack_decorr_stereo_pass_cont_x64win
    #define DECORR_STEREO_PASS_CONT_AVAILABLE 1
    #define DECORR_MONO_PASS_CONT unpack_decorr_mono_pass_cont_x64win
#elif defined(OPT_ASM_X64)
    #define DECORR_STEREO_PASS_CONT unpack_decorr_stereo_pass_cont_x64
    #define DECORR_STEREO_PASS_CONT_AVAILABLE 1
    #define DECORR_MONO_PASS_CONT unpack_decorr_mono_pass_cont_x64
#elif defined(OPT_ASM_ARM)
    #define DECORR_STEREO_PASS_CONT unpack_decorr_stereo_pass_cont_armv7
    #define DECORR_STEREO_PASS_CONT_AVAILABLE 1
    #define DECORR_MONO_PASS_CONT unpack_decorr_mono_pass_cont_armv7
#endif

#if DECORR_STEREO_PASS_CONT
extern void DECORR_STEREO_PASS_CONT (struct decorr_pass *dpp, int32_t *buffer, int32_t sample_count, int32_t long_math);
extern void DECORR_MONO_PASS_CONT (struct decorr_pass *dpp, int32_t *buffer, int32_t sample_count, int32_t long_math);
#endif

// This monster actually unpacks the WavPack bitstream(s) into the specified
// buffer as 32-bit integers or floats (depending on original data). Lossy
// samples will be clipped to their original limits (i.e. 8-bit samples are
// clipped to -128/+127) but are still returned in longs. It is up to the
// caller to potentially reformat this for the final output including any
// multichannel distribution, block alignment or endian compensation. The
// function unpack_init() must have been called and the entire WavPack block
// must still be visible (although wps->blockbuff will not be accessed again).
// For maximum clarity, the function is broken up into segments that handle
// various modes. This makes for a few extra infrequent flag checks, but
// makes the code easier to follow because the nesting does not become so
// deep. For maximum efficiency, the conversion is isolated to tight loops
// that handle an entire buffer. The function returns the total number of
// samples unpacked, which can be less than the number requested if an error
// occurs or the end of the block is reached.

static void decorr_stereo_pass (struct decorr_pass *dpp, int32_t *buffer, int32_t sample_count);
static void decorr_mono_pass (struct decorr_pass *dpp, int32_t *buffer, int32_t sample_count);
static void fixup_samples (WavpackContext *wpc, int32_t *buffer, uint32_t sample_count);

int32_t unpack_samples (WavpackContext *wpc, int32_t *buffer, uint32_t sample_count)
{
    WavpackStream *wps = wpc->streams [wpc->current_stream];
    uint32_t flags = wps->wphdr.flags, crc = wps->crc, i;
    int32_t mute_limit = (1L << ((flags & MAG_MASK) >> MAG_LSB)) + 2;
    int32_t correction [2], read_word, *bptr;
    struct decorr_pass *dpp;
    int tcount, m = 0;

    // don't attempt to decode past the end of the block, but watch out for overflow!

    if (wps->sample_index + sample_count > GET_BLOCK_INDEX (wps->wphdr) + wps->wphdr.block_samples &&
        (uint32_t) (GET_BLOCK_INDEX (wps->wphdr) + wps->wphdr.block_samples - wps->sample_index) < sample_count)
            sample_count = (uint32_t) (GET_BLOCK_INDEX (wps->wphdr) + wps->wphdr.block_samples - wps->sample_index);

    if (GET_BLOCK_INDEX (wps->wphdr) > wps->sample_index || wps->wphdr.block_samples < sample_count)
        wps->mute_error = true;

    if (wps->mute_error) {
        if (wpc->reduced_channels == 1 || wpc->config.num_channels == 1 || (flags & MONO_FLAG))
            memset (buffer, 0, sample_count * 4);
        else
            memset (buffer, 0, sample_count * 8);

        wps->sample_index += sample_count;
        return sample_count;
    }

    if ((flags & HYBRID_FLAG) && !wps->block2buff)
        mute_limit = (mute_limit * 2) + 128;

    //////////////// handle lossless or hybrid lossy mono data /////////////////

    if (!wps->block2buff && (flags & MONO_DATA)) {
        int32_t *eptr = buffer + sample_count;

        if (flags & HYBRID_FLAG) {
            i = sample_count;

            for (bptr = buffer; bptr < eptr;)
                if ((*bptr++ = get_word (wps, 0, nullptr)) == WORD_EOF) {
                    i = (uint32_t)(bptr - buffer);
                    break;
                }
        }
        else
            i = get_words_lossless (wps, buffer, sample_count);

        if (i != sample_count)
            goto get_word_eof;

#if DECORR_MONO_PASS_CONT
        if (sample_count < 16)
            for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++)
                decorr_mono_pass (dpp, buffer, sample_count);
        else
            for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
                int pre_samples = (dpp->term > MAX_TERM) ? 2 : dpp->term;

                decorr_mono_pass (dpp, buffer, pre_samples);

                DECORR_MONO_PASS_CONT (dpp, buffer + pre_samples, sample_count - pre_samples,
                    ((flags & MAG_MASK) >> MAG_LSB) > 15);
            }
#else
        for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++)
            decorr_mono_pass (dpp, buffer, sample_count);
#endif

#if ! LOSSY_MUTE
        if (!(flags & HYBRID_FLAG))
#endif
        for (bptr = buffer; bptr < eptr; ++bptr) {
            if (labs (bptr [0]) > mute_limit) {
                i = (uint32_t)(bptr - buffer);
                break;
            }

            crc = crc * 3 + bptr [0];
        }
#if ! LOSSY_MUTE
        else
            for (bptr = buffer; bptr < eptr; ++bptr)
                crc = crc * 3 + bptr [0];
#endif
    }

    /////////////// handle lossless or hybrid lossy stereo data ///////////////

    else if (!wps->block2buff && !(flags & MONO_DATA)) {
        int32_t *eptr = buffer + (sample_count * 2);

        if (flags & HYBRID_FLAG) {
            i = sample_count;

            for (bptr = buffer; bptr < eptr; bptr += 2)
                if ((bptr [0] = get_word (wps, 0, nullptr)) == WORD_EOF ||
                    (bptr [1] = get_word (wps, 1, nullptr)) == WORD_EOF) {
                        i = (uint32_t)(bptr - buffer) / 2;
                        break;
                }
        }
        else
            i = get_words_lossless (wps, buffer, sample_count);

        if (i != sample_count)
            goto get_word_eof;

#if DECORR_STEREO_PASS_CONT
        if (sample_count < 16 || !DECORR_STEREO_PASS_CONT_AVAILABLE) {
            for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++)
                decorr_stereo_pass (dpp, buffer, sample_count);

            m = sample_count & (MAX_TERM - 1);
        }
        else
            for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
                int pre_samples = (dpp->term < 0 || dpp->term > MAX_TERM) ? 2 : dpp->term;

                decorr_stereo_pass (dpp, buffer, pre_samples);

                DECORR_STEREO_PASS_CONT (dpp, buffer + pre_samples * 2, sample_count - pre_samples,
                    ((flags & MAG_MASK) >> MAG_LSB) >= 16);
            }
#else
        for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++)
            decorr_stereo_pass (dpp, buffer, sample_count);

        m = sample_count & (MAX_TERM - 1);
#endif

        if (flags & JOINT_STEREO)
            for (bptr = buffer; bptr < eptr; bptr += 2) {
                bptr [0] += (bptr [1] -= (bptr [0] >> 1));
                crc += (crc << 3) + ((uint32_t) bptr [0] << 1) + bptr [0] + bptr [1];
            }
        else
            for (bptr = buffer; bptr < eptr; bptr += 2)
                crc += (crc << 3) + ((uint32_t) bptr [0] << 1) + bptr [0] + bptr [1];

#if ! LOSSY_MUTE
        if (!(flags & HYBRID_FLAG))
#endif
        for (bptr = buffer; bptr < eptr; bptr += 16)
            if (labs (bptr [0]) > mute_limit || labs (bptr [1]) > mute_limit) {
                i = (uint32_t)(bptr - buffer) / 2;
                break;
            }
    }

    /////////////////// handle hybrid lossless mono data ////////////////////

    else if ((flags & HYBRID_FLAG) && (flags & MONO_DATA))
        for (bptr = buffer, i = 0; i < sample_count; ++i) {

            if ((read_word = get_word (wps, 0, correction)) == WORD_EOF)
                break;

            for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
                int32_t sam, temp;
                int k;

                if (dpp->term > MAX_TERM) {
                    if (dpp->term & 1)
                        sam = 2 * dpp->samples_A [0] - dpp->samples_A [1];
                    else
                        sam = (3 * dpp->samples_A [0] - dpp->samples_A [1]) >> 1;

                    dpp->samples_A [1] = dpp->samples_A [0];
                    k = 0;
                }
                else {
                    sam = dpp->samples_A [m];
                    k = (m + dpp->term) & (MAX_TERM - 1);
                }

                temp = apply_weight (dpp->weight_A, sam) + read_word;
                update_weight (dpp->weight_A, dpp->delta, sam, read_word);
                dpp->samples_A [k] = read_word = temp;
            }

            m = (m + 1) & (MAX_TERM - 1);

            if (flags & HYBRID_SHAPE) {
                int shaping_weight = (wps->dc.shaping_acc [0] += wps->dc.shaping_delta [0]) >> 16;
                int32_t temp = -apply_weight (shaping_weight, wps->dc.error [0]);

                if ((flags & NEW_SHAPING) && shaping_weight < 0 && temp) {
                    if (temp == wps->dc.error [0])
                        temp = (temp < 0) ? temp + 1 : temp - 1;

                    wps->dc.error [0] = temp - correction [0];
                }
                else
                    wps->dc.error [0] = -correction [0];

                read_word += correction [0] - temp;
            }
            else
                read_word += correction [0];

            crc += (crc << 1) + read_word;

            if (labs (read_word) > mute_limit)
                break;

            *bptr++ = read_word;
        }

    //////////////////// handle hybrid lossless stereo data ///////////////////

    else if (wps->block2buff && !(flags & MONO_DATA))
        for (bptr = buffer, i = 0; i < sample_count; ++i) {
            int32_t left, right, left2, right2;
            int32_t left_c = 0, right_c = 0;

            if ((left = get_word (wps, 0, correction)) == WORD_EOF ||
                (right = get_word (wps, 1, correction + 1)) == WORD_EOF)
                    break;

            if (flags & CROSS_DECORR) {
                left_c = left + correction [0];
                right_c = right + correction [1];

                for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
                    int32_t sam_A, sam_B;

                    if (dpp->term > 0) {
                        if (dpp->term > MAX_TERM) {
                            if (dpp->term & 1) {
                                sam_A = 2 * dpp->samples_A [0] - dpp->samples_A [1];
                                sam_B = 2 * dpp->samples_B [0] - dpp->samples_B [1];
                            }
                            else {
                                sam_A = (3 * dpp->samples_A [0] - dpp->samples_A [1]) >> 1;
                                sam_B = (3 * dpp->samples_B [0] - dpp->samples_B [1]) >> 1;
                            }
                        }
                        else {
                            sam_A = dpp->samples_A [m];
                            sam_B = dpp->samples_B [m];
                        }

                        left_c += apply_weight (dpp->weight_A, sam_A);
                        right_c += apply_weight (dpp->weight_B, sam_B);
                    }
                    else if (dpp->term == -1) {
                        left_c += apply_weight (dpp->weight_A, dpp->samples_A [0]);
                        right_c += apply_weight (dpp->weight_B, left_c);
                    }
                    else {
                        right_c += apply_weight (dpp->weight_B, dpp->samples_B [0]);

                        if (dpp->term == -3)
                            left_c += apply_weight (dpp->weight_A, dpp->samples_A [0]);
                        else
                            left_c += apply_weight (dpp->weight_A, right_c);
                    }
                }

                if (flags & JOINT_STEREO)
                    left_c += (right_c -= (left_c >> 1));
            }

            for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
                int32_t sam_A, sam_B;

                if (dpp->term > 0) {
                    int k;

                    if (dpp->term > MAX_TERM) {
                        if (dpp->term & 1) {
                            sam_A = 2 * dpp->samples_A [0] - dpp->samples_A [1];
                            sam_B = 2 * dpp->samples_B [0] - dpp->samples_B [1];
                        }
                        else {
                            sam_A = (3 * dpp->samples_A [0] - dpp->samples_A [1]) >> 1;
                            sam_B = (3 * dpp->samples_B [0] - dpp->samples_B [1]) >> 1;
                        }

                        dpp->samples_A [1] = dpp->samples_A [0];
                        dpp->samples_B [1] = dpp->samples_B [0];
                        k = 0;
                    }
                    else {
                        sam_A = dpp->samples_A [m];
                        sam_B = dpp->samples_B [m];
                        k = (m + dpp->term) & (MAX_TERM - 1);
                    }

                    left2 = apply_weight (dpp->weight_A, sam_A) + left;
                    right2 = apply_weight (dpp->weight_B, sam_B) + right;

                    update_weight (dpp->weight_A, dpp->delta, sam_A, left);
                    update_weight (dpp->weight_B, dpp->delta, sam_B, right);

                    dpp->samples_A [k] = left = left2;
                    dpp->samples_B [k] = right = right2;
                }
                else if (dpp->term == -1) {
                    left2 = left + apply_weight (dpp->weight_A, dpp->samples_A [0]);
                    update_weight_clip (dpp->weight_A, dpp->delta, dpp->samples_A [0], left);
                    left = left2;
                    right2 = right + apply_weight (dpp->weight_B, left2);
                    update_weight_clip (dpp->weight_B, dpp->delta, left2, right);
                    dpp->samples_A [0] = right = right2;
                }
                else {
                    right2 = right + apply_weight (dpp->weight_B, dpp->samples_B [0]);
                    update_weight_clip (dpp->weight_B, dpp->delta, dpp->samples_B [0], right);
                    right = right2;

                    if (dpp->term == -3) {
                        right2 = dpp->samples_A [0];
                        dpp->samples_A [0] = right;
                    }

                    left2 = left + apply_weight (dpp->weight_A, right2);
                    update_weight_clip (dpp->weight_A, dpp->delta, right2, left);
                    dpp->samples_B [0] = left = left2;
                }
            }

            m = (m + 1) & (MAX_TERM - 1);

            if (!(flags & CROSS_DECORR)) {
                left_c = left + correction [0];
                right_c = right + correction [1];

                if (flags & JOINT_STEREO)
                    left_c += (right_c -= (left_c >> 1));
            }

            if (flags & JOINT_STEREO)
                left += (right -= (left >> 1));

            if (flags & HYBRID_SHAPE) {
                int shaping_weight;
                int32_t temp;

                correction [0] = left_c - left;
                shaping_weight = (wps->dc.shaping_acc [0] += wps->dc.shaping_delta [0]) >> 16;
                temp = -apply_weight (shaping_weight, wps->dc.error [0]);

                if ((flags & NEW_SHAPING) && shaping_weight < 0 && temp) {
                    if (temp == wps->dc.error [0])
                        temp = (temp < 0) ? temp + 1 : temp - 1;

                    wps->dc.error [0] = temp - correction [0];
                }
                else
                    wps->dc.error [0] = -correction [0];

                left = left_c - temp;
                correction [1] = right_c - right;
                shaping_weight = (wps->dc.shaping_acc [1] += wps->dc.shaping_delta [1]) >> 16;
                temp = -apply_weight (shaping_weight, wps->dc.error [1]);

                if ((flags & NEW_SHAPING) && shaping_weight < 0 && temp) {
                    if (temp == wps->dc.error [1])
                        temp = (temp < 0) ? temp + 1 : temp - 1;

                    wps->dc.error [1] = temp - correction [1];
                }
                else
                    wps->dc.error [1] = -correction [1];

                right = right_c - temp;
            }
            else {
                left = left_c;
                right = right_c;
            }

            if (labs (left) > mute_limit || labs (right) > mute_limit)
                break;

            crc += (crc << 3) + ((uint32_t) left << 1) + left + right;
            *bptr++ = left;
            *bptr++ = right;
        }
    else
        i = 0;  /* this line can't execute, but suppresses compiler warning */

get_word_eof:
    if (i != sample_count) {
        memset (buffer, 0, sample_count * (flags & MONO_FLAG ? 4 : 8));
        wps->mute_error = true;
        i = sample_count;

        if (bs_is_open (&wps->wvxbits))
            bs_close_read (&wps->wvxbits);
    }

    if (m)
        for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++)
            if (dpp->term > 0 && dpp->term <= MAX_TERM) {
                int32_t temp_A [MAX_TERM], temp_B [MAX_TERM];
                int k;

                memcpy (temp_A, dpp->samples_A, sizeof (dpp->samples_A));
                memcpy (temp_B, dpp->samples_B, sizeof (dpp->samples_B));

                for (k = 0; k < MAX_TERM; k++) {
                    dpp->samples_A [k] = temp_A [m];
                    dpp->samples_B [k] = temp_B [m];
                    m = (m + 1) & (MAX_TERM - 1);
                }
            }

    fixup_samples (wpc, buffer, i);

    if ((flags & FLOAT_DATA) && (wpc->open_flags & OPEN_NORMALIZE))
        WavpackFloatNormalize (buffer, (flags & MONO_DATA) ? i : i * 2,
            127 - wps->float_norm_exp + wpc->norm_offset);

    if (flags & FALSE_STEREO) {
        int32_t *dptr = buffer + i * 2;
        int32_t *sptr = buffer + i;
        int32_t c = i;

        while (c--) {
            *--dptr = *--sptr;
            *--dptr = *sptr;
        }
    }

    wps->sample_index += i;
    wps->crc = crc;

    return i;
}

// General function to perform mono decorrelation pass on specified buffer
// (although since this is the reverse function it might technically be called
// "correlation" instead). This version handles all sample resolutions and
// weight deltas. The dpp->samples_X[] data is returned normalized for term
// values 1-8.

static void decorr_mono_pass (struct decorr_pass *dpp, int32_t *buffer, int32_t sample_count)
{
    int32_t delta = dpp->delta, weight_A = dpp->weight_A;
    int32_t *bptr, *eptr = buffer + sample_count, sam_A;
    int m, k;

    switch (dpp->term) {

        case 17:
            for (bptr = buffer; bptr < eptr; bptr++) {
                sam_A = 2 * dpp->samples_A [0] - dpp->samples_A [1];
                dpp->samples_A [1] = dpp->samples_A [0];
                dpp->samples_A [0] = apply_weight (weight_A, sam_A) + bptr [0];
                update_weight (weight_A, delta, sam_A, bptr [0]);
                bptr [0] = dpp->samples_A [0];
            }

            break;

        case 18:
            for (bptr = buffer; bptr < eptr; bptr++) {
                sam_A = (3 * dpp->samples_A [0] - dpp->samples_A [1]) >> 1;
                dpp->samples_A [1] = dpp->samples_A [0];
                dpp->samples_A [0] = apply_weight (weight_A, sam_A) + bptr [0];
                update_weight (weight_A, delta, sam_A, bptr [0]);
                bptr [0] = dpp->samples_A [0];
            }

            break;

        default:
            for (m = 0, k = dpp->term & (MAX_TERM - 1), bptr = buffer; bptr < eptr; bptr++) {
                sam_A = dpp->samples_A [m];
                dpp->samples_A [k] = apply_weight (weight_A, sam_A) + bptr [0];
                update_weight (weight_A, delta, sam_A, bptr [0]);
                bptr [0] = dpp->samples_A [k];
                m = (m + 1) & (MAX_TERM - 1);
                k = (k + 1) & (MAX_TERM - 1);
            }

            if (m) {
                int32_t temp_samples [MAX_TERM];

                memcpy (temp_samples, dpp->samples_A, sizeof (dpp->samples_A));

                for (k = 0; k < MAX_TERM; k++, m++)
                    dpp->samples_A [k] = temp_samples [m & (MAX_TERM - 1)];
            }

            break;
    }

    dpp->weight_A = weight_A;
}

// General function to perform stereo decorrelation pass on specified buffer
// (although since this is the reverse function it might technically be called
// "correlation" instead). This version handles all sample resolutions and
// weight deltas. The dpp->samples_X[] data is *not* returned normalized for
// term values 1-8, so it should be normalized if it is going to be used to
// call this function again.

static void decorr_stereo_pass (struct decorr_pass *dpp, int32_t *buffer, int32_t sample_count)
{
    int32_t *bptr, *eptr = buffer + (sample_count * 2);
    int m, k;

    switch (dpp->term) {
        case 17:
            for (bptr = buffer; bptr < eptr; bptr += 2) {
                int32_t sam, tmp;

                sam = 2 * dpp->samples_A [0] - dpp->samples_A [1];
                dpp->samples_A [1] = dpp->samples_A [0];
                bptr [0] = dpp->samples_A [0] = apply_weight (dpp->weight_A, sam) + (tmp = bptr [0]);
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);

                sam = 2 * dpp->samples_B [0] - dpp->samples_B [1];
                dpp->samples_B [1] = dpp->samples_B [0];
                bptr [1] = dpp->samples_B [0] = apply_weight (dpp->weight_B, sam) + (tmp = bptr [1]);
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
            }

            break;

        case 18:
            for (bptr = buffer; bptr < eptr; bptr += 2) {
                int32_t sam, tmp;

                sam = dpp->samples_A [0] + ((dpp->samples_A [0] - dpp->samples_A [1]) >> 1);
                dpp->samples_A [1] = dpp->samples_A [0];
                bptr [0] = dpp->samples_A [0] = apply_weight (dpp->weight_A, sam) + (tmp = bptr [0]);
                update_weight (dpp->weight_A, dpp->delta, sam, tmp);

                sam = dpp->samples_B [0] + ((dpp->samples_B [0] - dpp->samples_B [1]) >> 1);
                dpp->samples_B [1] = dpp->samples_B [0];
                bptr [1] = dpp->samples_B [0] = apply_weight (dpp->weight_B, sam) + (tmp = bptr [1]);
                update_weight (dpp->weight_B, dpp->delta, sam, tmp);
            }

            break;

        default:
            for (m = 0, k = dpp->term & (MAX_TERM - 1), bptr = buffer; bptr < eptr; bptr += 2) {
                int32_t sam;

                sam = dpp->samples_A [m];
                dpp->samples_A [k] = apply_weight (dpp->weight_A, sam) + bptr [0];
                update_weight (dpp->weight_A, dpp->delta, sam, bptr [0]);
                bptr [0] = dpp->samples_A [k];

                sam = dpp->samples_B [m];
                dpp->samples_B [k] = apply_weight (dpp->weight_B, sam) + bptr [1];
                update_weight (dpp->weight_B, dpp->delta, sam, bptr [1]);
                bptr [1] = dpp->samples_B [k];

                m = (m + 1) & (MAX_TERM - 1);
                k = (k + 1) & (MAX_TERM - 1);
            }

            break;

        case -1:
            for (bptr = buffer; bptr < eptr; bptr += 2) {
                int32_t sam;

                sam = bptr [0] + apply_weight (dpp->weight_A, dpp->samples_A [0]);
                update_weight_clip (dpp->weight_A, dpp->delta, dpp->samples_A [0], bptr [0]);
                bptr [0] = sam;
                dpp->samples_A [0] = bptr [1] + apply_weight (dpp->weight_B, sam);
                update_weight_clip (dpp->weight_B, dpp->delta, sam, bptr [1]);
                bptr [1] = dpp->samples_A [0];
            }

            break;

        case -2:
            for (bptr = buffer; bptr < eptr; bptr += 2) {
                int32_t sam;

                sam = bptr [1] + apply_weight (dpp->weight_B, dpp->samples_B [0]);
                update_weight_clip (dpp->weight_B, dpp->delta, dpp->samples_B [0], bptr [1]);
                bptr [1] = sam;
                dpp->samples_B [0] = bptr [0] + apply_weight (dpp->weight_A, sam);
                update_weight_clip (dpp->weight_A, dpp->delta, sam, bptr [0]);
                bptr [0] = dpp->samples_B [0];
            }

            break;

        case -3:
            for (bptr = buffer; bptr < eptr; bptr += 2) {
                int32_t sam_A, sam_B;

                sam_A = bptr [0] + apply_weight (dpp->weight_A, dpp->samples_A [0]);
                update_weight_clip (dpp->weight_A, dpp->delta, dpp->samples_A [0], bptr [0]);
                sam_B = bptr [1] + apply_weight (dpp->weight_B, dpp->samples_B [0]);
                update_weight_clip (dpp->weight_B, dpp->delta, dpp->samples_B [0], bptr [1]);
                bptr [0] = dpp->samples_B [0] = sam_A;
                bptr [1] = dpp->samples_A [0] = sam_B;
            }

            break;
    }
}

// This is a helper function for unpack_samples() that applies several final
// operations. First, if the data is 32-bit float data, then that conversion
// is done in the float.c module (whether lossy or lossless) and we return.
// Otherwise, if the extended integer data applies, then that operation is
// executed first. If the unpacked data is lossy (and not corrected) then
// it is clipped and shifted in a single operation. Otherwise, if it's
// lossless then the last step is to apply the final shift (if any).

static void fixup_samples (WavpackContext *wpc, int32_t *buffer, uint32_t sample_count)
{
    WavpackStream *wps = wpc->streams [wpc->current_stream];
    uint32_t flags = wps->wphdr.flags;
    int lossy_flag = (flags & HYBRID_FLAG) && !wps->block2buff;
    int shift = (flags & SHIFT_MASK) >> SHIFT_LSB;

    if (flags & FLOAT_DATA) {
        float_values (wps, buffer, (flags & MONO_DATA) ? sample_count : sample_count * 2);
        return;
    }

    if (flags & INT32_DATA) {
        uint32_t count = (flags & MONO_DATA) ? sample_count : sample_count * 2;
        int sent_bits = wps->int32_sent_bits & 0x1f, zeros = wps->int32_zeros & 0x1f;
        int ones = wps->int32_ones & 0x1f, dups = wps->int32_dups & 0x1f;
        uint32_t data, mask = (1U << sent_bits) - 1;
        int32_t *dptr = buffer;

        if (bs_is_open (&wps->wvxbits)) {
            uint32_t crc = wps->crc_x;

            while (count--) {
//              if (sent_bits) {
                    getbits (&data, sent_bits, &wps->wvxbits);
                    *dptr = ((uint32_t) *dptr << sent_bits) | (data & mask);
//              }

                if (zeros)
                    *(uint32_t*)dptr <<= zeros;
                else if (ones)
                    *dptr = ((uint32_t)(*dptr + 1) << ones) - 1;
                else if (dups)
                    *dptr = ((uint32_t)(*dptr + (*dptr & 1)) << dups) - (*dptr & 1);

                crc = crc * 9 + (*dptr & 0xffff) * 3 + ((*dptr >> 16) & 0xffff);
                dptr++;
            }

            wps->crc_x = crc;
        }
        else if (!sent_bits && (zeros + ones + dups)) {
            while (lossy_flag && (flags & BYTES_STORED) == 3 && shift < 8) {
                if (zeros)
                    zeros--;
                else if (ones)
                    ones--;
                else if (dups)
                    dups--;
                else
                    break;

                shift++;
            }

            while (count--) {
                if (zeros)
                    *(uint32_t*)dptr <<= zeros;
                else if (ones)
                    *dptr = ((uint32_t)(*dptr + 1) << ones) - 1;
                else if (dups)
                    *dptr = ((uint32_t)(*dptr + (*dptr & 1)) << dups) - (*dptr & 1);

                dptr++;
            }
        }
        else
            shift += zeros + sent_bits + ones + dups;
    }

    shift &= 0x1f;

    if (lossy_flag) {
        int32_t min_value, max_value, min_shifted, max_shifted;

        switch (flags & BYTES_STORED) {
            case 0:
                min_shifted = (uint32_t)(min_value = -128 >> shift) << shift;
                max_shifted = (max_value = 127 >> shift) << shift;
                break;

            case 1:
                min_shifted = (uint32_t)(min_value = -32768 >> shift) << shift;
                max_shifted = (max_value = 32767 >> shift) << shift;
                break;

            case 2:
                min_shifted = (uint32_t)(min_value = -8388608 >> shift) << shift;
                max_shifted = (max_value = 8388607 >> shift) << shift;
                break;

            case 3: default:    /* "default" suppresses compiler warning */
                min_shifted = (uint32_t)(min_value = (int32_t) 0x80000000 >> shift) << shift;
                max_shifted = (max_value = (int32_t) 0x7fffffff >> shift) << shift;
                break;
        }

        if (!(flags & MONO_DATA))
            sample_count *= 2;

        while (sample_count--) {
            if (*buffer < min_value)
                *buffer++ = min_shifted;
            else if (*buffer > max_value)
                *buffer++ = max_shifted;
            else
                *(uint32_t*)buffer++ <<= shift;
        }
    }
    else if (shift) {
        if (!(flags & MONO_DATA))
            sample_count *= 2;

        while (sample_count--)
            *(uint32_t*)buffer++ <<= shift;
    }
}

// This function checks the crc value(s) for an unpacked block, returning the
// number of actual crc errors detected for the block. The block must be
// completely unpacked before this test is valid. For losslessly unpacked
// blocks of float or extended integer data the extended crc is also checked.
// Note that WavPack's crc is not a CCITT approved polynomial algorithm, but
// is a much simpler method that is virtually as robust for real world data.

int check_crc_error (WavpackContext *wpc)
{
    int result = 0, stream;

    for (stream = 0; stream < wpc->num_streams; stream++) {
        WavpackStream *wps = wpc->streams [stream];

        if (wps->crc != wps->wphdr.crc)
            ++result;
        else if (bs_is_open (&wps->wvxbits) && wps->crc_x != wps->crc_wvx)
            ++result;
    }

    return result;
}


// This module provides unpacking for WavPack files prior to version 4.0,
// not including "raw" files. As these modes are all obsolete and are no
// longer written, this code will not be fully documented other than the
// global functions. However, full documentation is provided in the version
// 3.97 source code. Note that this module does only the low-level sample
// unpacking; the actual opening of the file (and obtaining information
// from it) is handled in the unpack3_open.c module.

#if ENABLE_LEGACY

#define ATTEMPT_ERROR_MUTING

static int bs_open_read3 (Bitstream3 *bs, WavpackStreamReader64 *reader, void *id);
static uint32_t bs_unused_bytes (Bitstream3 *bs);
static uint8_t *bs_unused_data (Bitstream3 *bs);
static void init_words3 (WavpackStream3 *wps);

//////////////////////////////// local macros /////////////////////////////////

#define apply_weight_n(bits, weight, sample) ((weight * sample + (1 << (bits - 1))) >> bits)

#define update_weight_n(bits, weight, source, result) \
    if (source && result) { \
        if ((source ^ result) >= 0) { if (weight++ == (1 << bits)) weight--; } \
        else if (weight-- == min_weight) weight++; \
    }

#define apply_weight24(weight, sample) (((((sample & 0xffff) * weight) >> 7) + \
    (((sample & ~0xffff) >> 7) * weight) + 1) >> 1)

#define update_weight2(weight, source, result) \
    if (source && result) { \
        if ((source ^ result) >= 0) { if (weight++ == 256) weight--; } \
        else if (weight-- == min_weight) weight++; \
    }

//////////////////////////////// local tables ///////////////////////////////

// These three tables specify the characteristics of the decorrelation filters.
// Each term represents one layer of the sequential filter, where positive
// values indicate the relative sample involved from the same channel (1=prev)
// while -1 and -2 indicate cross channel decorrelation (in stereo only). The
// "simple_terms" table is no longer used for writing, but is kept for older
// file decoding.

static const signed char extreme_terms [] = { 1,1,1,2,4,-1,1,2,3,6,-2,8,5,7,4,1,2,3 };
static const signed char default_terms [] = { 1,1,1,-1,2,1,-2 };
static const signed char simple_terms []  = { 1,1,1,1 };

///////////////////////////// executable code ////////////////////////////////

// This function initializes everything required to unpack WavPack
// bitstreams and must be called before any unpacking is performed. Note
// that the (WavpackHeader3 *) in the WavpackStream3 struct must be valid.

void unpack_init3 (WavpackStream3 *wps)
{
    int flags = wps->wphdr.flags;
    struct decorr_pass *dpp;
    int ti;

    CLEAR (wps->decorr_passes);
    CLEAR (wps->dc);

    if (flags & EXTREME_DECORR) {
        for (dpp = wps->decorr_passes, ti = 0; ti < sizeof (extreme_terms); ti++)
            if (extreme_terms [sizeof (extreme_terms) - ti - 1] > 0 || (flags & CROSS_DECORR))
                dpp++->term = extreme_terms [sizeof (extreme_terms) - ti - 1];
    }
    else if (flags & NEW_DECORR_FLAG) {
        for (dpp = wps->decorr_passes, ti = 0; ti < sizeof (default_terms); ti++)
            if (default_terms [sizeof (default_terms) - ti - 1] > 0 || (flags & CROSS_DECORR))
                dpp++->term = default_terms [sizeof (default_terms) - ti - 1];
    }
    else
        for (dpp = wps->decorr_passes, ti = 0; ti < sizeof (simple_terms); ti++)
            dpp++->term = simple_terms [sizeof (simple_terms) - ti - 1];

    wps->num_terms = (int)(dpp - wps->decorr_passes);
    init_words3 (wps);
}

#if ! NO_SEEKING

// This function returns the size (in bytes) required to save the unpacking
// context. Note that the (WavpackHeader3 *) in the WavpackStream3 struct
// must be valid.

static int unpack_size (WavpackStream3 *wps)
{
    int flags = wps->wphdr.flags, byte_sum = 0, tcount;
    struct decorr_pass *dpp;

    byte_sum += sizeof (wps->wvbits);

    if (flags & WVC_FLAG)
        byte_sum += sizeof (wps->wvcbits);

    if (wps->wphdr.version == 3) {
        if (wps->wphdr.bits)
            byte_sum += sizeof (wps->w4);
        else
            byte_sum += sizeof (wps->w1);

        byte_sum += sizeof (wps->w3) + sizeof (wps->dc.crc);
    }
    else
        byte_sum += sizeof (wps->w2);

    if (wps->wphdr.bits)
        byte_sum += sizeof (wps->dc.error);
    else
        byte_sum += sizeof (wps->dc.sum_level) + sizeof (wps->dc.left_level) +
            sizeof (wps->dc.right_level) + sizeof (wps->dc.diff_level);

    if (flags & OVER_20)
        byte_sum += sizeof (wps->dc.last_extra_bits) + sizeof (wps->dc.extra_bits_count);

    if (!(flags & EXTREME_DECORR)) {
        byte_sum += sizeof (wps->dc.sample);
        byte_sum += sizeof (wps->dc.weight);
    }

    if (flags & (HIGH_FLAG | NEW_HIGH_FLAG))
        for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
            if (dpp->term > 0) {
                byte_sum += sizeof (dpp->samples_A [0]) * dpp->term;
                byte_sum += sizeof (dpp->weight_A);

                if (!(flags & MONO_FLAG)) {
                    byte_sum += sizeof (dpp->samples_B [0]) * dpp->term;
                    byte_sum += sizeof (dpp->weight_B);
                }
            }
            else {
                byte_sum += sizeof (dpp->samples_A [0]) + sizeof (dpp->samples_B [0]);
                byte_sum += sizeof (dpp->weight_A) + sizeof (dpp->weight_B);
            }
        }

    return byte_sum;
}

// This function saves the unpacking context at the specified pointer and
// returns the updated pointer. The actual amount of data required can be
// determined beforehand by calling unpack_size() but must be allocated by
// the caller.

static void *unpack_save (WavpackStream3 *wps, void *destin)
{
    int flags = wps->wphdr.flags, tcount;
    struct decorr_pass *dpp;

    SAVE (destin, wps->wvbits);

    if (flags & WVC_FLAG)
        SAVE (destin, wps->wvcbits);

    if (wps->wphdr.version == 3) {
        if (wps->wphdr.bits) {
            SAVE (destin, wps->w4);
        }
        else {
            SAVE (destin, wps->w1);
        }

        SAVE (destin, wps->w3);
        SAVE (destin, wps->dc.crc);
    }
    else
        SAVE (destin, wps->w2);

    if (wps->wphdr.bits) {
        SAVE (destin, wps->dc.error);
    }
    else {
        SAVE (destin, wps->dc.sum_level);
        SAVE (destin, wps->dc.left_level);
        SAVE (destin, wps->dc.right_level);
        SAVE (destin, wps->dc.diff_level);
    }

    if (flags & OVER_20) {
        SAVE (destin, wps->dc.last_extra_bits);
        SAVE (destin, wps->dc.extra_bits_count);
    }

    if (!(flags & EXTREME_DECORR)) {
        SAVE (destin, wps->dc.sample);
        SAVE (destin, wps->dc.weight);
    }

    if (flags & (HIGH_FLAG | NEW_HIGH_FLAG))
        for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
            if (dpp->term > 0) {
                int count = dpp->term;
                int index = wps->dc.m;

                SAVE (destin, dpp->weight_A);

                while (count--) {
                    SAVE (destin, dpp->samples_A [index]);
                    index = (index + 1) & (MAX_TERM - 1);
                }

                if (!(flags & MONO_FLAG)) {
                    count = dpp->term;
                    index = wps->dc.m;

                    SAVE (destin, dpp->weight_B);

                    while (count--) {
                        SAVE (destin, dpp->samples_B [index]);
                        index = (index + 1) & (MAX_TERM - 1);
                    }
                }
            }
            else {
                SAVE (destin, dpp->weight_A);
                SAVE (destin, dpp->weight_B);
                SAVE (destin, dpp->samples_A [0]);
                SAVE (destin, dpp->samples_B [0]);
            }
        }

    return destin;
}

#endif

// This monster actually unpacks the WavPack bitstream(s) into the specified
// buffer as longs, and serves as an extension to WavpackUnpackSamples().
// Note that WavPack files created prior to version 4.0 could only contain 16
// or 24 bit values, and these values are right-justified in the 32-bit values.
// So, if the original file contained 16-bit values, then the range of the
// returned longs would be +/- 32K. For maximum clarity, the function is
// broken up into segments that handle various modes. This makes for a few
// extra infrequent flag checks, but makes the code easier to follow because
// the nesting does not become so deep. For maximum efficiency, the conversion
// is isolated to tight loops that handle an entire buffer.

static int32_t FASTCALL get_word1 (WavpackStream3 *wps, int chan);
static int32_t FASTCALL get_old_word1 (WavpackStream3 *wps, int chan);
static int32_t FASTCALL get_word2 (WavpackStream3 *wps, int chan);
static int32_t FASTCALL get_word3 (WavpackStream3 *wps, int chan);
static int32_t FASTCALL get_word4 (WavpackStream3 *wps, int chan, int32_t *correction);

int32_t unpack_samples3 (WavpackContext *wpc, int32_t *buffer, uint32_t sample_count)
{
    WavpackStream3 *wps = (WavpackStream3 *) wpc->stream3;
    int shift = wps->wphdr.shift, flags = wps->wphdr.flags, min_weight = 0, m = wps->dc.m, tcount;
#if ! NO_SEEKING
    int points_index = wps->sample_index / (((uint32_t) wpc->total_samples >> 8) + 1);
#endif
    int32_t min_value, max_value, min_shifted, max_shifted;
    int32_t correction [2], crc = wps->dc.crc;
    struct decorr_pass *dpp;
    int32_t read_word, *bptr;
    int32_t sample [2] [2];
    int weight [2] [1];
    unsigned int i;

#if ATTEMPT_ERROR_MUTING
    int32_t mute_limit = (flags & BYTES_3) ? 8388608 : 32768;
    int mute_block = 0;

    if (wps->wphdr.bits && !(flags & WVC_FLAG)) {
        if (wps->wphdr.version < 3)
            mute_limit *= 4;
        else
            mute_limit *= 2;
    }
#endif

    if (wps->sample_index + sample_count > wpc->total_samples)
        sample_count = (uint32_t) (wpc->total_samples - wps->sample_index);

    if (!sample_count)
        return 0;

    if (!wps->sample_index) {
        unpack_init3 (wps);

        bs_open_read3 (&wps->wvbits, wpc->reader, wpc->wv_in);

        if (wpc->wvc_flag)
            bs_open_read3 (&wps->wvcbits, wpc->reader, wpc->wvc_in);
    }

#if ! NO_SEEKING
    if (!wps->index_points [points_index].saved) {

        if (!wps->unpack_data)
            wps->unpack_data = (uint8_t *) malloc (256 * (wps->unpack_size = unpack_size (wps)));

        wps->index_points [points_index].sample_index = wps->sample_index;
        unpack_save (wps, wps->unpack_data + points_index * wps->unpack_size);
        wps->index_points [points_index].saved = true;
    }
#endif

    memcpy (sample, wps->dc.sample, sizeof (sample));
    memcpy (weight, wps->dc.weight, sizeof (weight));

    if (wps->wphdr.bits) {
        if (flags & (NEW_DECORR_FLAG | EXTREME_DECORR))
            min_weight = -256;
    }
    else
        if (flags & NEW_DECORR_FLAG)
            min_weight = (flags & EXTREME_DECORR) ? -512 : -256;

    if (flags & BYTES_3) {
        min_shifted = (min_value = -8388608 >> shift) << shift;
        max_shifted = (max_value = 8388607 >> shift) << shift;
    }
    else {
        min_shifted = (min_value = -32768 >> shift) << shift;
        max_shifted = (max_value = 32767 >> shift) << shift;
    }

    ///////////////// handle version 3 lossless mono data /////////////////////

    if (wps->wphdr.version == 3 && !wps->wphdr.bits && (flags & MONO_FLAG)) {
        if (flags & FAST_FLAG) {
            if (flags & OVER_20)
                for (bptr = buffer, i = 0; i < sample_count; ++i) {
                    int32_t temp;

                    if ((read_word = get_word3 (wps, 0)) == WORD_EOF)
                        break;

                    sample [0] [0] += sample [0] [1] += read_word;
                    getbits (&temp, 4, &wps->wvbits);
                    crc = crc * 3 + (temp = (temp & 0xf) + (sample [0] [0] << 4));
                    *bptr++ = temp;
                }
            else
                for (bptr = buffer, i = 0; i < sample_count; ++i) {
                    if ((read_word = get_word3 (wps, 0)) == WORD_EOF)
                        break;

                    crc = crc * 3 + (sample [0] [0] += sample [0] [1] += read_word);
                    *bptr++ = sample [0] [0] << shift;
                }
        }
        else if (flags & HIGH_FLAG)
            for (bptr = buffer, i = 0; i < sample_count; ++i) {
                int32_t temp;

                if (flags & NEW_HIGH_FLAG) {
                    if ((read_word = get_word1 (wps, 0)) == WORD_EOF)
                        break;
                }
                else {
                    if ((read_word = get_old_word1 (wps, 0)) == WORD_EOF)
                        break;
                }

                if (flags & EXTREME_DECORR)
                    for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
                        int32_t sam = dpp->samples_A [m];

                        temp = apply_weight_n (9, dpp->weight_A, sam) + read_word;
                        update_weight_n (9, dpp->weight_A, sam, read_word);
                        dpp->samples_A [(m + dpp->term) & (MAX_TERM - 1)] = read_word = temp;
                    }
                else
                    for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
                        int32_t sam = dpp->samples_A [m];

                        temp = apply_weight_n (8, dpp->weight_A, sam) + read_word;
                        update_weight_n (8, dpp->weight_A, sam, read_word);
                        dpp->samples_A [(m + dpp->term) & (MAX_TERM - 1)] = read_word = temp;
                    }

                m = (m + 1) & (MAX_TERM - 1);

                if (flags & OVER_20) {
                    if (wps->dc.extra_bits_count < 8 || !getbit (&wps->wvbits)) {
                        getbits (&temp, 4, &wps->wvbits);

                        if ((temp &= 0xf) != wps->dc.last_extra_bits) {
                            wps->dc.last_extra_bits = temp;
                            wps->dc.extra_bits_count = 0;
                        }
                        else
                            ++wps->dc.extra_bits_count;
                    }

                    crc = crc * 3 + (temp = wps->dc.last_extra_bits + (read_word << 4));
                    *bptr++ = temp;
                }
                else {
                    crc = crc * 3 + read_word;
                    *bptr++ = read_word << shift;
                }
            }
        else
            for (bptr = buffer, i = 0; i < sample_count; ++i) {

                int32_t temp;

                if ((read_word = get_word3 (wps, 0)) == WORD_EOF)
                    break;

                temp = sample [0] [0] + ((sample [0] [1] * weight [0] [0] + 128) >> 8) + read_word;

                if ((sample [0] [1] >= 0) == (read_word > 0)) {
                    if (weight [0] [0]++ == 256)
                        weight [0] [0]--;
                }
                else if (weight [0] [0]-- == 0)
                    weight [0] [0]++;

                sample [0] [0] += (sample [0] [1] = temp - sample [0] [0]);

                if (flags & OVER_20) {
                    if (wps->dc.extra_bits_count < 8 || !getbit (&wps->wvbits)) {
                        getbits (&temp, 4, &wps->wvbits);

                        if ((temp &= 0xf) != wps->dc.last_extra_bits) {
                            wps->dc.last_extra_bits = temp;
                            wps->dc.extra_bits_count = 0;
                        }
                        else
                            ++wps->dc.extra_bits_count;
                    }

                    crc = crc * 3 + (*bptr++ = temp = wps->dc.last_extra_bits + (sample [0] [0] << 4));
                }
                else {
                    crc = crc * 3 + sample [0] [0];
                    *bptr++ = sample [0] [0] << shift;
                }
            }
    }

    //////////////// handle version 3 lossless stereo data ////////////////////

    else if (wps->wphdr.version == 3 && !wps->wphdr.bits && !(flags & MONO_FLAG)) {
        int32_t left_level = wps->dc.left_level, right_level = wps->dc.right_level;
        int32_t sum_level = wps->dc.sum_level, diff_level = wps->dc.diff_level;

        if (flags & FAST_FLAG) {
            if (flags & OVER_20)
                for (bptr = buffer, i = 0; i < sample_count; ++i) {
                    int32_t sum, diff, temp;

                    read_word = get_word3 (wps, 0);

                    if (read_word == WORD_EOF)
                        break;

                    sum = (read_word << 1) | ((diff = get_word3 (wps, 1)) & 1);
                    sample [0] [0] += sample [0] [1] += ((sum + diff) >> 1);
                    sample [1] [0] += sample [1] [1] += ((sum - diff) >> 1);
                    getbits (&temp, 8, &wps->wvbits);
                    crc = crc * 3 + (*bptr++ = (sample [0] [0] << 4) + ((temp >> 4) & 0xf));
                    crc = crc * 3 + (*bptr++ = (sample [1] [0] << 4) + (temp & 0xf));
                }
            else
                for (bptr = buffer, i = 0; i < sample_count; ++i) {
                    int32_t sum, diff;

                    read_word = get_word3 (wps, 0);

                    if (read_word == WORD_EOF)
                        break;

                    sum = (read_word << 1) | ((diff = get_word3 (wps, 1)) & 1);
                    sample [0] [1] += ((sum + diff) >> 1);
                    sample [1] [1] += ((sum - diff) >> 1);
                    crc = crc * 3 + (sample [0] [0] += sample [0] [1]);
                    crc = crc * 3 + (sample [1] [0] += sample [1] [1]);
                    *bptr++ = sample [0] [0] << shift;
                    *bptr++ = sample [1] [0] << shift;
                }
        }
        else if (flags & HIGH_FLAG) {
            for (bptr = buffer, i = 0; i < sample_count; ++i) {
                int32_t sum, left, right, diff, left2, right2, extra_bits, next_word;

                if (flags & CROSS_DECORR) {
                    left = get_word1 (wps, 0);

                    if (left == WORD_EOF)
                        break;

                    right = get_word1 (wps, 1);
                }
                else {
                    if (flags & NEW_HIGH_FLAG) {
                        read_word = get_word1 (wps, 0);

                        if (read_word == WORD_EOF)
                            break;

                        next_word = get_word1 (wps, 1);

                        if (right_level > left_level) {
                            if (left_level + right_level < sum_level + diff_level && right_level < diff_level) {
                                sum = (right = read_word) + (left = next_word);
                                diff = left - right;
                            }
                            else {
                                diff = read_word;

                                if (sum_level < left_level) {
                                    sum = (next_word << 1) | (diff & 1);
                                    left = (sum + diff) >> 1;
                                    right = (sum - diff) >> 1;
                                }
                                else
                                    sum = next_word + (right = (left = next_word) - diff);
                            }
                        }
                        else {
                            if (left_level + right_level < sum_level + diff_level && left_level < diff_level) {
                                sum = (left = read_word) + (right = next_word);
                                diff = left - right;
                            }
                            else {
                                diff = read_word;

                                if (sum_level < right_level) {
                                    sum = (next_word << 1) | (diff & 1);
                                    left = (sum + diff) >> 1;
                                    right = (sum - diff) >> 1;
                                }
                                else
                                    sum = (left = diff + (right = next_word)) + next_word;
                            }
                        }
                    }
                    else {
                        read_word = get_old_word1 (wps, 0);

                        if (read_word == WORD_EOF)
                            break;

                        next_word = get_old_word1 (wps, 1);

                        if (sum_level <= right_level && sum_level <= left_level) {
                            sum = (next_word << 1) | (read_word & 1);
                            left = (sum + read_word) >> 1;
                            right = (sum - read_word) >> 1;
                        }
                        else if (left_level <= right_level)
                            sum = next_word + (right = (left = next_word) - read_word);
                        else
                            sum = next_word + (left = read_word + (right = next_word));

                        diff = left - right;
                    }

                    sum_level = sum_level - (sum_level >> 8) + labs (sum >> 1);
                    left_level = left_level - (left_level >> 8) + labs (left);
                    right_level = right_level - (right_level >> 8) + labs (right);
                    diff_level = diff_level - (diff_level >> 8) + labs (diff);

                    if (flags & JOINT_STEREO) {
                        left = diff;
                        right = sum >> 1;
                    }
                }

                if (flags & EXTREME_DECORR) {
                    for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++)
                        if (dpp->term > 0) {
                            int32_t sam_A = dpp->samples_A [m], sam_B = dpp->samples_B [m];
                            int k = (m + dpp->term) & (MAX_TERM - 1);

                            left2 = apply_weight_n (9, dpp->weight_A, sam_A) + left;
                            right2 = apply_weight_n (9, dpp->weight_B, sam_B) + right;

                            update_weight_n (9, dpp->weight_A, sam_A, left);
                            update_weight_n (9, dpp->weight_B, sam_B, right);

                            dpp->samples_A [k] = left = left2;
                            dpp->samples_B [k] = right = right2;
                        }
                        else if (dpp->term == -1) {
                            left2 = left + apply_weight_n (9, dpp->weight_A, dpp->samples_A [0]);
                            update_weight_n (9, dpp->weight_A, dpp->samples_A [0], left);
                            left = left2;
                            right2 = right + apply_weight_n (9, dpp->weight_B, left);
                            update_weight_n (9, dpp->weight_B, left, right);
                            dpp->samples_A [0] = right = right2;
                        }
                        else {
                            right2 = right + apply_weight_n (9, dpp->weight_A, dpp->samples_A [0]);
                            update_weight_n (9, dpp->weight_A, dpp->samples_A [0], right);
                            right = right2;
                            left2 = left + apply_weight_n (9, dpp->weight_B, right);
                            update_weight_n (9, dpp->weight_B, right, left);
                            dpp->samples_A [0] = left = left2;
                        }
                }
                else {
                    for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++)
                        if (dpp->term > 0) {
                            int32_t sam_A = dpp->samples_A [m], sam_B = dpp->samples_B [m];
                            int k = (m + dpp->term) & (MAX_TERM - 1);

                            left2 = apply_weight_n (8, dpp->weight_A, sam_A) + left;
                            right2 = apply_weight_n (8, dpp->weight_B, sam_B) + right;

                            update_weight_n (8, dpp->weight_A, sam_A, left);
                            update_weight_n (8, dpp->weight_B, sam_B, right);

                            dpp->samples_A [k] = left = left2;
                            dpp->samples_B [k] = right = right2;
                        }
                        else if (dpp->term == -1) {
                            left2 = left + apply_weight_n (8, dpp->weight_A, dpp->samples_A [0]);
                            update_weight_n (8, dpp->weight_A, dpp->samples_A [0], left);
                            left = left2;
                            right2 = right + apply_weight_n (8, dpp->weight_B, left);
                            update_weight_n (8, dpp->weight_B, left, right);
                            dpp->samples_A [0] = right = right2;
                        }
                        else {
                            right2 = right + apply_weight_n (8, dpp->weight_A, dpp->samples_A [0]);
                            update_weight_n (8, dpp->weight_A, dpp->samples_A [0], right);
                            right = right2;
                            left2 = left + apply_weight_n (8, dpp->weight_B, right);
                            update_weight_n (8, dpp->weight_B, right, left);
                            dpp->samples_A [0] = left = left2;
                        }
                }

                m = (m + 1) & (MAX_TERM - 1);

                if (flags & JOINT_STEREO) {
                    sum = (right << 1) | ((diff = left) & 1);
                    right = (sum - diff) >> 1;
                    left = (sum + diff) >> 1;
                }

                if (flags & OVER_20) {
                    if (wps->dc.extra_bits_count < 8 || !getbit (&wps->wvbits)) {
                        getbits (&extra_bits, 8, &wps->wvbits);

                        if ((extra_bits &= 0xff) != wps->dc.last_extra_bits) {
                            wps->dc.last_extra_bits = extra_bits;
                            wps->dc.extra_bits_count = 0;
                        }
                        else
                            ++wps->dc.extra_bits_count;
                    }

                    crc = crc * 3 + (*bptr++ = left = (left << 4) + (wps->dc.last_extra_bits >> 4));
                    crc = crc * 3 + (*bptr++ = right = (right << 4) + (wps->dc.last_extra_bits & 0xf));
                }
                else {
                    crc = crc * 9 + left * 3 + right;
                    *bptr++ = left << shift;
                    *bptr++ = right << shift;
                }
            }
        }
        else
            for (bptr = buffer, i = 0; i < sample_count; ++i) {
                int32_t sum, left, right, left2, right2, extra_bits;

                read_word = get_word3 (wps, 0);

                if (read_word == WORD_EOF)
                    break;

                if (sum_level <= right_level && sum_level <= left_level) {
                    sum = (get_word3 (wps, 1) << 1) | (read_word & 1);
                    left = (sum + read_word) >> 1;
                    right = (sum - read_word) >> 1;
                }
                else if (left_level <= right_level) {
                    right = (left = get_word3 (wps, 1)) - read_word;
                    sum = left + right;
                }
                else {
                    left = read_word + (right = get_word3 (wps, 1));
                    sum = right + left;
                }

                sum_level = sum_level - (sum_level >> 8) + labs (sum >> 1);
                left_level = left_level - (left_level >> 8) + labs (left);
                right_level = right_level - (right_level >> 8) + labs (right);

                left2 = sample [0] [0] + ((sample [0] [1] * weight [0] [0] + 128) >> 8) + left;
                right2 = sample [1] [0] + ((sample [1] [1] * weight [1] [0] + 128) >> 8) + right;

                if ((sample [0] [1] >= 0) == (left > 0)) {
                    if (weight [0] [0]++ == 256)
                        weight [0] [0]--;
                }
                else if (weight [0] [0]-- == 0)
                    weight [0] [0]++;

                if ((sample [1] [1] >= 0) == (right > 0)) {
                    if (weight [1] [0]++ == 256)
                        weight [1] [0]--;
                }
                else if (weight [1] [0]-- == 0)
                    weight [1] [0]++;

                sample [0] [0] += (sample [0] [1] = left2 - sample [0] [0]);
                sample [1] [0] += (sample [1] [1] = right2 - sample [1] [0]);

                if (flags & OVER_20) {
                    if (wps->dc.extra_bits_count < 8 || !getbit (&wps->wvbits)) {
                        getbits (&extra_bits, 8, &wps->wvbits);

                        if ((extra_bits &= 0xff) != wps->dc.last_extra_bits) {
                            wps->dc.last_extra_bits = extra_bits;
                            wps->dc.extra_bits_count = 0;
                        }
                        else
                            ++wps->dc.extra_bits_count;
                    }

                    crc = crc * 3 + (*bptr++ = left2 = (sample [0] [0] << 4) + (wps->dc.last_extra_bits >> 4));
                    crc = crc * 3 + (*bptr++ = right2 = (sample [1] [0] << 4) + (wps->dc.last_extra_bits & 0xf));
                }
                else {
                    crc = crc * 9 + sample [0] [0] * 3 + sample [1] [0];
                    *bptr++ = sample [0] [0] << shift;
                    *bptr++ = sample [1] [0] << shift;
                }
            }

        wps->dc.left_level = left_level;
        wps->dc.right_level = right_level;
        wps->dc.sum_level = sum_level;
        wps->dc.diff_level = diff_level;
    }

    //////////////// handle version 3 lossy/hybrid mono data //////////////////

    else if (wps->wphdr.version == 3 && wps->wphdr.bits && (flags & MONO_FLAG)) {
        if (flags & FAST_FLAG)
            for (bptr = buffer, i = 0; i < sample_count; ++i) {

                if ((read_word = get_word3 (wps, 0)) == WORD_EOF)
                    break;

                crc = crc * 3 + (sample [0] [0] += sample [0] [1] += read_word);

                if (sample [0] [0] < min_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] < -mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = min_shifted;
                }
                else if (sample [0] [0] > max_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] > mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = max_shifted;
                }
                else
                    *bptr++ = sample [0] [0] << shift;
            }
        else if (flags & (HIGH_FLAG | NEW_HIGH_FLAG))
            for (bptr = buffer, i = 0; i < sample_count; ++i) {
                int32_t temp;

                read_word = (flags & NEW_HIGH_FLAG) ?
                    get_word4 (wps, 0, correction) : get_word3 (wps, 0);

                if (read_word == WORD_EOF)
                    break;

                for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
                    int32_t sam = dpp->samples_A [m];

                    temp = apply_weight24 (dpp->weight_A, sam) + read_word;
                    update_weight2 (dpp->weight_A, sam, read_word);
                    dpp->samples_A [(m + dpp->term) & (MAX_TERM - 1)] = read_word = temp;
                }

                m = (m + 1) & (MAX_TERM - 1);

                if (flags & WVC_FLAG) {
                    if (flags & LOSSY_SHAPE) {
                        crc = crc * 3 + (read_word += correction [0] + wps->dc.error [0]);
                        wps->dc.error [0] = -correction [0];
                    }
                    else
                        crc = crc * 3 + (read_word += correction [0]);

                    *bptr++ = read_word << shift;
                }
                else {
                    crc = crc * 3 + read_word;

                    if (read_word < min_value) {
#if ATTEMPT_ERROR_MUTING
                        if (read_word < -mute_limit)
                            mute_block = 1;
#endif
                        *bptr++ = min_shifted;
                    }
                    else if (read_word > max_value) {
#if ATTEMPT_ERROR_MUTING
                        if (read_word > mute_limit)
                            mute_block = 1;
#endif
                        *bptr++ = max_shifted;
                    }
                    else
                        *bptr++ = read_word << shift;
                }
            }
        else
            for (bptr = buffer, i = 0; i < sample_count; ++i) {
                int32_t new_sample;

                if ((read_word = get_word3 (wps, 0)) == WORD_EOF)
                    break;

                new_sample = sample [0] [0] + ((sample [0] [1] * weight [0] [0] + 128) >> 8) + read_word;

                if ((sample [0] [1] >= 0) == (read_word > 0)) {
                    if (weight [0] [0]++ == 256)
                        weight [0] [0]--;
                }
                else if (weight [0] [0]-- == 0)
                    weight [0] [0]++;

                sample [0] [1] = new_sample - sample [0] [0];
                crc = crc * 3 + (sample [0] [0] = new_sample);

                if (sample [0] [0] < min_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] < -mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = min_shifted;
                }
                else if (sample [0] [0] > max_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] > mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = max_shifted;
                }
                else
                    *bptr++ = sample [0] [0] << shift;
            }
    }

    //////////////// handle version 3 lossy/hybrid stereo data ////////////////

    else if (wps->wphdr.version == 3 && wps->wphdr.bits && !(flags & MONO_FLAG)) {
        if (flags & FAST_FLAG)
            for (bptr = buffer, i = 0; i < sample_count; ++i) {

                if ((read_word = get_word3 (wps, 0)) == WORD_EOF)
                    break;

                crc = crc * 3 + (sample [0] [0] += sample [0] [1] += read_word);

                if (sample [0] [0] < min_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] < -mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = min_shifted;
                }
                else if (sample [0] [0] > max_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] > mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = max_shifted;
                }
                else
                    *bptr++ = sample [0] [0] << shift;

                crc = crc * 3 + (sample [1] [0] += sample [1] [1] += get_word3 (wps, 1));

                if (sample [1] [0] < min_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [1] [0] < -mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = min_shifted;
                }
                else if (sample [1] [0] > max_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [1] [0] > mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = max_shifted;
                }
                else
                    *bptr++ = sample [1] [0] << shift;
            }
        else if (flags & (HIGH_FLAG | NEW_HIGH_FLAG))
            for (bptr = buffer, i = 0; i < sample_count; ++i) {
                int32_t left, right, left2, right2, sum, diff;

                if (flags & NEW_HIGH_FLAG) {
                    left = get_word4 (wps, 0, correction);
                    right = get_word4 (wps, 1, correction + 1);
                }
                else {
                    left = get_word3 (wps, 0);
                    right = get_word3 (wps, 1);
                }

                if (left == WORD_EOF)
                    break;

                for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
                    int32_t sam_A = dpp->samples_A [m], sam_B = dpp->samples_B [m];
                    int k = (m + dpp->term) & (MAX_TERM - 1);

                    left2 = apply_weight24 (dpp->weight_A, sam_A) + left;
                    update_weight2 (dpp->weight_A, sam_A, left);
                    dpp->samples_A [k] = left = left2;

                    right2 = apply_weight24 (dpp->weight_B, sam_B) + right;
                    update_weight2 (dpp->weight_B, sam_B, right);
                    dpp->samples_B [k] = right = right2;
                }

                m = (m + 1) & (MAX_TERM - 1);

                if (flags & WVC_FLAG) {
                    if (flags & LOSSY_SHAPE) {
                        left += correction [0] + wps->dc.error [0];
                        right += correction [1] + wps->dc.error [1];
                        wps->dc.error [0] = -correction [0];
                        wps->dc.error [1] = -correction [1];
                    }
                    else {
                        left += correction [0];
                        right += correction [1];
                    }
                }

                if (flags & JOINT_STEREO) {
                    right = ((sum = (right << 1) | (left & 1)) - (diff = left)) >> 1;
                    left = (sum + diff) >> 1;
                }

                crc = crc * 9 + left * 3 + right;

                if (flags & WVC_FLAG) {
                    *bptr++ = left << shift;
                    *bptr++ = right << shift;
                }
                else {
                    if (left < min_value) {
#if ATTEMPT_ERROR_MUTING
                        if (left < -mute_limit)
                            mute_block = 1;
#endif
                        *bptr++ = min_shifted;
                    }
                    else if (left > max_value) {
#if ATTEMPT_ERROR_MUTING
                        if (left > mute_limit)
                            mute_block = 1;
#endif
                        *bptr++ = max_shifted;
                    }
                    else
                        *bptr++ = left << shift;

                    if (right < min_value) {
#if ATTEMPT_ERROR_MUTING
                        if (right < -mute_limit)
                            mute_block = 1;
#endif
                        *bptr++ = min_shifted;
                    }
                    else if (right > max_value) {
#if ATTEMPT_ERROR_MUTING
                        if (right > mute_limit)
                            mute_block = 1;
#endif
                        *bptr++ = max_shifted;
                    }
                    else
                        *bptr++ = right << shift;
                }
            }
        else
            for (bptr = buffer, i = 0; i < sample_count; ++i) {
                int32_t new_sample;

                if ((read_word = get_word3 (wps, 0)) == WORD_EOF)
                    break;

                new_sample = sample [0] [0] + ((sample [0] [1] * weight [0] [0] + 128) >> 8) + read_word;

                if ((sample [0] [1] >= 0) == (read_word > 0)) {
                    if (weight [0] [0]++ == 256)
                        weight [0] [0]--;
                }
                else if (weight [0] [0]-- == 0)
                    weight [0] [0]++;

                sample [0] [1] = new_sample - sample [0] [0];
                crc = crc * 3 + (sample [0] [0] = new_sample);

                read_word = get_word3 (wps, 1);
                new_sample = sample [1] [0] + ((sample [1] [1] * weight [1] [0] + 128) >> 8) + read_word;

                if ((sample [1] [1] >= 0) == (read_word > 0)) {
                    if (weight [1] [0]++ == 256)
                        weight [1] [0]--;
                }
                else if (weight [1] [0]-- == 0)
                    weight [1] [0]++;

                sample [1] [1] = new_sample - sample [1] [0];
                crc = crc * 3 + (sample [1] [0] = new_sample);

                if (sample [0] [0] < min_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] < -mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = min_shifted;
                }
                else if (sample [0] [0] > max_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] > mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = max_shifted;
                }
                else
                    *bptr++ = sample [0] [0] << shift;

                if (sample [1] [0] < min_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [1] [0] < -mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = min_shifted;
                }
                else if (sample [1] [0] > max_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [1] [0] > mute_limit)
                        mute_block = 1;
#endif
                    *bptr++ = max_shifted;
                }
                else
                    *bptr++ = sample [1] [0] << shift;
            }
    }

    //////////////////// finally, handle version 2 data ///////////////////////

    else if (wps->wphdr.version == 2 && (flags & MONO_FLAG))
        for (bptr = buffer, i = 0; i < sample_count; ++i) {
            if ((read_word = get_word2 (wps, 0)) == WORD_EOF)
                break;

            sample [0] [0] += sample [0] [1] += read_word;

            if (wps->wphdr.bits) {
                if (sample [0] [0] < min_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] < -mute_limit)
                        mute_block = 1;
#endif
                    sample [0] [0] = min_value;
                }
                else if (sample [0] [0] > max_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] > mute_limit)
                        mute_block = 1;
#endif
                    sample [0] [0] = max_value;
                }
            }

            *bptr++ = sample [0] [0] << shift;
        }
    else if (wps->wphdr.version < 3 && !(flags & MONO_FLAG))
        for (bptr = buffer, i = 0; i < sample_count; ++i) {
            int32_t sum, diff;

            read_word = get_word2 (wps, 0);

            if (read_word == WORD_EOF)
                break;

            sum = (read_word << 1) | ((diff = get_word2 (wps, 1)) & 1);
            sample [0] [0] += sample [0] [1] += ((sum + diff) >> 1);
            sample [1] [0] += sample [1] [1] += ((sum - diff) >> 1);

            if (wps->wphdr.bits) {
                if (sample [0] [0] < min_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] < -mute_limit)
                        mute_block = 1;
#endif
                    sample [0] [0] = min_value;
                }
                else if (sample [0] [0] > max_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [0] [0] > mute_limit)
                        mute_block = 1;
#endif
                    sample [0] [0] = max_value;
                }

                if (sample [1] [0] < min_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [1] [0] < -mute_limit)
                        mute_block = 1;
#endif
                    sample [1] [0] = min_value;
                }
                else if (sample [1] [0] > max_value) {
#if ATTEMPT_ERROR_MUTING
                    if (sample [1] [0] > mute_limit)
                        mute_block = 1;
#endif
                    sample [1] [0] = max_value;
                }
            }

            *bptr++ = sample [0] [0] << shift;
            *bptr++ = sample [1] [0] << shift;
        }
    else
        i = 0;  /* can't get here, but suppresses warning */

#if ATTEMPT_ERROR_MUTING
    if (!wps->wphdr.bits || (flags & WVC_FLAG)) {
        int32_t *eptr = buffer + sample_count * ((flags & MONO_FLAG) ? 1 : 2);

        for (bptr = buffer; bptr < eptr; bptr += 3)
            if (*bptr > mute_limit || *bptr < -mute_limit) {
                mute_block = 1;
                break;
            }
    }

    if (mute_block)
        memset (buffer, 0, sizeof (*buffer) * sample_count * ((flags & MONO_FLAG) ? 1 : 2));
#endif

    if (i && (wps->sample_index += i) == wpc->total_samples) {

        if (wps->wphdr.version == 3 && crc != (wpc->wvc_flag ? wps->wphdr.crc2 : wps->wphdr.crc))
            wpc->crc_errors++;

        if (wpc->open_flags & OPEN_WRAPPER) {
            uint8_t *temp = (uint8_t *)malloc (1024);
            uint32_t bcount;

            if (bs_unused_bytes (&wps->wvbits)) {
                wpc->wrapper_data = (uint8_t *)realloc (wpc->wrapper_data, wpc->wrapper_bytes + bs_unused_bytes (&wps->wvbits));
                memcpy (wpc->wrapper_data + wpc->wrapper_bytes, bs_unused_data (&wps->wvbits), bs_unused_bytes (&wps->wvbits));
                wpc->wrapper_bytes += bs_unused_bytes (&wps->wvbits);
            }

            while (1) {
                bcount = wpc->reader->read_bytes (wpc->wv_in, temp, 1024);

                if (!bcount)
                    break;

                wpc->wrapper_data = (uint8_t *)realloc (wpc->wrapper_data, wpc->wrapper_bytes + bcount);
                memcpy (wpc->wrapper_data + wpc->wrapper_bytes, temp, bcount);
                wpc->wrapper_bytes += bcount;
            }

            free (temp);

            if (wpc->wrapper_bytes > 16) {
                int c;

                for (c = 0; c < 16 && wpc->wrapper_data [c] == 0xff; ++c);

                if (c == 16) {
                    memmove (wpc->wrapper_data, wpc->wrapper_data + 16, wpc->wrapper_bytes - 16);
                    wpc->wrapper_bytes -= 16;
                }
                else {
                    free (wpc->wrapper_data);
                    wpc->wrapper_data = nullptr;
                    wpc->wrapper_bytes = 0;
                }
            }
        }
    }

    memcpy (wps->dc.sample, sample, sizeof (sample));
    memcpy (wps->dc.weight, weight, sizeof (weight));
    wps->dc.crc = crc;
    wps->dc.m = m;

    return i;
}

// This function initializes everything required to receive words with this
// module and must be called BEFORE any other function in this module.

static void init_words3 (WavpackStream3 *wps)
{
    CLEAR (wps->w1);
    CLEAR (wps->w2);
    CLEAR (wps->w3);
    CLEAR (wps->w4);

    if (wps->wphdr.flags & MONO_FLAG)
        wps->w4.bitrate = wps->wphdr.bits - 768;
    else
        wps->w4.bitrate = (wps->wphdr.bits / 2) - 768;
}

static int32_t FASTCALL get_word1 (WavpackStream3 *wps, int chan)
{
    uint32_t tmp1, tmp2, avalue;
    unsigned int ones_count;
    int k;

    if ((wps->wphdr.flags & EXTREME_DECORR) && !(wps->wphdr.flags & OVER_20)) {
        if (wps->w1.zeros_acc) {
            if (--wps->w1.zeros_acc)
                return 0;
        }
        else if (wps->w1.ave_level [0] [0] < 0x20 && wps->w1.ave_level [0] [1] < 0x20) {
            int32_t mask;
            int cbits;

            for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);

            if (cbits == 33)
                return WORD_EOF;

            if (cbits < 2)
                wps->w1.zeros_acc = cbits;
            else {
                for (mask = 1, wps->w1.zeros_acc = 0; --cbits; mask <<= 1)
                    if (getbit (&wps->wvbits))
                        wps->w1.zeros_acc |= mask;

                wps->w1.zeros_acc |= mask;
            }

            if (wps->w1.zeros_acc)
                return 0;
        }
    }

    // count consecutive ones in bitstream, > 25 indicates error (or EOF)

    for (ones_count = 0; ones_count < 25 && getbit (&wps->wvbits); ++ones_count);

    if (ones_count == 25)
        return WORD_EOF;

    k = (wps->w1.ave_level [0] [chan] + (wps->w1.ave_level [0] [chan] >> 3) + 0x40) >> 7;
    k = count_bits (k);

    if (k & ~31)
        return WORD_EOF;

    if (ones_count == 0) {
        getbits (&avalue, k, &wps->wvbits);
        avalue &= bitmask [k];
    }
    else {
        tmp1 = bitset [k];
        k = (wps->w1.ave_level [1] [chan] + (wps->w1.ave_level [1] [chan] >> 4) + 0x20) >> 6;
        k = count_bits (k);

        if (k & ~31)
            return WORD_EOF;

        if (ones_count == 1) {
            getbits (&avalue, k, &wps->wvbits);
            avalue &= bitmask [k];
        }
        else {
            tmp2 = bitset [k];

            // If the ones count is exactly 24, then next 24 bits are literal

            if (ones_count == 24) {
                getbits (&avalue, 24, &wps->wvbits);
                avalue &= 0xffffff;
            }
            else {
                k = (wps->w1.ave_level [2] [chan] + 0x10) >> 5;
                k = count_bits (k);

                if (k & ~31)
                    return WORD_EOF;

                getbits (&avalue, k, &wps->wvbits);
                avalue = (avalue & bitmask [k]) + (bitset [k] * (ones_count - 2));
            }

            wps->w1.ave_level [2] [chan] -= ((wps->w1.ave_level [2] [chan] + 0x8) >> 4);
            wps->w1.ave_level [2] [chan] += avalue;
            avalue += tmp2;
        }

        wps->w1.ave_level [1] [chan] -= ((wps->w1.ave_level [1] [chan] + 0x10) >> 5);
        wps->w1.ave_level [1] [chan] += avalue;
        avalue += tmp1;
    }

    wps->w1.ave_level [0] [chan] -= ((wps->w1.ave_level [0] [chan] + 0x20) >> 6);
    wps->w1.ave_level [0] [chan] += avalue;

    return (avalue && getbit (&wps->wvbits)) ? -(int32_t)avalue : avalue;
}

#define NUM_SAMPLES 128

static int32_t FASTCALL get_old_word1 (WavpackStream3 *wps, int chan)
{
    uint32_t avalue;
    unsigned int bc;
    int k;

    if (!wps->w1.index [chan]) {

        int guess_k = (wps->w1.ave_k [chan] + 128) >> 8, ones;

        for (ones = 0; ones < 72 && getbit (&wps->wvbits); ++ones);

        if (ones == 72)
            return WORD_EOF;

        if (ones % 3 == 1)
            wps->w1.k_value [chan] = guess_k - (ones / 3) - 1;
        else
            wps->w1.k_value [chan] = guess_k + ones - ((ones + 1) / 3);

        wps->w1.ave_k [chan] -= (wps->w1.ave_k [chan] + 0x10) >> 5;
        wps->w1.ave_k [chan] += wps->w1.k_value [chan] << 3;
    }

    if (++wps->w1.index [chan] == NUM_SAMPLES)
        wps->w1.index [chan] = 0;

    k = wps->w1.k_value [chan];
    getbits (&avalue, k, &wps->wvbits);

    for (bc = 0; bc < 32 && getbit (&wps->wvbits); ++bc);

    if (bc == 32 || (k & ~31))
        return WORD_EOF;

    avalue = (avalue & bitmask [k]) + bitset [k] * bc;
    return (avalue && getbit (&wps->wvbits)) ? -(int32_t)avalue : avalue;
}

static int32_t FASTCALL get_word2 (WavpackStream3 *wps, int chan)
{
    int cbits, delta_dbits, dbits;
    int32_t value, mask = 1;

    cbits = 0;

    while (getbit (&wps->wvbits))
        if ((cbits += 2) == 50)
            return WORD_EOF;

    if (getbit (&wps->wvbits))
        cbits++;

    if (cbits == 0)
        delta_dbits = 0;
    else if (cbits & 1) {
        delta_dbits = (cbits + 1) / 2;

        if (wps->w2.last_delta_sign [chan] > 0)
            delta_dbits *= -1;

        wps->w2.last_delta_sign [chan] = delta_dbits;
    }
    else {
        delta_dbits = cbits / 2;

        if (wps->w2.last_delta_sign [chan] <= 0)
            delta_dbits *= -1;
    }

    dbits = (wps->w2.last_dbits [chan] += delta_dbits);

    if (dbits < 0 || dbits > 20)
        return WORD_EOF;

    if (!dbits)
        return 0L;

    if (wps->wphdr.bits) {
        for (value = 1L << (dbits - 1); --dbits; mask <<= 1)
            if (dbits < wps->wphdr.bits && getbit (&wps->wvbits))
                value |= mask;
    }
    else
        for (value = 1L << (dbits - 1); --dbits; mask <<= 1)
            if (getbit (&wps->wvbits))
                value |= mask;

    return getbit (&wps->wvbits) ? -(int32_t)value : value;
}

static int32_t FASTCALL get_word3 (WavpackStream3 *wps, int chan)
{
    int cbits, delta_dbits, dbits;
    int32_t value;

    for (cbits = 0; cbits < 72 && getbit (&wps->wvbits); ++cbits);

    if (cbits == 72)
        return WORD_EOF;

    if (cbits || getbit (&wps->wvbits))
        ++cbits;

    if (!((cbits + 1) % 3))
        delta_dbits = (cbits + 1) / 3;
    else
        delta_dbits = -(cbits - cbits / 3);

    if (chan) {
        dbits = (wps->w3.ave_dbits [1] >> 8) + 1 + delta_dbits;
        wps->w3.ave_dbits [1] -= (wps->w3.ave_dbits [1] + 0x10) >> 5;
        wps->w3.ave_dbits [1] += dbits << 3;
    }
    else {
        dbits = (wps->w3.ave_dbits [0] >> 8) + 1 + delta_dbits;
        wps->w3.ave_dbits [0] -= (wps->w3.ave_dbits [0] + 0x10) >> 5;
        wps->w3.ave_dbits [0] += dbits << 3;
    }

    if (dbits < 0 || dbits > 24)
        return WORD_EOF;

    if (!dbits)
        return 0L;

    if (wps->wphdr.bits && dbits > wps->wphdr.bits) {
        getbits (&value, wps->wphdr.bits, &wps->wvbits);

        if (value & bitset [wps->wphdr.bits - 1])
            return -(int32_t)(value & bitmask [wps->wphdr.bits]) << (dbits - wps->wphdr.bits);
        else
            return ((value & bitmask [wps->wphdr.bits - 1]) | bitset [wps->wphdr.bits - 1]) << (dbits - wps->wphdr.bits);
    }
    else {
        getbits (&value, dbits, &wps->wvbits);

        if (value & bitset [dbits - 1])
            return -(int32_t)(value & bitmask [dbits]);
        else
            return (value & bitmask [dbits - 1]) | bitset [dbits - 1];
    }
}

static int FASTCALL wp3_log2 (uint32_t avalue);

static int32_t FASTCALL get_word4 (WavpackStream3 *wps, int chan, int32_t *correction)
{
    uint32_t base, ones_count, avalue;
    int32_t value, low, mid, high;
    int bitcount;

    // count consecutive ones in bitstream, > 25 indicates error (or EOF)

    for (ones_count = 0; ones_count < 25 && getbit (&wps->wvbits); ++ones_count);

    if (ones_count == 25)
        return WORD_EOF;

    // if the ones count is exactly 24, then we switch to non-unary method

    if (ones_count == 24) {
        int32_t mask;
        int cbits;

        for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);

        if (cbits == 33)
            return WORD_EOF;

        if (cbits < 2)
            ones_count = cbits;
        else {
            for (mask = 1, ones_count = 0; --cbits; mask <<= 1)
                if (getbit (&wps->wvbits))
                    ones_count |= mask;

            ones_count |= mask;
        }

        ones_count += 24;
    }

    if (!chan) {
        int slow_log_0, slow_log_1, balance;

        if (wps->wphdr.flags & MONO_FLAG) {
            wps->w4.bits_acc [0] += wps->w4.bitrate + wp3_log2 (wps->w4.fast_level [0]) - wp3_log2 (wps->w4.slow_level [0]) + (3 << 8);

            if (wps->w4.bits_acc [0] < 0)
                wps->w4.bits_acc [0] = 0;
        }
        else {
            slow_log_0 = wp3_log2 (wps->w4.slow_level [0]);
            slow_log_1 = wp3_log2 (wps->w4.slow_level [1]);

            if (wps->wphdr.flags & JOINT_STEREO)
                balance = (slow_log_1 - slow_log_0 + 257) >> 1;
            else
                balance = (slow_log_1 - slow_log_0 + 1) >> 1;

            wps->w4.bits_acc [0] += wps->w4.bitrate - balance + wp3_log2 (wps->w4.fast_level [0]) - slow_log_0 + (3 << 8);
            wps->w4.bits_acc [1] += wps->w4.bitrate + balance + wp3_log2 (wps->w4.fast_level [1]) - slow_log_1 + (3 << 8);

            if (wps->w4.bits_acc [0] + wps->w4.bits_acc [1] < 0)
                wps->w4.bits_acc [0] = wps->w4.bits_acc [1] = 0;
            else if (wps->w4.bits_acc [0] < 0) {
                wps->w4.bits_acc [1] += wps->w4.bits_acc [0];
                wps->w4.bits_acc [0] = 0;
            }
            else if (wps->w4.bits_acc [1] < 0) {
                wps->w4.bits_acc [0] += wps->w4.bits_acc [1];
                wps->w4.bits_acc [1] = 0;
            }
        }
    }

    base = (wps->w4.fast_level [chan] + 48) / 96;
    bitcount = wps->w4.bits_acc [chan] >> 8;
    wps->w4.bits_acc [chan] &= 0xff;

    if (!base) {
        if (ones_count)
            high = low = mid = (getbit (&wps->wvbits)) ? -(int32_t)ones_count : ones_count;
        else
            high = low = mid = 0;
    }
    else {
        mid = (ones_count * 2 + 1) * base;
        if (getbit (&wps->wvbits)) mid = -mid;
        low = mid - base;
        high = mid + base - 1;

        while (bitcount--) {
            if (getbit (&wps->wvbits))
                mid = (high + (low = mid) + 1) >> 1;
            else
                mid = ((high = mid - 1) + low + 1) >> 1;

            if (high == low)
                break;
        }
    }

    wps->w4.fast_level [chan] -= ((wps->w4.fast_level [chan] + 0x10) >> 5);
    wps->w4.fast_level [chan] += (avalue = labs (mid));
    wps->w4.slow_level [chan] -= ((wps->w4.slow_level [chan] + 0x80) >> 8);
    wps->w4.slow_level [chan] += avalue;

    if (bs_is_open (&wps->wvcbits)) {

        if (high != low) {
            uint32_t maxcode = high - low;
            int bitcount = count_bits (maxcode);
            uint32_t extras = (1L << bitcount) - maxcode - 1;

            getbits (&avalue, bitcount - 1, &wps->wvcbits);
            avalue &= bitmask [bitcount - 1];

            if (avalue >= extras) {
                avalue = (avalue << 1) - extras;

                if (getbit (&wps->wvcbits))
                    ++avalue;
            }

            value = (mid < 0) ? high - avalue : avalue + low;

            if (correction)
                *correction = value - mid;
        }
        else if (correction)
            *correction = 0;
    }

    return mid;
}

// This function calculates an approximate base-2 logarithm (with 8 bits of
// fraction) from the supplied value. Using logarithms makes comparing
// signal level values and calculating fractional bitrates much easier.

static int FASTCALL wp3_log2 (uint32_t avalue)
{
    int dbits;

    if ((avalue += avalue >> 9) < (1 << 8)) {
        dbits = nbits_table [avalue];
        return (dbits << 8) + ((avalue << (9 - dbits)) & 0xff);
    }
    else {
        if (avalue < (1L << 16))
            dbits = nbits_table [avalue >> 8] + 8;
        else if (avalue < (1L << 24))
            dbits = nbits_table [avalue >> 16] + 16;
        else
            dbits = nbits_table [avalue >> 24] + 24;

        return (dbits << 8) + ((avalue >> (dbits - 9)) & 0xff);
    }
}

static void bs_read3 (Bitstream3 *bs)
{
    uint32_t bytes_read;

    bytes_read = bs->reader->read_bytes (bs->id, bs->buf, bs->bufsiz);
    bs->end = bs->buf + bytes_read;
    bs->fpos += bytes_read;

    if (bs->end == bs->buf) {
        memset (bs->buf, -1, bs->bufsiz);
        bs->end += bs->bufsiz;
    }

    bs->ptr = bs->buf;
}

// Open the specified BitStream and associate with the specified file. The
// "bufsiz" field of the structure must be preset with the desired buffer
// size and the file's read pointer must be set to where the desired bit
// data is located.  A return value of true indicates an error in
// allocating buffer space.

static int bs_open_read3 (Bitstream3 *bs, WavpackStreamReader64 *reader, void *id)
{
    bs->fpos = (bs->reader = reader)->get_pos (bs->id = id);

    if (!bs->buf)
        bs->buf = (uint8_t *) malloc (bs->bufsiz);

    bs->end = bs->buf + bs->bufsiz;
    bs->ptr = bs->end - 1;
    bs->sr = bs->bc = 0;
    bs->error = bs->buf ? 0 : 1;
    bs->wrap = bs_read3;
    return bs->error;
}

static uint32_t bs_unused_bytes (Bitstream3 *bs)
{
    if (bs->bc < 8) {
        bs->bc += 8;
        bs->ptr++;
    }

    return (uint32_t)(bs->end - bs->ptr);
}

static uint8_t *bs_unused_data (Bitstream3 *bs)
{
    if (bs->bc < 8) {
        bs->bc += 8;
        bs->ptr++;
    }

    return bs->ptr;
}

#endif  // ENABLE_LEGACY


#if ENABLE_LEGACY
#if ! NO_SEEKING

static void *unpack_restore (WavpackStream3 *wps, void *source, int keep_resources);
static void bs_restore3 (Bitstream3 *bs);

// This is an extension for WavpackSeekSample (). Note that because WavPack
// files created prior to version 4.0 are not inherently seekable, this
// function could take a long time if a forward seek is requested to an
// area that has not been played (or seeked through) yet.

int seek_sample3 (WavpackContext *wpc, uint32_t desired_index)
{
    int points_index = desired_index / (((uint32_t) wpc->total_samples >> 8) + 1);
    WavpackStream3 *wps = (WavpackStream3 *) wpc->stream3;

    if (desired_index >= wpc->total_samples)
        return false;

    while (points_index)
        if (wps->index_points [points_index].saved &&
            wps->index_points [points_index].sample_index <= desired_index)
                break;
        else
            points_index--;

    if (wps->index_points [points_index].saved)
        if (wps->index_points [points_index].sample_index > wps->sample_index ||
            wps->sample_index > desired_index) {
                wps->sample_index = wps->index_points [points_index].sample_index;
                unpack_restore (wps, wps->unpack_data + points_index * wps->unpack_size, true);
        }

    if (desired_index > wps->sample_index) {
        int32_t *buffer = (int32_t *) malloc (1024 * (wps->wphdr.flags & MONO_FLAG ? 4 : 8));
        uint32_t samples_to_skip = desired_index - wps->sample_index;

        while (1) {
            if (samples_to_skip > 1024) {
                if (unpack_samples3 (wpc, buffer, 1024) == 1024)
                    samples_to_skip -= 1024;
                else
                    break;
            }
            else {
                samples_to_skip -= unpack_samples3 (wpc, buffer, samples_to_skip);
                break;
            }
        }

        free (buffer);

        if (samples_to_skip)
            return false;
    }

    return true;
}

// This function restores the unpacking context from the specified pointer
// and returns the updated pointer. After this call, unpack_samples() will
// continue where it left off immediately before unpack_save() was called.
// If the WavPack files and bitstreams might have been closed and reopened,
// then the "keep_resources" flag should be set to avoid using the "old"
// resources that were originally saved (and are probably now invalid).

static void *unpack_restore (WavpackStream3 *wps, void *source, int keep_resources)
{
    int flags = wps->wphdr.flags, tcount;
    struct decorr_pass *dpp;
    FILE *temp_file;
    uint8_t *temp_buf;

    unpack_init3 (wps);
    temp_file = wps->wvbits.id;
    temp_buf = wps->wvbits.buf;
    RESTORE (wps->wvbits, source);

    if (keep_resources) {
        wps->wvbits.id = temp_file;
        wps->wvbits.ptr += temp_buf - wps->wvbits.buf;
        wps->wvbits.end += temp_buf - wps->wvbits.buf;
        wps->wvbits.buf = temp_buf;
    }

    bs_restore3 (&wps->wvbits);

    if (flags & WVC_FLAG) {
        temp_file = wps->wvcbits.id;
        temp_buf = wps->wvcbits.buf;
        RESTORE (wps->wvcbits, source);

        if (keep_resources) {
            wps->wvcbits.id = temp_file;
            wps->wvcbits.ptr += temp_buf - wps->wvcbits.buf;
            wps->wvcbits.end += temp_buf - wps->wvcbits.buf;
            wps->wvcbits.buf = temp_buf;
        }

        bs_restore3 (&wps->wvcbits);
    }

    if (wps->wphdr.version == 3) {
        if (wps->wphdr.bits) {
            RESTORE (wps->w4, source);
        }
        else {
            RESTORE (wps->w1, source);
        }

        RESTORE (wps->w3, source);
        RESTORE (wps->dc.crc, source);
    }
    else
        RESTORE (wps->w2, source);

    if (wps->wphdr.bits) {
        RESTORE (wps->dc.error, source);
    }
    else {
        RESTORE (wps->dc.sum_level, source);
        RESTORE (wps->dc.left_level, source);
        RESTORE (wps->dc.right_level, source);
        RESTORE (wps->dc.diff_level, source);
    }

    if (flags & OVER_20) {
        RESTORE (wps->dc.last_extra_bits, source);
        RESTORE (wps->dc.extra_bits_count, source);
    }

    if (!(flags & EXTREME_DECORR)) {
        RESTORE (wps->dc.sample, source);
        RESTORE (wps->dc.weight, source);
    }

    if (flags & (HIGH_FLAG | NEW_HIGH_FLAG))
        for (tcount = wps->num_terms, dpp = wps->decorr_passes; tcount--; dpp++) {
            if (dpp->term > 0) {
                int count = dpp->term;
                int index = wps->dc.m;

                RESTORE (dpp->weight_A, source);

                while (count--) {
                    RESTORE (dpp->samples_A [index], source);
                    index = (index + 1) & (MAX_TERM - 1);
                }

                if (!(flags & MONO_FLAG)) {
                    count = dpp->term;
                    index = wps->dc.m;

                    RESTORE (dpp->weight_B, source);

                    while (count--) {
                        RESTORE (dpp->samples_B [index], source);
                        index = (index + 1) & (MAX_TERM - 1);
                    }
                }
            }
            else {
                RESTORE (dpp->weight_A, source);
                RESTORE (dpp->weight_B, source);
                RESTORE (dpp->samples_A [0], source);
                RESTORE (dpp->samples_B [0], source);
            }
        }

    return source;
}

// This function is called after a call to unpack_restore() has restored
// the BitStream structure to a previous state and causes any required data
// to be read from the file. This function is NOT supported for overlapped
// operation.

static void bs_restore3 (Bitstream3 *bs)
{
    uint32_t bytes_to_read = (uint32_t)(bs->end - bs->ptr - 1), bytes_read;

    bs->reader->set_pos_abs (bs->id, bs->fpos - bytes_to_read);

    if (bytes_to_read > 0) {

        bytes_read = bs->reader->read_bytes (bs->id, bs->ptr + 1, bytes_to_read);

        if (bytes_to_read != bytes_read)
            bs->end = bs->ptr + 1 + bytes_read;
    }
}

#endif      // NO_SEEKING
#endif      // ENABLE_LEGACY


// This module provides an extension to the open_utils.c module for handling
// WavPack files prior to version 4.0, not including "raw" files. As these
// modes are all obsolete and are no longer written, this code will not be
// fully documented other than the global functions. However, full documentation
// is provided in the version 3.97 source code. Note that this module only
// provides the functionality of opening the files and obtaining information
// from them; the actual audio decoding is located in the unpack3.c module.

#if ENABLE_LEGACY

#define ATTEMPT_ERROR_MUTING

// This provides an extension to the WavpackOpenFileRead () function contained
// in the wputils.c module. It is assumed that an 'R' had been read as the
// first character of the file/stream (indicating a non-raw pre version 4.0
// WavPack file) and had been pushed back onto the stream (or simply seeked
// back to).

WavpackContext *open_file3 (WavpackContext *wpc, char *error)
{
    RiffChunkHeader RiffChunkHeader;
    ChunkHeader ChunkHeader;
    WavpackHeader3 wphdr;
    WavpackStream3 *wps;
    WaveHeader3 wavhdr;

    CLEAR (wavhdr);
    wpc->stream3 = wps = (WavpackStream3 *) malloc (sizeof (WavpackStream3));
    CLEAR (*wps);

    if (wpc->reader->read_bytes (wpc->wv_in, &RiffChunkHeader, sizeof (RiffChunkHeader)) !=
        sizeof (RiffChunkHeader)) {
            if (error) strcpy (error, "not a valid WavPack file!");
            return WavpackCloseFile (wpc);
    }

    if (!strncmp (RiffChunkHeader.ckID, "RIFF", 4) && !strncmp (RiffChunkHeader.formType, "WAVE", 4)) {

        if (wpc->open_flags & OPEN_WRAPPER) {
            wpc->wrapper_data = (uint8_t *)malloc (wpc->wrapper_bytes = sizeof (RiffChunkHeader));
            memcpy (wpc->wrapper_data, &RiffChunkHeader, sizeof (RiffChunkHeader));
        }

    // If the first chunk is a wave RIFF header, then read the various chunks
    // until we get to the "data" chunk (and WavPack header should follow). If
    // the first chunk is not a RIFF, then we assume a "raw" WavPack file and
    // the WavPack header must be first.

        while (1) {

            if (wpc->reader->read_bytes (wpc->wv_in, &ChunkHeader, sizeof (ChunkHeader)) !=
                sizeof (ChunkHeader)) {
                    if (error) strcpy (error, "not a valid WavPack file!");
                    return WavpackCloseFile (wpc);
            }
            else {
                if (wpc->open_flags & OPEN_WRAPPER) {
                    wpc->wrapper_data = (uint8_t *)realloc (wpc->wrapper_data, wpc->wrapper_bytes + sizeof (ChunkHeader));
                    memcpy (wpc->wrapper_data + wpc->wrapper_bytes, &ChunkHeader, sizeof (ChunkHeader));
                    wpc->wrapper_bytes += sizeof (ChunkHeader);
                }

                WavpackLittleEndianToNative (&ChunkHeader, ChunkHeaderFormat);

                if (!strncmp (ChunkHeader.ckID, "fmt ", 4)) {

                    if (ChunkHeader.ckSize < sizeof (wavhdr) ||
                        wpc->reader->read_bytes (wpc->wv_in, &wavhdr, sizeof (wavhdr)) != sizeof (wavhdr)) {
                            if (error) strcpy (error, "not a valid WavPack file!");
                            return WavpackCloseFile (wpc);
                    }
                    else if (wpc->open_flags & OPEN_WRAPPER) {
                        wpc->wrapper_data = (uint8_t *)realloc (wpc->wrapper_data, wpc->wrapper_bytes + sizeof (wavhdr));
                        memcpy (wpc->wrapper_data + wpc->wrapper_bytes, &wavhdr, sizeof (wavhdr));
                        wpc->wrapper_bytes += sizeof (wavhdr);
                    }

                    WavpackLittleEndianToNative (&wavhdr, WaveHeader3Format);

                    if (ChunkHeader.ckSize > sizeof (wavhdr)) {
                        uint32_t bytes_to_skip = (ChunkHeader.ckSize + 1 - sizeof (wavhdr)) & ~1L;

                        if (bytes_to_skip > 1024 * 1024) {
                            if (error) strcpy (error, "not a valid WavPack file!");
                            return WavpackCloseFile (wpc);
                        }

                        if (wpc->open_flags & OPEN_WRAPPER) {
                            wpc->wrapper_data = (uint8_t *)realloc (wpc->wrapper_data, wpc->wrapper_bytes + bytes_to_skip);
                            wpc->reader->read_bytes (wpc->wv_in, wpc->wrapper_data + wpc->wrapper_bytes, bytes_to_skip);
                            wpc->wrapper_bytes += bytes_to_skip;
                        }
                        else {
                            uint8_t *temp = (uint8_t *)malloc (bytes_to_skip);
                            wpc->reader->read_bytes (wpc->wv_in, temp, bytes_to_skip);
                            free (temp);
                        }
                    }
                }
                else if (!strncmp (ChunkHeader.ckID, "data", 4))
                    break;
                else if ((ChunkHeader.ckSize + 1) & ~1L) {
                    uint32_t bytes_to_skip = (ChunkHeader.ckSize + 1) & ~1L;

                    if (bytes_to_skip > 1024 * 1024) {
                        if (error) strcpy (error, "not a valid WavPack file!");
                        return WavpackCloseFile (wpc);
                    }

                    if (wpc->open_flags & OPEN_WRAPPER) {
                        wpc->wrapper_data = (uint8_t *)realloc (wpc->wrapper_data, wpc->wrapper_bytes + bytes_to_skip);
                        wpc->reader->read_bytes (wpc->wv_in, wpc->wrapper_data + wpc->wrapper_bytes, bytes_to_skip);
                        wpc->wrapper_bytes += bytes_to_skip;
                    }
                    else {
                        uint8_t *temp = (uint8_t *)malloc (bytes_to_skip);
                        wpc->reader->read_bytes (wpc->wv_in, temp, bytes_to_skip);
                        free (temp);
                    }
                }
            }
        }
    }
    else {
        if (error) strcpy (error, "not a valid WavPack file!");
        return WavpackCloseFile (wpc);
    }

    if (wavhdr.FormatTag != 1 || !wavhdr.NumChannels || wavhdr.NumChannels > 2 ||
        !wavhdr.SampleRate || wavhdr.BitsPerSample < 16 || wavhdr.BitsPerSample > 24 ||
        wavhdr.BlockAlign / wavhdr.NumChannels > 3 || wavhdr.BlockAlign % wavhdr.NumChannels ||
        wavhdr.BlockAlign / wavhdr.NumChannels < (wavhdr.BitsPerSample + 7) / 8) {
            if (error) strcpy (error, "not a valid WavPack file!");
            return WavpackCloseFile (wpc);
    }

    wpc->total_samples = ChunkHeader.ckSize / wavhdr.NumChannels /
        ((wavhdr.BitsPerSample > 16) ? 3 : 2);

    if (wpc->reader->read_bytes (wpc->wv_in, &wphdr, 10) != 10) {
        if (error) strcpy (error, "not a valid WavPack file!");
        return WavpackCloseFile (wpc);
    }

    if (((char *) &wphdr) [8] == 2 && (wpc->reader->read_bytes (wpc->wv_in, ((char *) &wphdr) + 10, 2) != 2)) {
        if (error) strcpy (error, "not a valid WavPack file!");
        return WavpackCloseFile (wpc);
    }
    else if (((char *) &wphdr) [8] == 3 && (wpc->reader->read_bytes (wpc->wv_in, ((char *) &wphdr) + 10,
        sizeof (wphdr) - 10) != sizeof (wphdr) - 10)) {
            if (error) strcpy (error, "not a valid WavPack file!");
            return WavpackCloseFile (wpc);
    }

    WavpackLittleEndianToNative (&wphdr, WavpackHeader3Format);

    // make sure this is a version we know about

    if (strncmp (wphdr.ckID, "wvpk", 4) || wphdr.version < 1 || wphdr.version > 3) {
        if (error) strcpy (error, "not a valid WavPack file!");
        return WavpackCloseFile (wpc);
    }

    // Because I ran out of flag bits in the WavPack header, an amazingly ugly
    // kludge was forced upon me! This code takes care of preparing the flags
    // field for internal use and checking for unknown formats we can't decode

    if (wphdr.version == 3) {

        if (wphdr.flags & EXTREME_DECORR) {

            if ((wphdr.flags & NOT_STORED_FLAGS) ||
                ((wphdr.bits) &&
                (((wphdr.flags & NEW_HIGH_FLAG) &&
                (wphdr.flags & (FAST_FLAG | HIGH_FLAG))) ||
                (wphdr.flags & CROSS_DECORR)))) {
                    if (error) strcpy (error, "not a valid WavPack file!");
                    return WavpackCloseFile (wpc);
            }

            if (wphdr.flags & CANCEL_EXTREME)
                wphdr.flags &= ~(EXTREME_DECORR | CANCEL_EXTREME);
        }
        else
            wphdr.flags &= ~CROSS_DECORR;
    }

    // check to see if we should look for a "correction" file, and if so try
    // to open it for reading, then set WVC_FLAG accordingly

    if (wpc->wvc_in && wphdr.version == 3 && wphdr.bits && (wphdr.flags & NEW_HIGH_FLAG)) {
        wpc->file2len = wpc->reader->get_length (wpc->wvc_in);
        wphdr.flags |= WVC_FLAG;
        wpc->wvc_flag = true;
    }
    else
        wphdr.flags &= ~WVC_FLAG;

    // check WavPack version to handle special requirements of versions
    // before 3.0 that had smaller headers

    if (wphdr.version < 3) {
        wphdr.total_samples = (int32_t) wpc->total_samples;
        wphdr.flags = wavhdr.NumChannels == 1 ? MONO_FLAG : 0;
        wphdr.shift = 16 - wavhdr.BitsPerSample;

        if (wphdr.version == 1)
            wphdr.bits = 0;
    }

    wpc->config.sample_rate = wavhdr.SampleRate;
    wpc->config.num_channels = wavhdr.NumChannels;
    wpc->config.channel_mask = 5 - wavhdr.NumChannels;

    if (wphdr.flags & MONO_FLAG)
        wpc->config.flags |= CONFIG_MONO_FLAG;

    if (wphdr.flags & EXTREME_DECORR)
        wpc->config.flags |= CONFIG_HIGH_FLAG;

    if (wphdr.bits) {
        if (wphdr.flags & NEW_HIGH_FLAG)
            wpc->config.flags |= CONFIG_HYBRID_FLAG;
        else
            wpc->config.flags |= CONFIG_LOSSY_MODE;
    }
    else if (!(wphdr.flags & HIGH_FLAG))
        wpc->config.flags |= CONFIG_FAST_FLAG;

    wpc->config.bytes_per_sample = (wphdr.flags & BYTES_3) ? 3 : 2;
    wpc->config.bits_per_sample = wavhdr.BitsPerSample;

    memcpy (&wps->wphdr, &wphdr, sizeof (wphdr));
    wps->wvbits.bufsiz = wps->wvcbits.bufsiz = 1024 * 1024;
    return wpc;
}


uint32_t get_sample_index3 (WavpackContext *wpc)
{
    WavpackStream3 *wps = (WavpackStream3 *) wpc->stream3;

    return (wps) ? wps->sample_index : (uint32_t) -1;
}

int get_version3 (WavpackContext *wpc)
{
    WavpackStream3 *wps = (WavpackStream3 *) wpc->stream3;

    return (wps) ? wps->wphdr.version : 0;
}

void free_stream3 (WavpackContext *wpc)
{
    WavpackStream3 *wps = (WavpackStream3 *) wpc->stream3;

    if (wps) {
#if ! NO_SEEKING
        if (wps->unpack_data)
            free (wps->unpack_data);
#endif
        if ((wps->wphdr.flags & WVC_FLAG) && wps->wvcbits.buf)
            free (wps->wvcbits.buf);

        if (wps->wvbits.buf)
            free (wps->wvbits.buf);

        free (wps);
    }
}

#endif  // ENABLE_LEGACY

uint32_t WavpackUnpackSamples (WavpackContext *wpc, int32_t *buffer, uint32_t samples)
{
    WavpackStream *wps = wpc->streams ? wpc->streams [wpc->current_stream = 0] : nullptr;
    int num_channels = wpc->config.num_channels, file_done = false;
    uint32_t bcount, samples_unpacked = 0, samples_to_unpack;
    int32_t *bptr = buffer;

    memset (buffer, 0, num_channels * samples * sizeof (int32_t));

#if ENABLE_LEGACY
    if (wpc->stream3)
        return unpack_samples3 (wpc, buffer, samples);
#endif

    while (samples) {

        // if the current block has no audio, or it's not the first block of a multichannel
        // sequence, or the sample we're on is past the last sample in this block...we need
        // to free up the streams and read the next block

        if (!wps->wphdr.block_samples || !(wps->wphdr.flags & INITIAL_BLOCK) ||
            wps->sample_index >= GET_BLOCK_INDEX (wps->wphdr) + wps->wphdr.block_samples) {

                int64_t nexthdrpos;

                if (wpc->wrapper_bytes >= MAX_WRAPPER_BYTES)
                    break;

                free_streams (wpc);
                nexthdrpos = wpc->reader->get_pos (wpc->wv_in);
                bcount = read_next_header (wpc->reader, wpc->wv_in, &wps->wphdr);

                if (bcount == (uint32_t) -1)
                    break;

                wpc->filepos = nexthdrpos + bcount;

                // allocate the memory for the entire raw block and read it in

                wps->blockbuff = (uint8_t *)malloc (wps->wphdr.ckSize + 8);

                if (!wps->blockbuff)
                    break;

                memcpy (wps->blockbuff, &wps->wphdr, 32);

                if (wpc->reader->read_bytes (wpc->wv_in, wps->blockbuff + 32, wps->wphdr.ckSize - 24) !=
                    wps->wphdr.ckSize - 24) {
                        strcpy (wpc->error_message, "can't read all of last block!");
                        wps->wphdr.block_samples = 0;
                        wps->wphdr.ckSize = 24;
                        break;
                }

                // render corrupt blocks harmless
                if (!WavpackVerifySingleBlock (wps->blockbuff, !(wpc->open_flags & OPEN_NO_CHECKSUM))) {
                    wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;
                    wps->wphdr.block_samples = 0;
                    memcpy (wps->blockbuff, &wps->wphdr, 32);
                }

                // potentially adjusting block_index must be done AFTER verifying block

                if (wpc->open_flags & OPEN_STREAMING)
                    SET_BLOCK_INDEX (wps->wphdr, wps->sample_index = 0);
                else
                    SET_BLOCK_INDEX (wps->wphdr, GET_BLOCK_INDEX (wps->wphdr) - wpc->initial_index);

                memcpy (wps->blockbuff, &wps->wphdr, 32);
                wps->init_done = false;     // we have not yet called unpack_init() for this block

                // if this block has audio, but not the sample index we were expecting, flag an error

                if (wps->wphdr.block_samples && wps->sample_index != GET_BLOCK_INDEX (wps->wphdr))
                    wpc->crc_errors++;

                // if this block has audio, and we're in hybrid lossless mode, read the matching wvc block

                if (wps->wphdr.block_samples && wpc->wvc_flag)
                    read_wvc_block (wpc);

                // if the block does NOT have any audio, call unpack_init() to process non-audio stuff

                if (!wps->wphdr.block_samples) {
                    if (!wps->init_done && !unpack_init (wpc))
                        wpc->crc_errors++;

                    wps->init_done = true;
                }
        }

        // if the current block has no audio, or it's not the first block of a multichannel
        // sequence, or the sample we're on is past the last sample in this block...we need
        // to loop back and read the next block

        if (!wps->wphdr.block_samples || !(wps->wphdr.flags & INITIAL_BLOCK) ||
            wps->sample_index >= GET_BLOCK_INDEX (wps->wphdr) + wps->wphdr.block_samples)
                continue;

        // There seems to be some missing data, like a block was corrupted or something.
        // If it's not too much data, just fill in with silence here and loop back.

        if (wps->sample_index < GET_BLOCK_INDEX (wps->wphdr)) {
            int32_t zvalue = (wps->wphdr.flags & DSD_FLAG) ? 0x55 : 0;

            samples_to_unpack = (uint32_t) (GET_BLOCK_INDEX (wps->wphdr) - wps->sample_index);

            if (!samples_to_unpack || samples_to_unpack > 262144) {
                strcpy (wpc->error_message, "discontinuity found, aborting file!");
                wps->wphdr.block_samples = 0;
                wps->wphdr.ckSize = 24;
                break;
            }

            if (samples_to_unpack > samples)
                samples_to_unpack = samples;

            wps->sample_index += samples_to_unpack;
            samples_unpacked += samples_to_unpack;
            samples -= samples_to_unpack;

            samples_to_unpack *= (wpc->reduced_channels ? wpc->reduced_channels : num_channels);

            while (samples_to_unpack--)
                *bptr++ = zvalue;

            continue;
        }

        // calculate number of samples to process from this block, then initialize the decoder for
        // this block if we haven't already

        samples_to_unpack = (uint32_t) (GET_BLOCK_INDEX (wps->wphdr) + wps->wphdr.block_samples - wps->sample_index);

        if (samples_to_unpack > samples)
            samples_to_unpack = samples;

        if (!wps->init_done && !unpack_init (wpc))
            wpc->crc_errors++;

        wps->init_done = true;

        // if this block is not the final block of a multichannel sequence (and we're not truncating
        // to stereo), then enter this conditional block...otherwise we just unpack the samples directly

        if (!wpc->reduced_channels && !(wps->wphdr.flags & FINAL_BLOCK)) {
            int32_t *temp_buffer = (int32_t *)calloc (1, samples_to_unpack * 8), *src, *dst;
            int offset = 0;     // offset to next channel in sequence (0 to num_channels - 1)
            uint32_t samcnt;

            // since we are getting samples from multiple bocks in a multichannel sequence, we must
            // allocate a temporary buffer to unpack to so that we can re-interleave the samples

            if (!temp_buffer)
                break;

            // loop through all the streams...

            while (1) {

                // if the stream has not been allocated and corresponding block read, do that here...

                if (wpc->current_stream == wpc->num_streams) {
                    wpc->streams = (WavpackStream **)realloc (wpc->streams, (wpc->num_streams + 1) * sizeof (wpc->streams [0]));

                    if (!wpc->streams)
                        break;

                    wps = wpc->streams [wpc->num_streams++] = (WavpackStream *)malloc (sizeof (WavpackStream));

                    if (!wps)
                        break;

                    CLEAR (*wps);
                    bcount = read_next_header (wpc->reader, wpc->wv_in, &wps->wphdr);

                    if (bcount == (uint32_t) -1) {
                        wpc->streams [0]->wphdr.block_samples = 0;
                        wpc->streams [0]->wphdr.ckSize = 24;
                        file_done = true;
                        break;
                    }

                    wps->blockbuff = (uint8_t *)malloc (wps->wphdr.ckSize + 8);

                    if (!wps->blockbuff)
                        break;

                    memcpy (wps->blockbuff, &wps->wphdr, 32);

                    if (wpc->reader->read_bytes (wpc->wv_in, wps->blockbuff + 32, wps->wphdr.ckSize - 24) !=
                        wps->wphdr.ckSize - 24) {
                            wpc->streams [0]->wphdr.block_samples = 0;
                            wpc->streams [0]->wphdr.ckSize = 24;
                            file_done = true;
                            break;
                    }

                    // render corrupt blocks harmless
                    if (!WavpackVerifySingleBlock (wps->blockbuff, !(wpc->open_flags & OPEN_NO_CHECKSUM))) {
                        wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;
                        wps->wphdr.block_samples = 0;
                        memcpy (wps->blockbuff, &wps->wphdr, 32);
                    }

                    // potentially adjusting block_index must be done AFTER verifying block

                    if (wpc->open_flags & OPEN_STREAMING)
                        SET_BLOCK_INDEX (wps->wphdr, wps->sample_index = 0);
                    else
                        SET_BLOCK_INDEX (wps->wphdr, GET_BLOCK_INDEX (wps->wphdr) - wpc->initial_index);

                    memcpy (wps->blockbuff, &wps->wphdr, 32);

                    // if this block has audio, and we're in hybrid lossless mode, read the matching wvc block

                    if (wpc->wvc_flag)
                        read_wvc_block (wpc);

                    // initialize the unpacker for this block

                    if (!unpack_init (wpc))
                        wpc->crc_errors++;

                    wps->init_done = true;
                }
                else
                    wps = wpc->streams [wpc->current_stream];

                // unpack the correct number of samples (either mono or stereo) into the temp buffer

#if ENABLE_DSD
                if (wps->wphdr.flags & DSD_FLAG)
                    unpack_dsd_samples (wpc, src = temp_buffer, samples_to_unpack);
                else
#endif
                    unpack_samples (wpc, src = temp_buffer, samples_to_unpack);

                samcnt = samples_to_unpack;
                dst = bptr + offset;

                // if the block is mono, copy the samples from the single channel into the destination
                // using num_channels as the stride

                if (wps->wphdr.flags & MONO_FLAG) {
                    while (samcnt--) {
                        dst [0] = *src++;
                        dst += num_channels;
                    }

                    offset++;
                }

                // if the block is stereo, and we don't have room for two more channels, just copy one
                // and flag an error

                else if (offset == num_channels - 1) {
                    while (samcnt--) {
                        dst [0] = src [0];
                        dst += num_channels;
                        src += 2;
                    }

                    wpc->crc_errors++;
                    offset++;
                }

                // otherwise copy the stereo samples into the destination

                else {
                    while (samcnt--) {
                        dst [0] = *src++;
                        dst [1] = *src++;
                        dst += num_channels;
                    }

                    offset += 2;
                }

                // check several clues that we're done with this set of blocks and exit if we are; else do next stream

                if ((wps->wphdr.flags & FINAL_BLOCK) || wpc->current_stream == wpc->max_streams - 1 || offset == num_channels)
                    break;
                else
                    wpc->current_stream++;
            }

            // if we didn't get all the channels we expected, mute the buffer and flag an error

            if (offset != num_channels) {
                if (wps->wphdr.flags & DSD_FLAG) {
                    int samples_to_zero = samples_to_unpack * num_channels;
                    int32_t *zptr = bptr;

                    while (samples_to_zero--)
                        *zptr++ = 0x55;
                }
                else
                    memset (bptr, 0, samples_to_unpack * num_channels * 4);

                wpc->crc_errors++;
            }

            // go back to the first stream (we're going to leave them all loaded for now because they might have more samples)
            // and free the temp buffer

            wps = wpc->streams [wpc->current_stream = 0];
            free (temp_buffer);
        }
        // catch the error situation where we have only one channel but run into a stereo block
        // (this avoids overwriting the caller's buffer)
        else if (!(wps->wphdr.flags & MONO_FLAG) && (num_channels == 1 || wpc->reduced_channels == 1)) {
            memset (bptr, 0, samples_to_unpack * sizeof (*bptr));
            wps->sample_index += samples_to_unpack;
            wpc->crc_errors++;
        }
#if ENABLE_DSD
        else if (wps->wphdr.flags & DSD_FLAG)
            unpack_dsd_samples (wpc, bptr, samples_to_unpack);
#endif
        else
            unpack_samples (wpc, bptr, samples_to_unpack);

        if (file_done) {
            strcpy (wpc->error_message, "can't read all of last block!");
            break;
        }

        if (wpc->reduced_channels)
            bptr += samples_to_unpack * wpc->reduced_channels;
        else
            bptr += samples_to_unpack * num_channels;

        samples_unpacked += samples_to_unpack;
        samples -= samples_to_unpack;

        // if we just finished a block, check for a calculated crc error
        // (and back up the streams a little if possible in case we passed a header)

        if (wps->sample_index == GET_BLOCK_INDEX (wps->wphdr) + wps->wphdr.block_samples) {
            if (check_crc_error (wpc)) {
                int32_t *zptr = bptr, zvalue = (wps->wphdr.flags & DSD_FLAG) ? 0x55 : 0;
                uint32_t samples_to_zero = wps->wphdr.block_samples;

                if (samples_to_zero > samples_to_unpack)
                    samples_to_zero = samples_to_unpack;

                samples_to_zero *= (wpc->reduced_channels ? wpc->reduced_channels : num_channels);

                while (samples_to_zero--)
                    *--zptr = zvalue;

                if (wps->blockbuff && wpc->reader->can_seek (wpc->wv_in)) {
                    int32_t rseek = ((WavpackHeader *) wps->blockbuff)->ckSize / 3;
                    wpc->reader->set_pos_rel (wpc->wv_in, (rseek > 16384) ? -16384 : -rseek, SEEK_CUR);
                }

                if (wpc->wvc_flag && wps->block2buff && wpc->reader->can_seek (wpc->wvc_in)) {
                    int32_t rseek = ((WavpackHeader *) wps->block2buff)->ckSize / 3;
                    wpc->reader->set_pos_rel (wpc->wvc_in, (rseek > 16384) ? -16384 : -rseek, SEEK_CUR);
                }

                wpc->crc_errors++;
            }
        }

        if (wpc->total_samples != -1 && wps->sample_index == wpc->total_samples)
            break;
    }

#if ENABLE_DSD
    if (wpc->decimation_context)
        decimate_dsd_run (wpc->decimation_context, buffer, samples_unpacked);
#endif

    return samples_unpacked;
}
